<!DOCTYPE html><html lang="en" class="scroll-smooth"><head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v3.0.1"><!-- Canonical URL --><link rel="canonical" href="https://swordtraveller.github.io/go-spec-trans/post/go-specification/"><!-- Primary Meta Tags --><title>The Go Programming Language Specification • Astro Theme OpenBlog</title><meta name="title" content="The Go Programming Language Specification • Astro Theme OpenBlog"><meta name="description" content="Translation of The Go Programming Language Specification"><meta name="author" content="DanielCG"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://swordtraveller.github.io/go-spec-trans/post/go-specification/"><meta property="og:title" content="The Go Programming Language Specification"><meta property="og:description" content="Translation of The Go Programming Language Specification"><meta property="og:image" content="https://swordtraveller.github.io/open-graph.png"><meta property="article:author" content="DanielCG"><meta property="article:published_time" content="2023-09-29T16:00:00.000Z"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://swordtraveller.github.io/go-spec-trans/post/go-specification/"><meta property="twitter:title" content="The Go Programming Language Specification"><meta property="twitter:description" content="Translation of The Go Programming Language Specification"><meta property="twitter:image" content="https://swordtraveller.github.io/open-graph.png"><!-- RSS auto-discovery --><link rel="alternate" type="application/rss+xml" title="Astro Theme OpenBlog" href="/rss.xml"><script>
	if (localStorage.theme === 'light' || !('theme' in localStorage)) {
		document.documentElement.classList.remove('dark')
		localStorage.setItem('theme', 'light')
	} else {
		document.documentElement.classList.add('dark')
		localStorage.setItem('theme', 'dark')
	}
</script><script>
	if (!('animations' in localStorage)) {
		localStorage.setItem('animations', 'true')
	} else {
		localStorage.setItem('animations', 'false')
	}
</script><link rel="stylesheet" href="/go-spec-trans/_astro/_...category_.84964881.css" />
<link rel="stylesheet" href="/go-spec-trans/_astro/_...slug_.bc72c999.css" /><script type="module" src="/go-spec-trans/_astro/hoisted.c3d54d2a.js"></script></head><body class="bg-white text-stone-950 dark:bg-[#0a0910] dark:text-white w-full h-full"><main class="px-5 sm:mx-auto sm:max-w-2xl sm:px-8 lg:px-0 antialiased md:max-w-6xl grid gap-12 mt-4 overflow-hidden md:overflow-visible"><header class="relative flex items-center h-12 font-semibold"><a class="text-lg mr-auto" href="/">Home</a><div id="astro-header-drawer" class="shadow rounded-l-lg md:bg-transparent dark:md:bg-transparent bg-white dark:bg-[#0a0910] md:shadow-none md:rounded-none md:border-none md:h-auto md:static absolute transition-transform duration-300 ease-in translate-x-96 md:translate-x-0 top-12 -right-5 pl-4 pt-6 pb-4 md:p-0 h-[200px] w-[200px] z-50"><nav class="flex h-full flex-col justify-between gap-12 text-left md:flex-row md:w-full md:gap-5"><div class="flex flex-col gap-4 md:flex-row md:border-r-2 border-black pr-4 dark:border-white"></div><div class="flex justify-center items-center md:justify-end gap-3 md:p-0"><a href="https://github.com/swordtraveller" class="text-opacity-60" rel="noopener noreferrer " target="_blank" aria-label="Github"><span><svg xmlns="http://www.w3.org/2000/svg" class="w-8 md:w-6" viewBox="0 0 24 24" stroke-width="1.3" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg></span></a></div></nav></div><div class="flex items-center gap-3 md:pl-3"><div><site-search id="search" class="ms-auto"><button data-open-modal disabled class="flex items-center justify-center rounded-md gap-1"><svg aria-label="search" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path stroke="none" d="M0 0h24v24H0z"></path><path d="M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6"></path></svg><!-- <span class='md:hidden text-2xl'> Search</span> --></button><dialog aria-label="search" class="h-full max-h-full w-full max-w-full border border-zinc-400 bg-white dark:bg-[#0a0910ec] shadow backdrop:backdrop-blur sm:mx-auto sm:mb-auto sm:mt-16 sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md opacity-0"><div class="dialog-frame flex flex-col gap-4 p-6 pt-12 sm:pt-6"><button data-close-modal class="ms-auto cursor-pointer rounded-full bg-black text-white px-4 py-2 dark:bg-white dark:text-black">Close</button><div class="search-container dark:text-white"><div id="pagefind__search"></div></div></div></dialog></site-search></div><div class="theme relative cursor-pointer"><span class="sun-logo
						w-fit
						h-fit
						opacity-0
						transition-transform
						duration-500"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-sun-high" width="24" height="24" viewBox="0 0 24 24" stroke-width="1" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z"></path><path d="M6.343 17.657l-1.414 1.414"></path><path d="M6.343 6.343l-1.414 -1.414"></path><path d="M17.657 6.343l1.414 -1.414"></path><path d="M17.657 17.657l1.414 1.414"></path><path d="M4 12h-2"></path><path d="M12 4v-2"></path><path d="M20 12h2"></path><path d="M12 20v2"></path></svg></span><span class="moon-logo w-fit h-fit absolute opacity-0 inset-0 transition-transform duration-500"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.25" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path></svg></span></div><button id="astro-header-drawer-button" type="button" class="md:ml-6 md:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" width="24" height="24" viewBox="0 0 24 24" stroke-width="1.25" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M4 6l16 0"></path><path d="M4 12l16 0"></path><path d="M4 18l16 0"></path></svg><span class="sr-only">Show Menu</span></button></div></header><article class="min-w-full md:py-4 sm:max-w-none md:max-w-none"><header class="mb-3 flex flex-col justify-center items-center gap-6"><div class="flex flex-col gap-2"><div class="flex items-center justify-center gap-x-1"><p class="text-center text-sm text-opacity-50">
Published <time class="text-sm font-bold text-opacity-60" datetime="2023-09-29T16:00:00.000Z">Sep 30, 2023</time></p><p class="text-center text-sm text-opacity-50 font-bold">
- 392 min read</p></div><h1 class="title text-center text-4xl md:text-6xl md:pb-2.5 font-semibold opacity-0">The Go Programming Language Specification</h1></div><div class="flex flex-wrap justify-center items-center gap-2 gap-y-4 md:gap-5"><span class="bg-indigo-600 font-semibold text-white dark:bg-indigo-900 dark:text-white shadow text-sm w-fit px-2 py-1 md:px-5 md:py-2 rounded-full">Go</span></div></header><div class="relative"><div style="backdrop-filter: blur(25px) saturate(180%);" class="placeholder absolute inset-0 blur rounded-md transition-opacity duration-700 ease-out border-2 border-neutral-200 bg-gray-200 dark:border-neutral-900 dark:bg-zinc-900 bg-opacity-90"></div></div><hr><div><div class="grid grid-cols-1 md:grid-cols-[20%_auto] gap-10 mt-8"><!-- aside  --><aside class="md:flex flex-col gap-8 hidden"><div class="sticky top-24 self-start hidden md:block transition-all duration-200"><nav class="max-w-xs dark:text-black"><h1 class="font-bold mb-3 text-2xl dark:text-white">Index</h1><ul class="[text-wrap:balance] flex flex-col gap-1"><li class="flex flex-col"><a href="#目录" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">目录</a></li><li class="flex flex-col"><a href="#译者前言" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">译者前言</a><ul class="ml-3"><li class="flex flex-col"><a href="#背景" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">背景</a></li><li class="flex flex-col"><a href="#约定" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">约定</a></li><li class="flex flex-col"><a href="#版式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">版式</a></li></ul></li><li class="flex flex-col"><a href="#introduction-介绍" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Introduction 介绍</a></li><li class="flex flex-col"><a href="#notation-表示法" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Notation 表示法</a></li><li class="flex flex-col"><a href="#source-code-representation-源代码表示" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Source code representation 源代码表示</a><ul class="ml-3"><li class="flex flex-col"><a href="#characters-字符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Characters 字符</a></li><li class="flex flex-col"><a href="#letters-and-digits-字母和数字" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Letters and digits 字母和数字</a></li></ul></li><li class="flex flex-col"><a href="#lexical-elements-词法单元" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Lexical elements 词法单元</a><ul class="ml-3"><li class="flex flex-col"><a href="#comments-注释" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Comments 注释</a></li><li class="flex flex-col"><a href="#tokens-分词" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Tokens 分词</a></li><li class="flex flex-col"><a href="#semicolons-分号" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Semicolons 分号</a></li><li class="flex flex-col"><a href="#identifiers-标识符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Identifiers 标识符</a></li><li class="flex flex-col"><a href="#keywords-关键词" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Keywords 关键词</a></li><li class="flex flex-col"><a href="#operators-and-punctuation-运算符和标点符号" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Operators and punctuation 运算符和标点符号</a></li><li class="flex flex-col"><a href="#integer-literals-整数字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Integer literals 整数字面量</a></li><li class="flex flex-col"><a href="#floating-point-literals-浮点字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Floating-point literals 浮点字面量</a></li><li class="flex flex-col"><a href="#imaginary-literals-虚数字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Imaginary literals 虚数字面量</a></li><li class="flex flex-col"><a href="#rune-literals-unicode-字符字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Rune literals Unicode 字符字面量</a></li><li class="flex flex-col"><a href="#string-literals-字符串字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">String literals 字符串字面量</a></li></ul></li><li class="flex flex-col"><a href="#constants-常量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Constants 常量</a></li><li class="flex flex-col"><a href="#variables-变量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Variables 变量</a></li><li class="flex flex-col"><a href="#types-类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Types 类型</a><ul class="ml-3"><li class="flex flex-col"><a href="#boolean-types-布尔类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Boolean types 布尔类型</a></li><li class="flex flex-col"><a href="#numeric-types-数字类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Numeric types 数字类型</a></li><li class="flex flex-col"><a href="#string-types-字符串类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">String types 字符串类型</a></li><li class="flex flex-col"><a href="#array-types-数组类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Array types 数组类型</a></li><li class="flex flex-col"><a href="#slice-types-切片类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Slice types 切片类型</a></li><li class="flex flex-col"><a href="#struct-types-结构体类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Struct types 结构体类型</a></li><li class="flex flex-col"><a href="#pointer-types-指针类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Pointer types 指针类型</a></li><li class="flex flex-col"><a href="#function-types-函数类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Function types 函数类型</a></li><li class="flex flex-col"><a href="#interface-types-接口类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Interface types 接口类型</a><ul class="ml-3"><li class="flex flex-col"><a href="#basic-interfaces-基础接口" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Basic interfaces 基础接口</a></li><li class="flex flex-col"><a href="#embedded-interfaces-内嵌接口" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Embedded interfaces 内嵌接口</a></li><li class="flex flex-col"><a href="#general-interfaces-通用接口" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">General interfaces 通用接口</a></li><li class="flex flex-col"><a href="#implementing-an-interface-实现一个接口" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Implementing an interface 实现一个接口</a></li></ul></li><li class="flex flex-col"><a href="#map-types-map-类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Map types Map 类型</a></li><li class="flex flex-col"><a href="#channel-types-通道类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Channel types 通道类型</a></li></ul></li><li class="flex flex-col"><a href="#properties-of-types-and-values-类型和值的属性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Properties of types and values 类型和值的属性</a><ul class="ml-3"><li class="flex flex-col"><a href="#underlying-types-底层类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Underlying types 底层类型</a></li><li class="flex flex-col"><a href="#core-types-核心类型" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Core types 核心类型</a></li><li class="flex flex-col"><a href="#type-identity-类型标识" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type identity 类型标识</a></li><li class="flex flex-col"><a href="#assignability-可赋值性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Assignability 可赋值性</a></li><li class="flex flex-col"><a href="#representability-可表示性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Representability 可表示性</a></li><li class="flex flex-col"><a href="#method-sets-方法集" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Method sets 方法集</a></li></ul></li><li class="flex flex-col"><a href="#blocks-块" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Blocks 块</a></li><li class="flex flex-col"><a href="#declarations-and-scope-声明和作用域" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Declarations and scope 声明和作用域</a><ul class="ml-3"><li class="flex flex-col"><a href="#label-scopes-标签作用域" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Label scopes 标签作用域</a></li><li class="flex flex-col"><a href="#blank-identifier-空白标识符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Blank identifier 空白标识符</a></li><li class="flex flex-col"><a href="#predeclared-identifiers-预声明标识符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Predeclared identifiers 预声明标识符</a></li><li class="flex flex-col"><a href="#exported-identifiers-导出标识符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Exported identifiers 导出标识符</a></li><li class="flex flex-col"><a href="#uniqueness-of-identifiers-标识符的唯一性" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Uniqueness of identifiers 标识符的唯一性</a></li><li class="flex flex-col"><a href="#constant-declarations-常量声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Constant declarations 常量声明</a></li><li class="flex flex-col"><a href="#iota-枚举" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Iota 枚举</a></li><li class="flex flex-col"><a href="#type-declarations-类型声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type declarations 类型声明</a><ul class="ml-3"><li class="flex flex-col"><a href="#alias-declarations-别名声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Alias declarations 别名声明</a></li><li class="flex flex-col"><a href="#type-definitions-类型定义" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type definitions 类型定义</a></li></ul></li><li class="flex flex-col"><a href="#type-parameter-declarations-类型参数声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type parameter declarations 类型参数声明</a><ul class="ml-3"><li class="flex flex-col"><a href="#type-constraints-类型约束" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type constraints 类型约束</a></li><li class="flex flex-col"><a href="#satisfying-a-type-constraint-满足类型约束" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Satisfying a type constraint 满足类型约束</a></li></ul></li><li class="flex flex-col"><a href="#variable-declarations-变量声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Variable declarations 变量声明</a></li><li class="flex flex-col"><a href="#short-variable-declarations-短变量声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Short variable declarations 短变量声明</a></li><li class="flex flex-col"><a href="#function-declarations-函数声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Function declarations 函数声明</a></li><li class="flex flex-col"><a href="#method-declarations-方法声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Method declarations 方法声明</a></li></ul></li><li class="flex flex-col"><a href="#expressions-表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Expressions 表达式</a><ul class="ml-3"><li class="flex flex-col"><a href="#operands-操作数" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Operands 操作数</a></li><li class="flex flex-col"><a href="#qualified-identifiers-限定标识符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Qualified identifiers 限定标识符</a></li><li class="flex flex-col"><a href="#composite-literals-组合字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Composite literals 组合字面量</a></li><li class="flex flex-col"><a href="#function-literals-函数字面量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Function literals 函数字面量</a></li><li class="flex flex-col"><a href="#primary-expressions-主表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Primary expressions 主表达式</a></li><li class="flex flex-col"><a href="#selectors-选择器" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Selectors 选择器</a></li><li class="flex flex-col"><a href="#method-expressions-方法表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Method expressions 方法表达式</a></li><li class="flex flex-col"><a href="#method-values-方法值" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Method values 方法值</a></li><li class="flex flex-col"><a href="#index-expressions-索引表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Index expressions 索引表达式</a></li><li class="flex flex-col"><a href="#slice-expressions-切片表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Slice expressions 切片表达式</a><ul class="ml-3"><li class="flex flex-col"><a href="#simple-slice-expressions-简单切片表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Simple slice expressions 简单切片表达式</a></li><li class="flex flex-col"><a href="#full-slice-expressions-完整切片表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Full slice expressions 完整切片表达式</a></li></ul></li><li class="flex flex-col"><a href="#type-assertions-类型断言" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type assertions 类型断言</a></li><li class="flex flex-col"><a href="#calls-调用" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Calls 调用</a></li><li class="flex flex-col"><a href="#passing-arguments-to--parameters-传递实参给形如的形参" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Passing arguments to … parameters 传递实参给形如…的形参</a></li><li class="flex flex-col"><a href="#instantiations-实例化" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Instantiations 实例化</a></li><li class="flex flex-col"><a href="#type-inference-类型推断" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type inference 类型推断</a><ul class="ml-3"><li class="flex flex-col"><a href="#type-unification-类型统一" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type unification 类型统一</a></li></ul></li><li class="flex flex-col"><a href="#operators-运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Operators 运算符</a><ul class="ml-3"><li class="flex flex-col"><a href="#operator-precedence-运算符优先级" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Operator precedence 运算符优先级</a></li></ul></li><li class="flex flex-col"><a href="#arithmetic-operators-算术运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Arithmetic operators 算术运算符</a><ul class="ml-3"><li class="flex flex-col"><a href="#integer-operators" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Integer operators</a></li><li class="flex flex-col"><a href="#integer-overflow-整数溢出" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Integer overflow 整数溢出</a></li><li class="flex flex-col"><a href="#floating-point-operators-浮点运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Floating-point operators 浮点运算符</a></li><li class="flex flex-col"><a href="#string-concatenation-字符串连接" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">String concatenation 字符串连接</a></li></ul></li><li class="flex flex-col"><a href="#comparison-operators-比较运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Comparison operators 比较运算符</a></li><li class="flex flex-col"><a href="#logical-operators-逻辑运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Logical operators 逻辑运算符</a></li><li class="flex flex-col"><a href="#address-operators-取地址运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Address operators 取地址运算符</a></li><li class="flex flex-col"><a href="#receive-operator-接收运算符" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Receive operator 接收运算符</a></li><li class="flex flex-col"><a href="#conversions-转换" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Conversions 转换</a><ul class="ml-3"><li class="flex flex-col"><a href="#conversions-between-numeric-types-数值类型之间的转换" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Conversions between numeric types 数值类型之间的转换</a></li><li class="flex flex-col"><a href="#conversions-to-and-from-a-string-type-与字符串类型之间的转换" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Conversions to and from a string type 与字符串类型之间的转换</a></li><li class="flex flex-col"><a href="#conversions-from-slice-to-array-or-array-pointer-从切片到数组或到数组指针的转换" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Conversions from slice to array or array pointer 从切片到数组或到数组指针的转换</a></li></ul></li><li class="flex flex-col"><a href="#constant-expressions-常量表达式" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Constant expressions 常量表达式</a></li><li class="flex flex-col"><a href="#order-of-evaluation-求值顺序" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Order of evaluation 求值顺序</a></li></ul></li><li class="flex flex-col"><a href="#statements-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Statements 语句</a><ul class="ml-3"><li class="flex flex-col"><a href="#terminating-statements-终止语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Terminating statements 终止语句</a></li><li class="flex flex-col"><a href="#empty-statements-空语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Empty statements 空语句</a></li><li class="flex flex-col"><a href="#labeled-statements-标签语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Labeled statements 标签语句</a></li><li class="flex flex-col"><a href="#expression-statements-表达式语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Expression statements 表达式语句</a></li><li class="flex flex-col"><a href="#send-statements-发送语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Send statements 发送语句</a></li><li class="flex flex-col"><a href="#incdec-statements-自增减语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">IncDec statements 自增减语句</a></li><li class="flex flex-col"><a href="#assignment-statements-赋值语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Assignment statements 赋值语句</a></li><li class="flex flex-col"><a href="#if-statements-if-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">If statements If 语句</a></li><li class="flex flex-col"><a href="#switch-statements-switch-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Switch statements Switch 语句</a></li><li class="flex flex-col"><a href="#expression-switches-表达式开关" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Expression switches 表达式开关</a></li><li class="flex flex-col"><a href="#type-switches-类型开关" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type switches 类型开关</a></li><li class="flex flex-col"><a href="#for-statements-for-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">For statements for 语句</a><ul class="ml-3"><li class="flex flex-col"><a href="#for-statements-with-single-condition-单条件-for-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">For statements with single condition 单条件 for 语句</a></li><li class="flex flex-col"><a href="#for-statements-with-for-clause-带-for-子句的-for-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">For statements with for clause 带 for 子句的 for 语句</a></li><li class="flex flex-col"><a href="#for-statements-with-range-clause-带-range-子句的-for-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">For statements with range clause 带 range 子句的 for 语句</a></li></ul></li><li class="flex flex-col"><a href="#go-statements-go-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Go statements Go 语句</a></li><li class="flex flex-col"><a href="#select-statements-select-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Select statements Select 语句</a></li><li class="flex flex-col"><a href="#return-statements-return-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Return statements Return 语句</a></li><li class="flex flex-col"><a href="#break-statements-break-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Break statements Break 语句</a></li><li class="flex flex-col"><a href="#continue-statements-continue-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Continue statements Continue 语句</a></li><li class="flex flex-col"><a href="#goto-statements-goto-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Goto statements Goto 语句</a></li><li class="flex flex-col"><a href="#fallthrough-statements-fallthrough-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Fallthrough statements fallthrough 语句</a></li><li class="flex flex-col"><a href="#defer-statements-defer语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Defer statements defer语句</a></li></ul></li><li class="flex flex-col"><a href="#built-in-functions-内置函数" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Built-in functions 内置函数</a><ul class="ml-3"><li class="flex flex-col"><a href="#close-关闭通道" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Close 关闭（通道）</a></li><li class="flex flex-col"><a href="#length-and-capacity-长度和容量" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Length and capacity 长度和容量</a></li><li class="flex flex-col"><a href="#allocation-分配" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Allocation 分配</a><ul class="ml-3"><li class="flex flex-col"><a href="#for-instance-例如" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">For instance 例如</a></li></ul></li><li class="flex flex-col"><a href="#making-slices-maps-and-channels-创建切片map和通道" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Making slices, maps and channels 创建切片、map和通道</a></li><li class="flex flex-col"><a href="#appending-to-and-copying-slices-追加元素到和拷贝切片" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Appending to and copying slices 追加（元素到）和拷贝切片</a><ul class="ml-3"><li class="flex flex-col"><a href="#examples-例子" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Examples: 例子：</a></li></ul></li><li class="flex flex-col"><a href="#deletion-of-map-elements-删除map元素" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Deletion of map elements 删除map元素</a></li><li class="flex flex-col"><a href="#manipulating-complex-numbers-操纵复数" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Manipulating complex numbers 操纵复数</a></li><li class="flex flex-col"><a href="#handling-panics-处理panic" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Handling panics 处理panic</a></li><li class="flex flex-col"><a href="#bootstrapping-引导" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Bootstrapping 引导</a></li></ul></li><li class="flex flex-col"><a href="#packages-包" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Packages 包</a><ul class="ml-3"><li class="flex flex-col"><a href="#source-file-organization-源文件组织" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Source file organization 源文件组织</a></li><li class="flex flex-col"><a href="#package-clause-package-语句" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Package clause package 语句</a></li><li class="flex flex-col"><a href="#import-declarations-import-声明" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Import declarations import 声明</a></li><li class="flex flex-col"><a href="#an-example-package-一个示例包" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">An example package 一个示例包</a></li></ul></li><li class="flex flex-col"><a href="#program-initialization-and-execution-程序初始化和执行" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Program initialization and execution 程序初始化和执行</a><ul class="ml-3"><li class="flex flex-col"><a href="#the-zero-value-零值" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">The zero value 零值</a></li><li class="flex flex-col"><a href="#package-initialization-包的初始化" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Package initialization 包的初始化</a></li><li class="flex flex-col"><a href="#program-execution-程序执行" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Program execution 程序执行</a></li></ul></li><li class="flex flex-col"><a href="#errors-错误" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Errors 错误</a></li><li class="flex flex-col"><a href="#run-time-panics-运行时panic" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Run-time panics 运行时panic</a></li><li class="flex flex-col"><a href="#system-considerations-系统注意事项" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">System considerations 系统注意事项</a><ul class="ml-3"><li class="flex flex-col"><a href="#package-unsafe-unsafe包" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Package unsafe unsafe包</a></li><li class="flex flex-col"><a href="#size-and-alignment-guarantees-大小与对齐保证" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Size and alignment guarantees 大小与对齐保证</a></li></ul></li><li class="flex flex-col"><a href="#appendix-附录" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Appendix 附录</a><ul class="ml-3"><li class="flex flex-col"><a href="#type-unification-rules-类型统一规则" class="bg-slate-200 dark:bg-slate-800 dark:hover:bg-indigo-400 hover:bg-indigo-300 hover:text-white py-1 px-4 dark:text-white rounded-full mb-2 first-letter:uppercase w-fit line-clamp-2">Type unification rules 类型统一规则</a></li></ul></li></ul></nav></div></aside><!-- post --><article class="max-w-full w-full"><div class="prose prose-lg md:prose-xl dark:prose-invert mb-12 min-w-full"><p>Version of Aug 2, 2023</p>
<h2 id="目录">目录</h2>
<ul>
<li><a href="#introduction-%E4%BB%8B%E7%BB%8D">Introduction 介绍</a></li>
<li><a href="#notation-%E8%A1%A8%E7%A4%BA%E6%B3%95">Notation 表示法</a></li>
<li><a href="#source-code-representation-%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA">Source code representation 源代码表示</a>
<ul>
<li><a href="#characters-%E5%AD%97%E7%AC%A6">Characters 字符</a></li>
<li><a href="#letters-and-digits-%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97">Letters and digits 字母和数字</a></li>
</ul>
</li>
<li><a href="#lexical-elements-%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83">Lexical elements 词法单元</a>
<ul>
<li><a href="#comments-%E6%B3%A8%E9%87%8A">Comments 注释</a></li>
<li><a href="#tokens-%E5%88%86%E8%AF%8D">Tokens 分词</a></li>
<li><a href="#semicolons-%E5%88%86%E5%8F%B7">Semicolons 分号</a></li>
<li><a href="#identifiers-%E6%A0%87%E8%AF%86%E7%AC%A6">Identifiers 标识符</a></li>
<li><a href="#keywords-%E5%85%B3%E9%94%AE%E8%AF%8D">Keywords 关键词</a></li>
<li><a href="#operators-and-punctuation-%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7">Operators and punctuation 运算符和标点符号</a></li>
<li><a href="#integer-literals-%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F">Integer literals 整数字面量</a></li>
<li><a href="#floating-point-literals-%E6%B5%AE%E7%82%B9%E5%AD%97%E9%9D%A2%E9%87%8F">Floating-point literals 浮点字面量</a></li>
<li><a href="#imaginary-literals-%E8%99%9A%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F">Imaginary literals 虚数字面量</a></li>
<li><a href="#rune-literals-unicode-%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F">Rune literals Unicode字符字面量</a></li>
<li><a href="#string-literals-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F">String literals 字符串字面量</a></li>
</ul>
</li>
<li><a href="#constants-%E5%B8%B8%E9%87%8F">Constants 常量</a></li>
<li><a href="#variables-%E5%8F%98%E9%87%8F">Variables 变量</a></li>
<li><a href="#types-%E7%B1%BB%E5%9E%8B">Types 类型</a>
<ul>
<li><a href="#boolean-types-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B">Boolean types 布尔类型</a></li>
<li><a href="#numeric-types-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B">Numeric types 数字类型</a></li>
<li><a href="#string-types-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B">String types 字符串类型</a></li>
<li><a href="#array-types-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B">Array types 数组类型</a></li>
<li><a href="#slice-types-%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B">Slice types 切片类型</a></li>
<li><a href="#struct-types-%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B">Struct types 结构体类型</a></li>
<li><a href="#pointer-types-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B">Pointer types 指针类型</a></li>
<li><a href="#function-types-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B">Function types 函数类型</a></li>
<li><a href="#interface-types-%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B">Interface types 接口类型</a></li>
<li><a href="#map-types-map-%E7%B1%BB%E5%9E%8B">Map types map 类型</a></li>
<li><a href="#channel-types-%E9%80%9A%E9%81%93%E7%B1%BB%E5%9E%8B">Channel types 通道类型</a></li>
</ul>
</li>
<li><a href="#properties-of-types-and-values-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC%E7%9A%84%E5%B1%9E%E6%80%A7">Properties of types and values 类型和值的属性</a>
<ul>
<li><a href="#underlying-types-%E5%BA%95%E5%B1%82%E7%B1%BB%E5%9E%8B">Underlying types 底层类型</a></li>
<li><a href="#core-types-%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9E%8B">Core types 核心类型</a></li>
<li><a href="#type-identity-%E7%B1%BB%E5%9E%8B%E6%A0%87%E8%AF%86">Type identity 类型标识</a></li>
<li><a href="#assignability-%E5%8F%AF%E8%B5%8B%E5%80%BC%E6%80%A7">Assignability 可赋值性</a></li>
<li><a href="#representability-%E5%8F%AF%E8%A1%A8%E7%A4%BA%E6%80%A7">Representability 可表示性</a></li>
<li><a href="#method-sets-%E6%96%B9%E6%B3%95%E9%9B%86">Method sets 方法集</a></li>
</ul>
</li>
<li><a href="#blocks-%E5%9D%97">Blocks 块</a></li>
<li><a href="#declarations-and-scope-%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">Declarations and scope 声明和作用域</a>
<ul>
<li><a href="#label-scopes-%E6%A0%87%E7%AD%BE%E4%BD%9C%E7%94%A8%E5%9F%9F">Label scopes 标签作用域</a></li>
<li><a href="#blank-identifier-%E7%A9%BA%E7%99%BD%E6%A0%87%E8%AF%86%E7%AC%A6">Blank identifier 空白标识符</a></li>
<li><a href="#predeclared-identifiers-%E9%A2%84%E5%A3%B0%E6%98%8E%E6%A0%87%E8%AF%86%E7%AC%A6">Predeclared identifiers 预声明标识符</a></li>
<li><a href="#exported-identifiers-%E5%AF%BC%E5%87%BA%E6%A0%87%E8%AF%86%E7%AC%A6">Exported identifiers 导出标识符</a></li>
<li><a href="#uniqueness-of-identifiers-%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7">Uniqueness of identifiers 标识符的唯一性</a></li>
<li><a href="#constant-declarations-%E5%B8%B8%E9%87%8F%E5%A3%B0%E6%98%8E">Constant declarations 常量声明</a></li>
<li><a href="#iota-%E6%9E%9A%E4%B8%BE">Iota 枚举</a></li>
<li><a href="#type-declarations-%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E">Type declarations 类型声明</a></li>
<li><a href="#type-parameter-declarations-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%A3%B0%E6%98%8E">Type parameter declarations 类型参数声明</a></li>
<li><a href="#variable-declarations-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">Variable declarations 变量声明</a></li>
<li><a href="#short-variable-declarations-%E7%9F%AD%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E">Short variable declarations 短变量声明</a></li>
<li><a href="#function-declarations-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">Function declarations 函数声明</a></li>
<li><a href="#method-declarations-%E6%96%B9%E6%B3%95%E5%A3%B0%E6%98%8E">Method declarations 方法声明</a></li>
</ul>
</li>
<li><a href="#expressions-%E8%A1%A8%E8%BE%BE%E5%BC%8F">Expressions 表达式</a>
<ul>
<li><a href="#operands-%E6%93%8D%E4%BD%9C%E6%95%B0">Operands 操作数</a></li>
<li><a href="#qualified-identifiers-%E9%99%90%E5%AE%9A%E6%A0%87%E8%AF%86%E7%AC%A6">Qualified identifiers 限定标识符</a></li>
<li><a href="#composite-literals-%E7%BB%84%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F">Composite literals 组合字面量</a></li>
<li><a href="#function-literals-%E5%87%BD%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F">Function literals 函数字面量</a></li>
<li><a href="#primary-expressions-%E4%B8%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F">Primary expressions 主表达式</a></li>
<li><a href="#selectors-%E9%80%89%E6%8B%A9%E5%99%A8">Selectors 选择器</a></li>
<li><a href="#method-expressions-%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F">Method expressions 方法表达式</a></li>
<li><a href="#method-values-%E6%96%B9%E6%B3%95%E5%80%BC">Method values 方法值</a></li>
<li><a href="#index-expressions-%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%BE%BE%E5%BC%8F">Index expressions 索引表达式</a></li>
<li><a href="#slice-expressions-%E5%88%87%E7%89%87%E8%A1%A8%E8%BE%BE%E5%BC%8F">Slice expressions 切片表达式</a></li>
<li><a href="#type-assertions-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80">Type assertions 类型断言</a></li>
<li><a href="#calls-%E8%B0%83%E7%94%A8">Calls 调用</a></li>
<li><a href="#passing-arguments-to--parameters-%E4%BC%A0%E9%80%92%E5%AE%9E%E5%8F%82%E7%BB%99%E5%BD%A2%E5%A6%82%E7%9A%84%E5%BD%A2%E5%8F%82">Passing arguments to … parameters 传递实参给形如…的形参</a></li>
<li><a href="#instantiations-%E5%AE%9E%E4%BE%8B%E5%8C%96">Instantiations 实例化</a></li>
<li><a href="#type-inference-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">Type inference 类型推断</a></li>
<li><a href="#operators-%E8%BF%90%E7%AE%97%E7%AC%A6">Operators 运算符</a></li>
<li><a href="#arithmetic-operators-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">Arithmetic operators 算术运算符</a></li>
<li><a href="#comparison-operators-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">Comparison operators 比较运算符</a></li>
<li><a href="#logical-operators-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">Logical operators 逻辑运算符</a></li>
<li><a href="#address-operators-%E5%8F%96%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6">Address operators 取地址运算符</a></li>
<li><a href="#receive-operator-%E6%8E%A5%E6%94%B6%E8%BF%90%E7%AE%97%E7%AC%A6">Receive operator 接收运算符</a></li>
<li><a href="#conversions-%E8%BD%AC%E6%8D%A2">Conversions 转换</a></li>
<li><a href="#constant-expressions-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">Constant expressions 常量表达式</a></li>
<li><a href="#order-of-evaluation-%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F">Order of evaluation 求值顺序</a></li>
</ul>
</li>
<li><a href="#statements-%E8%AF%AD%E5%8F%A5">Statements 语句</a>
<ul>
<li><a href="#terminating-statements-%E7%BB%88%E6%AD%A2%E8%AF%AD%E5%8F%A5">Terminating statements 终止语句</a></li>
<li><a href="#empty-statements-%E7%A9%BA%E8%AF%AD%E5%8F%A5">Empty statements 空语句</a></li>
<li><a href="#labeled-statements-%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5">Labeled statements 标签语句</a></li>
<li><a href="#expression-statements-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E5%8F%A5">Expression statements 表达式语句</a></li>
<li><a href="#send-statements-%E5%8F%91%E9%80%81%E8%AF%AD%E5%8F%A5">Send statements 发送语句</a></li>
<li><a href="#incdec-statements-%E8%87%AA%E5%A2%9E%E5%87%8F%E8%AF%AD%E5%8F%A5">IncDec statements 自增减语句</a></li>
<li><a href="#assignment-statements-%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">Assignment statements 赋值语句</a></li>
<li><a href="#if-statements-if-%E8%AF%AD%E5%8F%A5">If statements if 语句</a></li>
<li><a href="#switch-statements-switch-%E8%AF%AD%E5%8F%A5">Switch statements switch 语句</a></li>
<li><a href="#for-statements-for-%E8%AF%AD%E5%8F%A5">For statements for 语句</a></li>
<li><a href="#go-statements-go-%E8%AF%AD%E5%8F%A5">Go statements go 语句</a></li>
<li><a href="#select-statements-select-%E8%AF%AD%E5%8F%A5">Select statements select 语句</a></li>
<li><a href="#return-statements-return-%E8%AF%AD%E5%8F%A5">Return statements return 语句</a></li>
<li><a href="#break-statements-break-%E8%AF%AD%E5%8F%A5">Break statements break 语句</a></li>
<li><a href="#continue-statements-continue-%E8%AF%AD%E5%8F%A5">Continue statements continue 语句</a></li>
<li><a href="#goto-statements-goto-%E8%AF%AD%E5%8F%A5">Goto statements goto 语句</a></li>
<li><a href="#fallthrough-statements-fallthrough-%E8%AF%AD%E5%8F%A5">Fallthrough statements fallthrough 语句</a></li>
<li><a href="#defer-statements-defer%E8%AF%AD%E5%8F%A5">Defer statements defer 语句</a></li>
</ul>
</li>
<li><a href="#built-in-functions-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">Built-in functions 内置函数</a>
<ul>
<li><a href="">Appending to and copying slices</a></li>
<li><a href="">Clear</a></li>
<li><a href="#close-%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93">Close 关闭通道</a></li>
<li><a href="#manipulating-complex-numbers-%E6%93%8D%E7%BA%B5%E5%A4%8D%E6%95%B0">Manipulating complex numbers 操纵复数</a></li>
<li><a href="#deletion-of-map-elements-%E5%88%A0%E9%99%A4map%E5%85%83%E7%B4%A0">Deletion of map elements 删除map元素</a></li>
<li><a href="#length-and-capacity-%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F">Length and capacity 长度和容量</a></li>
<li><a href="">Making slices, maps and channels</a></li>
<li><a href="">Min and max</a></li>
<li><a href="#allocation-%E5%88%86%E9%85%8D">Allocation 分配</a></li>
<li><a href="#handling-panics-%E5%A4%84%E7%90%86panic">Handling panics 处理panic</a></li>
<li><a href="#bootstrapping-%E5%BC%95%E5%AF%BC">Bootstrapping 引导</a></li>
</ul>
</li>
<li><a href="#packages-%E5%8C%85">Packages 包</a>
<ul>
<li><a href="#source-file-organization-%E6%BA%90%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87">Source file organization 源文件组织</a></li>
<li><a href="#package-clause-package-%E8%AF%AD%E5%8F%A5">Package clause package 语句</a></li>
<li><a href="#import-declarations-import-%E5%A3%B0%E6%98%8E">Import declarations 声明</a></li>
<li><a href="#an-example-package-%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B%E5%8C%85">An example package 一个示例包</a></li>
</ul>
</li>
<li><a href="">Program initialization and execution</a>
<ul>
<li><a href="#the-zero-value-%E9%9B%B6%E5%80%BC">The zero value 零值</a></li>
<li><a href="#package-initialization-%E5%8C%85%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">Package initialization 包的初始化</a></li>
<li><a href="">Program initialization</a></li>
<li><a href="#program-execution-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C">Program execution 程序执行</a></li>
</ul>
</li>
<li><a href="#errors-%E9%94%99%E8%AF%AF">Errors 错误</a></li>
<li><a href="#run-time-panics-%E8%BF%90%E8%A1%8C%E6%97%B6panic">Run-time panics 运行时panic</a></li>
<li><a href="#system-considerations-%E7%B3%BB%E7%BB%9F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">System considerations 系统注意事项</a>
<ul>
<li><a href="#package-unsafe-unsafe%E5%8C%85">Package unsafe unsafe 包</a></li>
<li><a href="#size-and-alignment-guarantees-%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%AF%B9%E9%BD%90%E4%BF%9D%E8%AF%81">Size and alignment guarantees 大小与对齐保证</a></li>
</ul>
</li>
<li><a href="#appendix-%E9%99%84%E5%BD%95">Appendix 附录</a>
<ul>
<li><a href="#type-unification-rules-%E7%B1%BB%E5%9E%8B%E7%BB%9F%E4%B8%80%E8%A7%84%E5%88%99">Type unification rules 类型统一规则</a></li>
</ul>
</li>
</ul>
<h2 id="译者前言">译者前言</h2>
<h3 id="背景">背景</h3>
<p><a href="https://go.dev/ref/spec">The Go Programming Language Specification</a> 是非常好的 Go 语言详解资料，但原文使用英文写作，无形之中有一道语言门槛。</p>
<p>网络上也有一些优秀的译作珠玉在前，但也有些瑕疵，诸如对于机器翻译的内容没有仔细甄别便加以使用，须知机器翻译往往只是针对提供的单个语句本身进行翻译，并没有充分考虑上下文的意图，对计算机领域特别是 Go 语言方面的专业术语也缺乏进一步的深化理解，常常驴头不对马嘴，反而给读者以误导。例如，机器翻译往往把 <code>literal</code> 不加区分地翻译成“文字”，但在本文语境中的大多数时候却应该翻译为“字面量”更符合编程领域的用语习惯；机器翻译往往把 <code>scope</code> 统统译为“范围”，但在这里解为编程专业术语“作用域”却更准确。诸如此类问题，在网络资料中不胜枚举。</p>
<p>出于深入学习 Go 语言、为原文的推广做一点工作的目的，特翻译此文；原文约有四万余单词，译文约有三万余汉字，深感艰辛与不易；限于本人水平，一定还有许多疏漏，感谢读者将来的斧正。</p>
<h3 id="约定">约定</h3>
<p>本文的翻译，尽可能按照如下约定进行：</p>
<ol>
<li>如背景一节中所言，会尽量使用编程语言中的专业术语来组织译文；</li>
<li>翻译不强求与原文逐词逐字一一对应，那样虽然“精确”，但形成的译文却十分刻板；本文尽力让译文更加符合汉语的表达习惯，力求通顺流畅，对于原文省略的部分会适度补充；</li>
<li>原文限于篇幅，或者默认读者已经掌握，并没有对提到的一些概念详加介绍，但实际上许多读者不具备这些概念的背景知识，理解产生了困难；因此用斜体字增注了“<em>编者按</em>”的内容，这些按语并不是原文中的内容，而是本人结合自己理解、查阅各种资料而加上的；</li>
<li>尽量减少“它”等代词的使用，由于上下文往往长篇大论，读者有时不易认清“它”指的究竟是哪一个，因此本文直接写出“它”具体是什么，而不是用一代词以蔽之。</li>
<li>原文会随着 Go 语言的版本演进适时修订，本人在精力有余的情况下也会尽快更新；</li>
</ol>
<h3 id="版式">版式</h3>
<p>本篇为双语对照翻译，版式如下：</p>
<blockquote>
<p>original text</p>
</blockquote>
<p>译文</p>
<p><em>译者按</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// Code block in the original text</span></span>
<span class="line"><span style="color:#89DDFF">package</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">main</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">import</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">&quot;</span><span style="color:#FFCB6B">fmt</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#89DDFF">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">main</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">Hello World</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<h2 id="introduction-介绍">Introduction 介绍</h2>
<blockquote>
<p>This is the reference manual for the Go programming language. The pre-Go1.18 version, without generics, can be found here. For more information and other documents, see golang.org.</p>
</blockquote>
<p>这是 Go 语言的参考手册。这里是关于 Go 1.18 以前的版本，并不包括泛型特性。更多详情，敬请参阅 <a href="https://golang.org">golang.org</a> 。</p>
<p><em>这段话是早期版本的 Go 语言参考手册中写的，当时主要介绍的还是 1.18 版本以前的内容，没有重点展开泛型相关的内容；但是这篇手册历经多次修订，现在的许多章节中其实已经包含了大量泛型相关的介绍。</em><br/>
<em>Go 官方也提供了对泛型的专门介绍资料：<a href="https://go.dev/doc/tutorial/generics">Tutorial: Getting started with generics</a> 和 <a href="https://go.dev/blog/intro-generics">An Introduction To Generics</a> 。</em></p>
<blockquote>
<p>Go is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies.</p>
</blockquote>
<p>Go 是一门深思熟虑设计出的系统编程的通用语言。它强类型、带垃圾回收、显式支持并发编程。程序由支持有效的依赖管理的包所组织起来。</p>
<blockquote>
<p>The syntax is compact and simple to parse, allowing for easy analysis by automatic tools such as integrated development environments.</p>
</blockquote>
<p>语法紧凑、易于分析。这使得集成开发环境（IDE）之类的自动化工具分析起来很容易。</p>
<h2 id="notation-表示法">Notation 表示法</h2>
<blockquote>
<p>The syntax is specified using a variant of Extended Backus-Naur Form (EBNF):</p>
</blockquote>
<p>语法通过一种扩展巴科斯-瑙尔范式 (EBNF) 的变体来明确：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Syntax      = { Production } .</span></span>
<span class="line"><span style="color:#babed8">Production  = production_name &quot;=&quot; [ Expression ] &quot;.&quot; .</span></span>
<span class="line"><span style="color:#babed8">Expression  = Term { &quot;|&quot; Term } .</span></span>
<span class="line"><span style="color:#babed8">Term        = Factor { Factor } .</span></span>
<span class="line"><span style="color:#babed8">Factor      = production_name | token [ &quot;…&quot; token ] | Group | Option | Repetition .</span></span>
<span class="line"><span style="color:#babed8">Group       = &quot;(&quot; Expression &quot;)&quot; .</span></span>
<span class="line"><span style="color:#babed8">Option      = &quot;[&quot; Expression &quot;]&quot; .</span></span>
<span class="line"><span style="color:#babed8">Repetition  = &quot;{&quot; Expression &quot;}&quot; .</span></span></code></pre>
<p><em>巴科斯-瑙尔范式，是编程语言理论（Programming language theory）中的概念，是一种用于表示上下文无关文法的语言。这里主要是谈 Go 语言语法的设计由来。</em></p>
<blockquote>
<p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p>
</blockquote>
<p>产生式是由要素和以下运算符构造的表达式，优先级逐步递增：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">|   alternation</span></span>
<span class="line"><span style="color:#babed8">()  grouping</span></span>
<span class="line"><span style="color:#babed8">[]  option (0 or 1 times)</span></span>
<span class="line"><span style="color:#babed8">{}  repetition (0 to n times)</span></span></code></pre>
<p><em>产生式的意思是，当我们使用巴科斯-瑙尔范式去描述一门语言的设计时，需要像“表示法”章节开头的第一个代码块那样定义许多规则，每一条规则就是一个产生式。</em></p>
<blockquote>
<p>Lowercase production names are used to identify lexical (terminal) tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes &quot;&quot; or back quotes <code> </code> .</p>
</blockquote>
<p>小写的产生式名用标识词法（终结符）的 tokens 来标记。非终结符采用驼峰命名法。词法标记用双引号 &quot;&quot; 或反引号 <code> </code> 括起来。</p>
<p><em>规则中的词素和标记等称为终结符，终结符是不可再分的最小单位；</em><br/>
<em>非终结符还可以再分，直到分解为一组终结符序列。非终结符是可以被取代的符号。</em></p>
<blockquote>
<p>The form a … b represents the set of characters from a through b as alternatives. The horizontal ellipsis … is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character … (as opposed to the three characters …) is not a token of the Go language.</p>
</blockquote>
<p>形式 <code>a … b</code> 表示从 a 到 b 的候选字符集。水平省略号 <code>…</code> 在本规范中的其他地方也常用来非正式地表示没有进一步详细具体说明的各种枚举或者代码片段。字符 <code>…</code> （与三个字符 <code>...</code> 相对）并不是 Go 语言中的 token 。</p>
<h2 id="source-code-representation-源代码表示">Source code representation 源代码表示</h2>
<blockquote>
<p>Source code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.</p>
</blockquote>
<p>源代码是基于 UTF-8 编码的 Unicode 文本。文本没有规范化，所以单个的重音码点与由重音和字母组合成的同一个字符并不同；它们被视为两个码点。简单起见，本文将使用非限定的术语“字符”来引用源代码文本中的 Unicode 码点。</p>
<p><em>像 é 这样的字符就是有重音的字符。 é 这种字符可以由单个的重音码点 \u00E9 得来，也可以由重音和字母组合 \u0065\u0301 得来；</em><br/>
<em>但是虽然 \u00E9 是 é ， \u0065\u0301 也是 é ，但 Go 语言却并不认为 \u00E9 和 \u0065\u0301 是同一的；</em><br/>
<em>请看如下译者补充的代码示意：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">package</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">main</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">import</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">&quot;</span><span style="color:#FFCB6B">fmt</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">&quot;</span><span style="color:#FFCB6B">strconv</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#89DDFF">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">main</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	single </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8">\u00E9</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#BABED8">	combine </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8">\u0065\u0301</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">single: </span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u00E9 转换为 </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> single</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">combine: </span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u0065</span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u0301 转换为 </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> combine</span><span style="color:#89DDFF">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF;font-style:italic">if</span><span style="color:#BABED8"> single </span><span style="color:#89DDFF">==</span><span style="color:#BABED8"> combine </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">		fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">single和combine是相同的</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">}</span><span style="color:#BABED8"> </span><span style="color:#89DDFF;font-style:italic">else</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">		fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">single和combine是不同的</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u00E9 的长度是 </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> strconv</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Itoa</span><span style="color:#89DDFF">(</span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">single</span><span style="color:#89DDFF">))</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D"> 字节</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Println</span><span style="color:#89DDFF">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u0065</span><span style="color:#BABED8">\\</span><span style="color:#C3E88D">u0301 的长度是 </span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> strconv</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Itoa</span><span style="color:#89DDFF">(</span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">combine</span><span style="color:#89DDFF">))</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">+</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D"> 字节</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<p><em>输出结果：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">single: \u00E9 转换为 é</span></span>
<span class="line"><span style="color:#babed8">combine: \u0065\u0301 转换为 é</span></span>
<span class="line"><span style="color:#babed8">single和combine是不同的</span></span>
<span class="line"><span style="color:#babed8">\u00E9 的长度是 2 字节</span></span>
<span class="line"><span style="color:#babed8">\u0065\u0301 的长度是 3 字节</span></span></code></pre>
<p><em>其中 \u0301 占了2个字节。</em></p>
<blockquote>
<p>Each code point is distinct; for instance, uppercase and lowercase letters are different characters.</p>
</blockquote>
<p>每个码点都是不同的；比如，大写字母和小写字母就是不同的字符。</p>
<blockquote>
<p>Implementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.</p>
</blockquote>
<p>实现限制：为了与其他工具相兼容，编译器有可能不允许在源文本中使用 NUL 字符 (U+0000)。</p>
<blockquote>
<p>Implementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.</p>
</blockquote>
<p>实现限制：为了与其他工具相兼容，如果 UTF-8 编码的字节顺序标记 (U+FEFF) 是源文本中的第一个 Unicode 代码点，那么编译器可能会忽略它。源中的其他任何地方可能都不允许使用字节顺序标记。</p>
<p><em>字节顺序标记指的就是 Byte Order Mark 即 BOM 。</em></p>
<h3 id="characters-字符">Characters 字符</h3>
<blockquote>
<p>The following terms are used to denote specific Unicode character categories:</p>
</blockquote>
<p>以下术语用来表示特定的 Unicode 字符类别：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">newline        = /* the Unicode code point U+000A */ .</span></span>
<span class="line"><span style="color:#babed8">unicode_char   = /* an arbitrary Unicode code point except newline */ .</span></span>
<span class="line"><span style="color:#babed8">unicode_letter = /* a Unicode code point categorized as &quot;Letter&quot; */ .</span></span>
<span class="line"><span style="color:#babed8">unicode_digit  = /* a Unicode code point categorized as &quot;Number, decimal digit&quot; */ .</span></span></code></pre>
<blockquote>
<p>In The Unicode Standard 8.0, Section 4.5 “General Category” defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.</p>
</blockquote>
<p>在 Unicode 标准的 8.0 版本中，第 4.5 节的“常规类别”定义了一套字符类别。<br/>
Go 对于任何字母类别 Lu, Ll, Lt, Lm 或 Lo 中的所有字符都视为是 Unicode 字母，并将数字类别 Nd 中的所有字符视为是 Unicode 数字。</p>
<h3 id="letters-and-digits-字母和数字">Letters and digits 字母和数字</h3>
<blockquote>
<p>The underscore character _ (U+005F) is considered a lowercase letter.</p>
</blockquote>
<p>下划线字符 _ (U+005F) 被视为一个小写字母。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">letter        = unicode_letter | &quot;_&quot; .</span></span>
<span class="line"><span style="color:#babed8">decimal_digit = &quot;0&quot; … &quot;9&quot; .</span></span>
<span class="line"><span style="color:#babed8">binary_digit  = &quot;0&quot; | &quot;1&quot; .</span></span>
<span class="line"><span style="color:#babed8">octal_digit   = &quot;0&quot; … &quot;7&quot; .</span></span>
<span class="line"><span style="color:#babed8">hex_digit     = &quot;0&quot; … &quot;9&quot; | &quot;A&quot; … &quot;F&quot; | &quot;a&quot; … &quot;f&quot; .</span></span></code></pre>
<p><em>所谓的“下划线字符 _ (U+005F) 被视为一个小写字母。”的说法只适用于源代码表示场合；</em><br/>
<em>在Go语言运行时中， ’_’ 和 ‘\u005F’ 都不是小写字母；</em><br/>
<em>unicode.IsLower(’_’) 和 unicode.IsLower(‘\u005F’) 的值都是 false 。</em></p>
<h2 id="lexical-elements-词法单元">Lexical elements 词法单元</h2>
<h3 id="comments-注释">Comments 注释</h3>
<blockquote>
<p>Comments serve as program documentation. There are two forms:</p>
</blockquote>
<p>注释用作程序文档。它有两种形式：</p>
<blockquote>
<p>Line comments start with the character sequence // and stop at the end of the line.
General comments start with the character sequence /* and stop with the first subsequent character sequence */.
A comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.</p>
</blockquote>
<p>行注释以字符序列 // 开头，并在行尾停止。<br/>
一般性注释以字符序列 /* 开头，以第一个后续字符序列 */ 结束。<br/>
注释不能在字符或是字符串字面量内开始，也不能（嵌套）在注释内开始。不包含换行符的一般性注释就像一个空格。任何其他注释都像换行符。</p>
<h3 id="tokens-分词">Tokens 分词</h3>
<p><em>Token就是Token，非要翻译的话，只能强调它是词法分析领域的“分词”概念。</em></p>
<blockquote>
<p>Tokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.</p>
</blockquote>
<p>Token构成了Go语言的词汇表。<br/>
有四类：标识符、关键字、运算符和标点符号以及字面量。<br/>
凡是由空格 （U+0020）、水平制表符 （U+0009）、回车符 （U+000D） 和换行符 （U+000A） 组成的空格将被忽略，除非它分割了那些本该作为单个token的token。<br/>
此外，换行符或文件结尾可能会触发分号的插入。在将输入划分为token时，下一个token就是能构成有效token的最长字符序列。</p>
<p><em>在Go语言的语句结尾你不需要写分号，因为换行符和文件结尾后面都会被加上分号。</em></p>
<h3 id="semicolons-分号">Semicolons 分号</h3>
<blockquote>
<p>The formal syntax uses semicolons ”;” as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:</p>
</blockquote>
<p>正式语法在许多产生式中使用了分号 ”;” 作为终止符。<br/>
Go 程序可以使用以下两个规则来省略大部分分号：</p>
<blockquote>
<ol>
<li>When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line’s final token if that token is</li>
</ol>
</blockquote>
<p>当输入被分解为 token 时，如果这个 token 是（以下这些），则分号会立即自动插入到 token 流中，在该行的最终 token 之后</p>
<blockquote>
<ul>
<li>an identifier</li>
</ul>
</blockquote>
<p>一个标识符</p>
<blockquote>
<ul>
<li>an integer, floating-point, imaginary, rune, or string literal</li>
</ul>
</blockquote>
<p>一个整数、浮点、虚数、 Unicode 字符或字符串字面量</p>
<blockquote>
<ul>
<li>one of the keywords break, continue, fallthrough, or return</li>
</ul>
</blockquote>
<p>关键字 break, continue, fallthrough, return 之一</p>
<blockquote>
<ul>
<li>one of the operators and punctuation ++, —, ), ], or }</li>
</ul>
</blockquote>
<p>运算符和标点符号 ++, —, ), ], } 之一</p>
<blockquote>
<ol start="2">
<li>To allow complex statements to occupy a single line, a semicolon may be omitted before a closing ”)” or ”}“.</li>
</ol>
</blockquote>
<p>为了允许复杂的语句能占一行，在用于闭合的 ”)” 或 ”}” 之前的分号可以省略掉。</p>
<blockquote>
<p>To reflect idiomatic use, code examples in this document elide semicolons using these rules.</p>
</blockquote>
<p>为了反映习惯用法，本文中的代码示例按照上述规则省略了分号。</p>
<h3 id="identifiers-标识符">Identifiers 标识符</h3>
<blockquote>
<p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.</p>
</blockquote>
<p>标识符命名了程序中的实体，例如变量和类型。<br/>
标识符是一个或多个字母和数字的序列。<br/>
标识符中的第一个字符必须是字母。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">identifier = letter { letter | unicode_digit } .</span></span>
<span class="line"><span style="color:#babed8">a</span></span>
<span class="line"><span style="color:#babed8">_x9</span></span>
<span class="line"><span style="color:#babed8">ThisVariableIsExported</span></span>
<span class="line"><span style="color:#babed8">αβ</span></span></code></pre>
<blockquote>
<p>Some identifiers are predeclared.</p>
</blockquote>
<p>一些标识符是预先声明好的（下文简称“预声明”）。</p>
<h3 id="keywords-关键词">Keywords 关键词</h3>
<blockquote>
<p>The following keywords are reserved and may not be used as identifiers.</p>
</blockquote>
<p>以下关键字保留，不可以用作标识符。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">break        default      func         interface    select</span></span>
<span class="line"><span style="color:#babed8">case         defer        go           map          struct</span></span>
<span class="line"><span style="color:#babed8">chan         else         goto         package      switch</span></span>
<span class="line"><span style="color:#babed8">const        fallthrough  if           range        type</span></span>
<span class="line"><span style="color:#babed8">continue     for          import       return       var</span></span></code></pre>
<h3 id="operators-and-punctuation-运算符和标点符号">Operators and punctuation 运算符和标点符号</h3>
<blockquote>
<p>The following character sequences represent operators (including assignment operators) and punctuation:</p>
</blockquote>
<p>以下字符序列表示运算符（包括赋值运算符）和标点符号：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )</span></span>
<span class="line"><span style="color:#babed8">-    |     -=    |=     ||    &lt;     &lt;=    [    ]</span></span>
<span class="line"><span style="color:#babed8">*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }</span></span>
<span class="line"><span style="color:#babed8">/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;</span></span>
<span class="line"><span style="color:#babed8">%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :</span></span>
<span class="line"><span style="color:#babed8">     &amp;^          &amp;^=          ~</span></span></code></pre>
<h3 id="integer-literals-整数字面量">Integer literals 整数字面量</h3>
<blockquote>
<p>An integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15.</p>
</blockquote>
<p>整数字面量是表示整数常量的数字序列。一个可选的前缀设置了非十进制的基数： 0b 或 0B 表示二进制， 0 、 0o 或 0O 表示八进制， 0x 或 0X 表示十六进制。单个 0 被视为十进制零。在十六进制字面量中，字母 a-f 和 A-F 表示值 10-15。</p>
<blockquote>
<p>For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal’s value.</p>
</blockquote>
<p>为方便阅读，下划线字符 _ 可能出现在基础前缀之后或连续的数字之间；这些下划线并不会改变字面量值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .</span></span>
<span class="line"><span style="color:#babed8">decimal_lit    = &quot;0&quot; | ( &quot;1&quot; … &quot;9&quot; ) [ [ &quot;_&quot; ] decimal_digits ] .</span></span>
<span class="line"><span style="color:#babed8">binary_lit     = &quot;0&quot; ( &quot;b&quot; | &quot;B&quot; ) [ &quot;_&quot; ] binary_digits .</span></span>
<span class="line"><span style="color:#babed8">octal_lit      = &quot;0&quot; [ &quot;o&quot; | &quot;O&quot; ] [ &quot;_&quot; ] octal_digits .</span></span>
<span class="line"><span style="color:#babed8">hex_lit        = &quot;0&quot; ( &quot;x&quot; | &quot;X&quot; ) [ &quot;_&quot; ] hex_digits .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">decimal_digits = decimal_digit { [ &quot;_&quot; ] decimal_digit } .</span></span>
<span class="line"><span style="color:#babed8">binary_digits  = binary_digit { [ &quot;_&quot; ] binary_digit } .</span></span>
<span class="line"><span style="color:#babed8">octal_digits   = octal_digit { [ &quot;_&quot; ] octal_digit } .</span></span>
<span class="line"><span style="color:#babed8">hex_digits     = hex_digit { [ &quot;_&quot; ] hex_digit } .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">42</span></span>
<span class="line"><span style="color:#babed8">4_2</span></span>
<span class="line"><span style="color:#babed8">0600</span></span>
<span class="line"><span style="color:#babed8">0_600</span></span>
<span class="line"><span style="color:#babed8">0o600</span></span>
<span class="line"><span style="color:#babed8">0O600       // second character is capital letter &#39;O&#39;</span></span>
<span class="line"><span style="color:#babed8">0xBadFace</span></span>
<span class="line"><span style="color:#babed8">0xBad_Face</span></span>
<span class="line"><span style="color:#babed8">0x_67_7a_2f_cc_40_c6</span></span>
<span class="line"><span style="color:#babed8">170141183460469231731687303715884105727</span></span>
<span class="line"><span style="color:#babed8">170_141183_460469_231731_687303_715884_105727</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">_42         // an identifier, not an integer literal</span></span>
<span class="line"><span style="color:#babed8">42_         // invalid: _ must separate successive digits</span></span>
<span class="line"><span style="color:#babed8">4__2        // invalid: only one _ at a time</span></span>
<span class="line"><span style="color:#babed8">0_xBadFace  // invalid: _ must separate successive digits</span></span></code></pre>
<h3 id="floating-point-literals-浮点字面量">Floating-point literals 浮点字面量</h3>
<blockquote>
<p>A floating-point literal is a decimal or hexadecimal representation of a floating-point constant.</p>
</blockquote>
<p>浮点字面量是浮点常量的十进制或十六进制表示形式。</p>
<blockquote>
<p>A decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10^exp.</p>
</blockquote>
<p>十进制浮点字面量由整数部分（十进制数字）、小数点、小数部分（十进制数字）和指数部分（ e 或 E 后面跟可选的符号和小数位）。<br/>
整数部分或小数部分之一可以省略；<br/>
小数点或指数部分之一可以被省略。<br/>
指数值 exp 将尾数（整数和小数部分）缩放 10^exp 倍。</p>
<blockquote>
<p>A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2^exp.</p>
</blockquote>
<p>十六进制浮点字面量由 0x 或 0X 前缀、整数部分（十六进制数字）、基数点、小数部分（十六进制数字）和指数部分组成（ p 或 P 后跟可选的符号和小数位）。<br/>
整数部分或小数部分之一可以省略；<br/>
小数点也可以省略，但指数部分是必需的。（此语法与 IEEE 754-2008 §5.12.3 中给定的语法一致。）<br/>
指数值 exp 将尾数（整数和小数部分）缩放 2^exp 倍。</p>
<p><em>基数点也是小数点的意思，但基数点这个词语用于任意基数的数字系统。</em></p>
<blockquote>
<p>For readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value.</p>
</blockquote>
<p>为方便阅读，下划线字符 _ 可能出现在基础前缀之后或连续的数字之间；这些下划线并不会改变字面量值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">float_lit         = decimal_float_lit | hex_float_lit .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">decimal_float_lit = decimal_digits &quot;.&quot; [ decimal_digits ] [ decimal_exponent ] |</span></span>
<span class="line"><span style="color:#babed8">                    decimal_digits decimal_exponent |</span></span>
<span class="line"><span style="color:#babed8">                    &quot;.&quot; decimal_digits [ decimal_exponent ] .</span></span>
<span class="line"><span style="color:#babed8">decimal_exponent  = ( &quot;e&quot; | &quot;E&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimal_digits .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">hex_float_lit     = &quot;0&quot; ( &quot;x&quot; | &quot;X&quot; ) hex_mantissa hex_exponent .</span></span>
<span class="line"><span style="color:#babed8">hex_mantissa      = [ &quot;_&quot; ] hex_digits &quot;.&quot; [ hex_digits ] |</span></span>
<span class="line"><span style="color:#babed8">                    [ &quot;_&quot; ] hex_digits |</span></span>
<span class="line"><span style="color:#babed8">                    &quot;.&quot; hex_digits .</span></span>
<span class="line"><span style="color:#babed8">hex_exponent      = ( &quot;p&quot; | &quot;P&quot; ) [ &quot;+&quot; | &quot;-&quot; ] decimal_digits .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">0.</span></span>
<span class="line"><span style="color:#babed8">72.40</span></span>
<span class="line"><span style="color:#babed8">072.40       // == 72.40</span></span>
<span class="line"><span style="color:#babed8">2.71828</span></span>
<span class="line"><span style="color:#babed8">1.e+0</span></span>
<span class="line"><span style="color:#babed8">6.67428e-11</span></span>
<span class="line"><span style="color:#babed8">1E6</span></span>
<span class="line"><span style="color:#babed8">.25</span></span>
<span class="line"><span style="color:#babed8">.12345E+5</span></span>
<span class="line"><span style="color:#babed8">1_5.         // == 15.0</span></span>
<span class="line"><span style="color:#babed8">0.15e+0_2    // == 15.0</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">0x1p-2       // == 0.25</span></span>
<span class="line"><span style="color:#babed8">0x2.p10      // == 2048.0</span></span>
<span class="line"><span style="color:#babed8">0x1.Fp+0     // == 1.9375</span></span>
<span class="line"><span style="color:#babed8">0X.8p-0      // == 0.5</span></span>
<span class="line"><span style="color:#babed8">0X_1FFFP-16  // == 0.1249847412109375</span></span>
<span class="line"><span style="color:#babed8">0x15e-2      // == 0x15e - 2 (integer subtraction)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">0x.p1        // invalid: mantissa has no digits</span></span>
<span class="line"><span style="color:#babed8">1p-2         // invalid: p exponent requires hexadecimal mantissa</span></span>
<span class="line"><span style="color:#babed8">0x1.5e-2     // invalid: hexadecimal mantissa requires p exponent</span></span>
<span class="line"><span style="color:#babed8">1_.5         // invalid: _ must separate successive digits</span></span>
<span class="line"><span style="color:#babed8">1._5         // invalid: _ must separate successive digits</span></span>
<span class="line"><span style="color:#babed8">1.5_e1       // invalid: _ must separate successive digits</span></span>
<span class="line"><span style="color:#babed8">1.5e_1       // invalid: _ must separate successive digits</span></span>
<span class="line"><span style="color:#babed8">1.5e1_       // invalid: _ must separate successive digits</span></span></code></pre>
<h3 id="imaginary-literals-虚数字面量">Imaginary literals 虚数字面量</h3>
<blockquote>
<p>An imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lowercase letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i.</p>
</blockquote>
<p>虚数字面量表示复数常量的虚部。<br/>
虚数字面量由一个整数或浮点字面量后跟小写字母 i 组成。<br/>
虚数字面量的值是相应整数或浮点字面量的值乘以虚数单位 i 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">imaginary_lit = (decimal_digits | int_lit | float_lit) &quot;i&quot; .</span></span></code></pre>
<blockquote>
<p>For backward compatibility, an imaginary literal’s integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0.</p>
</blockquote>
<p>为了向后兼容，完全由十进制数字（可能带下划线）组成的虚数字面量的整数部分被视为十进制整数，即使它以前导 0 开头。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">0i</span></span>
<span class="line"><span style="color:#babed8">0123i         // == 123i for backward-compatibility</span></span>
<span class="line"><span style="color:#babed8">0o123i        // == 0o123 * 1i == 83i</span></span>
<span class="line"><span style="color:#babed8">0xabci        // == 0xabc * 1i == 2748i</span></span>
<span class="line"><span style="color:#babed8">0.i</span></span>
<span class="line"><span style="color:#babed8">2.71828i</span></span>
<span class="line"><span style="color:#babed8">1.e+0i</span></span>
<span class="line"><span style="color:#babed8">6.67428e-11i</span></span>
<span class="line"><span style="color:#babed8">1E6i</span></span>
<span class="line"><span style="color:#babed8">.25i</span></span>
<span class="line"><span style="color:#babed8">.12345E+5i</span></span>
<span class="line"><span style="color:#babed8">0x1p-2i       // == 0x1p-2 * 1i == 0.25i</span></span></code></pre>
<h3 id="rune-literals-unicode-字符字面量">Rune literals <code>Unicode 字符字面量</code></h3>
<blockquote>
<p>A rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in ‘x’ or ‘\n’. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.</p>
</blockquote>
<p>rune 字面量表示 rune 常量，也就是标识 Unicode 码点的整数值。<br/>
一个 rune 字面量表示为用单引号括起来的一个或多个字符，如 ‘x’ 或 ‘\n’ 。<br/>
引号内可以出现除了换行符和未转义的单引号之外的任何字符。<br/>
单引号括起来的字符表示字符本身的 Unicode 值，而以反斜杠开头的多个字符的序列则以各种格式对值进行编码。</p>
<blockquote>
<p>The simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal ‘a’ holds a single byte representing a literal a, Unicode U+0061, value 0x61, while ‘ä’ holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4.</p>
</blockquote>
<p>表示引号内的单个字符的最简单的形式；由于 Go 源代码文本是以 UTF-8 编码的 Unicode 字符，因此多个 UTF-8 编码的字节可以表示单个整数值。<br/>
例如，字面量 ‘a’ 存储了表示文字 a 即 Unicode U+0061 的单个字节，值为 0x61 ，而 ‘ä’ 存储了两个字节 ( 0xc3 0xa4 ) 来表示文字 分音a 即 U+00E4 , 值为 0xe4 。</p>
<blockquote>
<p>Several backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \x followed by exactly two hexadecimal digits; \u followed by exactly four hexadecimal digits; \U followed by exactly eight hexadecimal digits, and a plain backslash \ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.</p>
</blockquote>
<p>多个反斜杠转义允许将任意值编码为 ASCII 文本。<br/>
有四种方法可以将整数值表示为数字常量：<br/>
\x 后跟两个十六进制数字；<br/>
\u 后跟四个十六进制数字；<br/>
\U 后跟八个十六进制数字；<br/>
一个直接的反斜杠 \ 后跟三个八进制数字。<br/>
在每种情况下，字面量的值都是由相应基数中的数字表示的值。</p>
<blockquote>
<p>Although these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \u and \U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves.</p>
</blockquote>
<p>尽管这些表示法都会产生一个整数，但它们有效范围不同。<br/>
八进制转义符必须表示 0 到 255 之间的值（包括 0 和 255）。<br/>
十六进制转义符通过构造来满足这个条件。<br/>
转义符 \u 和 \U 表示 Unicode 码点，因此其中的某些值是非法的，特别是 0x10FFFF 和代理对之上的值。</p>
<p><em>代理对，有的资料中也叫做代理项。代理对是Unicode编码中的概念。简言之，Unicode对于常用字符只用两个字节就表示了；可对于一些不常用的、后来补充进来的字符，就需要用到四个字节，前两个字节和后两个字节都是专用在这里的场景不会用来单独映射一个字符，所以不会有歧义，同时也意味着它们要成对使用，所以叫做代理对。</em></p>
<blockquote>
<p>After a backslash, certain single-character escapes represent special values:</p>
</blockquote>
<p>在反斜杠之后，某些单字符转义符代表特殊值：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">\a   U+0007 alert or bell</span></span>
<span class="line"><span style="color:#babed8">\b   U+0008 backspace</span></span>
<span class="line"><span style="color:#babed8">\f   U+000C form feed</span></span>
<span class="line"><span style="color:#babed8">\n   U+000A line feed or newline</span></span>
<span class="line"><span style="color:#babed8">\r   U+000D carriage return</span></span>
<span class="line"><span style="color:#babed8">\t   U+0009 horizontal tab</span></span>
<span class="line"><span style="color:#babed8">\v   U+000B vertical tab</span></span>
<span class="line"><span style="color:#babed8">\\   U+005C backslash</span></span>
<span class="line"><span style="color:#babed8">\&#39;   U+0027 single quote  (valid escape only within rune literals)</span></span>
<span class="line"><span style="color:#babed8">\&quot;   U+0022 double quote  (valid escape only within string literals)</span></span></code></pre>
<blockquote>
<p>An unrecognized character following a backslash in a rune literal is illegal.</p>
</blockquote>
<p>Unicode 字符字面量中反斜杠后面的无法识别的字符是非法的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">rune_lit         = &quot;&#39;&quot; ( unicode_value | byte_value ) &quot;&#39;&quot; .</span></span>
<span class="line"><span style="color:#babed8">unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .</span></span>
<span class="line"><span style="color:#babed8">byte_value       = octal_byte_value | hex_byte_value .</span></span>
<span class="line"><span style="color:#babed8">octal_byte_value = `\` octal_digit octal_digit octal_digit .</span></span>
<span class="line"><span style="color:#babed8">hex_byte_value   = `\` &quot;x&quot; hex_digit hex_digit .</span></span>
<span class="line"><span style="color:#babed8">little_u_value   = `\` &quot;u&quot; hex_digit hex_digit hex_digit hex_digit .</span></span>
<span class="line"><span style="color:#babed8">big_u_value      = `\` &quot;U&quot; hex_digit hex_digit hex_digit hex_digit</span></span>
<span class="line"><span style="color:#babed8">                           hex_digit hex_digit hex_digit hex_digit .</span></span>
<span class="line"><span style="color:#babed8">escaped_char     = `\` ( &quot;a&quot; | &quot;b&quot; | &quot;f&quot; | &quot;n&quot; | &quot;r&quot; | &quot;t&quot; | &quot;v&quot; | `\` | &quot;&#39;&quot; | `&quot;` ) .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">&#39;a&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;ä&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;本&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\t&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\000&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\007&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\377&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\x07&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\xff&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\u12e4&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\U00101234&#39;</span></span>
<span class="line"><span style="color:#babed8">&#39;\&#39;&#39;         // rune literal containing single quote character</span></span>
<span class="line"><span style="color:#babed8">&#39;aa&#39;         // illegal: too many characters</span></span>
<span class="line"><span style="color:#babed8">&#39;\k&#39;         // illegal: k is not recognized after a backslash</span></span>
<span class="line"><span style="color:#babed8">&#39;\xa&#39;        // illegal: too few hexadecimal digits</span></span>
<span class="line"><span style="color:#babed8">&#39;\0&#39;         // illegal: too few octal digits</span></span>
<span class="line"><span style="color:#babed8">&#39;\400&#39;       // illegal: octal value over 255</span></span>
<span class="line"><span style="color:#babed8">&#39;\uDFFF&#39;     // illegal: surrogate half</span></span>
<span class="line"><span style="color:#babed8">&#39;\U00110000&#39; // illegal: invalid Unicode code point</span></span></code></pre>
<h3 id="string-literals-字符串字面量">String literals 字符串字面量</h3>
<blockquote>
<p>A string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.</p>
</blockquote>
<p>字符串字面量表示通过字符序列的连接产生的一个字符串常量。<br/>
有两种形式：原始字符串字面量和解释型字符串字面量。</p>
<blockquote>
<p>Raw string literals are character sequences between back quotes, as in <code>foo</code>. Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters (‘\r’) inside raw string literals are discarded from the raw string value.</p>
</blockquote>
<p>原始字符串字面量是反引号之间的字符序列，如 `foo` 中的字符序列。<br/>
引号内可以出现除了反引号之外的任何字符。<br/>
原始字符串字面量的值是由引号之间的未解释的（隐式 UTF-8 编码）字符组成的字符串；<br/>
特别地，反斜杠没有特殊的含义，并且字符串可能会包含换行符。<br/>
原始字符串字面量中的回车符 (‘\r’) 会从原始字符串值中丢弃掉。</p>
<blockquote>
<p>Interpreted string literals are character sequences between double quotes, as in “bar”. Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that ’ is illegal and ” is legal), with the same restrictions. The three-digit octal (\nnn) and two-digit hexadecimal (\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \377 and \xFF represent a single byte of value 0xFF=255, while ÿ, \u00FF, \U000000FF and \xc3\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.</p>
</blockquote>
<p>解释型字符串字面量是双引号之间的字符序列，如 “bar” 中的字符序列。<br/>
引号内可以出现除了换行符和未转义的双引号之外的任何字符。<br/>
引号之间的文本形成了字面量的值，反斜杠转义被解释为 Unicode 字符字面量中的内容（除了 \’ 是非法的，而 \” 是合法的），具有相同的限制。<br/>
三位八进制 ( \nnn ) 和两位十六进制 ( \xnn ) 转义符表示结果字符串的各个独立的字节；<br/>
所有其他转义符表示单个字符的（可能是多字节的）UTF-8 编码。<br/>
因此，在字符串字面量中 \377 和 \xFF 表示值 0xFF=255 的单个字节，而 ÿ, \u00FF, \U000000FF 和 \xc3\xbf 表示字符 U+00FF 中的 UTF-8 编码的两个字节 0xc3 0xbf 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">string_lit             = raw_string_lit | interpreted_string_lit .</span></span>
<span class="line"><span style="color:#babed8">raw_string_lit         = &quot;`&quot; { unicode_char | newline } &quot;`&quot; .</span></span>
<span class="line"><span style="color:#babed8">interpreted_string_lit = `&quot;` { unicode_value | byte_value } `&quot;` .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">`abc`                // same as &quot;abc&quot;</span></span>
<span class="line"><span style="color:#babed8">`\n</span></span>
<span class="line"><span style="color:#babed8">\n`                  // same as &quot;\\n\n\\n&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;\n&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;\&quot;&quot;                 // same as `&quot;`</span></span>
<span class="line"><span style="color:#babed8">&quot;Hello, world!\n&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;日本語&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;\u65e5本\U00008a9e&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;\xff\u00FF&quot;</span></span>
<span class="line"><span style="color:#babed8">&quot;\uD800&quot;             // illegal: surrogate half</span></span>
<span class="line"><span style="color:#babed8">&quot;\U00110000&quot;         // illegal: invalid Unicode code point</span></span></code></pre>
<blockquote>
<p>These examples all represent the same string:</p>
</blockquote>
<p>这些例子都表示同一个字符串：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">&quot;日本語&quot;                                 // UTF-8 input text</span></span>
<span class="line"><span style="color:#babed8">`日本語`                                 // UTF-8 input text as a raw literal</span></span>
<span class="line"><span style="color:#babed8">&quot;\u65e5\u672c\u8a9e&quot;                    // the explicit Unicode code points</span></span>
<span class="line"><span style="color:#babed8">&quot;\U000065e5\U0000672c\U00008a9e&quot;        // the explicit Unicode code points</span></span>
<span class="line"><span style="color:#babed8">&quot;\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e&quot;  // the explicit UTF-8 bytes</span></span></code></pre>
<blockquote>
<p>If the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.</p>
</blockquote>
<p>如果源代码将一个字符表示为两个码点，例如包含重音符号和字母的组合形式，那么如果将其放在一个 rune 字面量（它不是单个的码点）中，结果将产生错误；<br/>
如果放置在字符串字面量中，那么会显示为两个码点。</p>
<p><em>rune可以理解为“Unicode字符”，此处为更加贴近编写英文代码时的场景，不译。</em></p>
<h2 id="constants-常量">Constants 常量</h2>
<blockquote>
<p>There are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.</p>
</blockquote>
<p>有布尔常量、 Unicode 字符常量、整型常量、浮点常量、复数常量和字符串常量。<br/>
Unicode 字符常量、整数常量、浮点常量和复数常量统称为数字常量。</p>
<blockquote>
<p>A constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as unsafe.Sizeof applied to certain values, cap or len applied to some expressions, real and imag applied to a complex constant and complex applied to numeric constants. The boolean truth values are represented by the predeclared constants true and false. The predeclared identifier iota denotes an integer constant.</p>
</blockquote>
<p>常量的值由 Unicode 字符、整数、浮点、虚数或字符串字面量、表示常量的标识符、常量表达式、结果为常量的转换或某些内置函数如 <code>unsafe.Sizeof</code> 作用于特定的值、 <code>cap</code> 和 <code>len</code> 作用于某些表达式、 <code>real</code> 和 <code>imag</code> 作用于复数常量和 <code>complex</code> 作用于数字常量的返回值来表示。<br/>
布尔真值由预声明的常量 <code>true</code> 和 <code>false</code> 来表示。<br/>
预声明的标识符 <code>iota</code> 表示整型常量。</p>
<blockquote>
<p>In general, complex constants are a form of constant expression and are discussed in that section.</p>
</blockquote>
<p>通常，复数常量是常量表达式的一种形式，将在常量表达式章节中讨论。</p>
<blockquote>
<p>Numeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE-754 negative zero, infinity, and not-a-number values.</p>
</blockquote>
<p>数字常量表示任意精度的精确值且不会溢出。<br/>
因此，没有常量来表示 IEEE-754标准中的 负零、无穷大和非数字值。</p>
<blockquote>
<p>Constants may be typed or untyped. Literal constants, true, false, iota, and certain constant expressions containing only untyped constant operands are untyped.</p>
</blockquote>
<p>常量可以是有类型的，也可以是无类型的。<br/>
字面量常量， true, false, iota 以及只包含无类型常量操作数的特定的常量表达式是无类型的。</p>
<blockquote>
<p>A constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment statement or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type. If the type is a type parameter, the constant is converted into a non-constant value of the type parameter.</p>
</blockquote>
<p>常量可以通过常量声明或转换来显式地给定类型，或者在变量声明或赋值语句中使用，或者作为表达式中的操作数时隐式地指定类型。<br/>
如果常量值不能表示为相应类型的值，那么就会产生一个错误。<br/>
如果类型是一个类型参数，那么常量就会转换为类型参数的非常量值。</p>
<blockquote>
<p>An untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as i := 0 where there is no explicit type. The default type of an untyped constant is bool, rune, int, float64, complex128 or string respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.</p>
</blockquote>
<p>无类型常量具有默认类型，该类型是常量在需要有类型值的上下文中隐式转换的目标类型，比如，在没有显式类型的短变量声明如 <code>i := 0</code> 中。<br/>
无类型常量的默认类型为 bool, rune, int, float64, complex128 或 string ，这分别取决于它是布尔、 Unicode 字符、整数、浮点、复数还是字符串常量。</p>
<blockquote>
<p>Implementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:</p>
</blockquote>
<p>实现限制：尽管数字常量在语言中具有任意精度，但编译器可以使用有限精度的内部表示来实现它们。<br/>
也就是说，每个实现都必须（满足）：</p>
<blockquote>
<ul>
<li>Represent integer constants with at least 256 bits.</li>
</ul>
</blockquote>
<p>整数常量，用至少 256 位来表示。</p>
<blockquote>
<ul>
<li>Represent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits.</li>
</ul>
</blockquote>
<p>浮点常量（包括复数常量的部分），用至少 256 位的尾数和至少 16 位的有符号二进制指数来表示。</p>
<blockquote>
<ul>
<li>Give an error if unable to represent an integer constant precisely.</li>
</ul>
</blockquote>
<p>无法精确表示整数常量时，会报错。</p>
<blockquote>
<ul>
<li>Give an error if unable to represent a floating-point or complex constant due to overflow.</li>
</ul>
</blockquote>
<p>由于溢出而无法表示浮点或复数常量时，会报错。</p>
<blockquote>
<ul>
<li>Round to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.</li>
</ul>
</blockquote>
<p>由于精度限制而无法表示浮点或复数常量时，就舍入到最接近的可表示的常量。</p>
<blockquote>
<p>These requirements apply both to literal constants and to the result of evaluating constant expressions.</p>
</blockquote>
<p>这些要求既对字面量常量适用，对常量表达式的计算结果也适用。</p>
<h2 id="variables-变量">Variables 变量</h2>
<blockquote>
<p>A variable is a storage location for holding a value. The set of permissible values is determined by the variable’s type.</p>
</blockquote>
<p>变量是保存值的存储位置。允许使用的值的集合，由变量的类型决定。</p>
<blockquote>
<p>A variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function new or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.</p>
</blockquote>
<p>变量声明，或者对于函数参数和返回值，函数声明或函数字面量的签名会将具名变量保存下来。调用内置函数 new 或获取组合字面量的地址会在运行时为变量分配存储空间。这样的匿名变量是通过（可能是隐式的）指针来间接引用的。</p>
<blockquote>
<p>Structured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.</p>
</blockquote>
<p>数组、切片和结构体类型的结构化变量有可以单独寻址的元素和字段。<br/>
每个这样的元素的表现就像一个变量。</p>
<blockquote>
<p>The static type (or just type) of a variable is the type given in its declaration, the type provided in the new call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the (non-interface) type of the value assigned to the variable at run time (unless the value is the predeclared identifier nil, which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.</p>
</blockquote>
<p>变量的静态类型（或仅有类型）是其声明，或者 new 调用或组合字面量中提供的类型，或者结构化变量中的元素的类型。<br/>
接口类型的变量也有一个独立的动态类型，它是运行时分配给变量的值的（非接口）类型（除非这个值是预先声明的标识符 nil ，没有类型）。动态类型在运行期间可能会发生变化，但储存在接口变量中的值始终可赋值给变量的静态类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x interface{}  // x is nil and has static type interface{}</span></span>
<span class="line"><span style="color:#babed8">var v *T           // v has value nil, static type *T</span></span>
<span class="line"><span style="color:#babed8">x = 42             // x has value 42 and dynamic type int</span></span>
<span class="line"><span style="color:#babed8">x = v              // x has value (*T)(nil) and dynamic type *T</span></span></code></pre>
<blockquote>
<p>A variable’s value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.</p>
</blockquote>
<p>通过引用表达式中的变量来检索变量的值；它是分配给变量的最新的值。如果变量还没有被赋值，那么变量的值就是其类型的零值。</p>
<h2 id="types-类型">Types 类型</h2>
<blockquote>
<p>A type determines a set of values together with operations and methods specific to those values.<br/>
A type may be denoted by a type name, if it has one, which must be followed by type arguments if the type is generic.<br/>
A type may also be specified using a type literal, which composes a type from existing types.</p>
</blockquote>
<p>类型确定了一组值及其特定的操作和方法。<br/>
一种类型可以由一种类型的名字表示，如果它有一个类型是泛型，就必须带上类型参数。<br/>
一种类型也可以用由已有的类型组成的类型字面值指定。</p>
<p><em>denote, 表示。</em><br/>
<em>specify, 指定。</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">Type      </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> TypeName </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> TypeArgs </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> TypeLit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> Type </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">)</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">TypeName  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> identifier </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> QualifiedIdent </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">TypeArgs  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">[</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> TypeList </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">,</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">]</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">TypeList  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> Type </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">,</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> Type </span><span style="color:#89DDFF">}</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">TypeLit   </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> ArrayType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> StructType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> PointerType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> FunctionType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> InterfaceType </span><span style="color:#89DDFF">|</span></span>
<span class="line"><span style="color:#BABED8">            SliceType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> MapType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> ChannelType </span><span style="color:#89DDFF">.</span></span></code></pre>
<blockquote>
<p>The language predeclares certain type names. Others are introduced with type declarations or type parameter lists. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.</p>
</blockquote>
<p>Go语言预先声明了一些特定的类型。其他的则是由类型声明或者类型参数列表引入。复合类型——数组（array）、结构体（struct）、指针（pointer）、函数（function）、接口（interface）、切片（slice）、映射（Map）以及通道（channel）类型，可以通过类型字面量构造出来。</p>
<blockquote>
<p>Predeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.</p>
</blockquote>
<p>预声明类型， 已定义类型和类型参数被称为具名类型。如果别名声明中给定的类型是具名的，那么这个别名也表示一种具名类型。</p>
<h3 id="boolean-types-布尔类型">Boolean types 布尔类型</h3>
<blockquote>
<p>A boolean type represents the set of Boolean truth values denoted by the predeclared constants true and false. The predeclared boolean type is bool; it is a defined type.</p>
</blockquote>
<p>布尔类型代表了一组用预声明常量 <code>true</code> 和 <code>false</code> 表示的布尔真假值。这种预声明的布尔类型就是 <code>bool</code> 。它是已定义的类型。</p>
<h3 id="numeric-types-数字类型">Numeric types 数字类型</h3>
<blockquote>
<p>An integer, floating-point, or complex type represents the set of integer, floating-point, or complex values, respectively. They are collectively called numeric types. The predeclared architecture-independent numeric types are:</p>
</blockquote>
<p>整数、浮点或复数类型分别表示整数、浮点或复数值的集合。<br/>
它们统称为数字类型。<br/>
预声明的独立于体系结构的数字类型是（以下这些）：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uint8       the set of all unsigned  8-bit integers (0 to 255)</span></span>
<span class="line"><span style="color:#babed8">uint16      the set of all unsigned 16-bit integers (0 to 65535)</span></span>
<span class="line"><span style="color:#babed8">uint32      the set of all unsigned 32-bit integers (0 to 4294967295)</span></span>
<span class="line"><span style="color:#babed8">uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">int8        the set of all signed  8-bit integers (-128 to 127)</span></span>
<span class="line"><span style="color:#babed8">int16       the set of all signed 16-bit integers (-32768 to 32767)</span></span>
<span class="line"><span style="color:#babed8">int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)</span></span>
<span class="line"><span style="color:#babed8">int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">float32     the set of all IEEE-754 32-bit floating-point numbers</span></span>
<span class="line"><span style="color:#babed8">float64     the set of all IEEE-754 64-bit floating-point numbers</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">complex64   the set of all complex numbers with float32 real and imaginary parts</span></span>
<span class="line"><span style="color:#babed8">complex128  the set of all complex numbers with float64 real and imaginary parts</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">byte        alias for uint8</span></span>
<span class="line"><span style="color:#babed8">rune        alias for int32</span></span></code></pre>
<blockquote>
<p>The value of an n-bit integer is n bits wide and represented using two’s complement arithmetic.</p>
</blockquote>
<p>n 位整数的值是 n 位宽的，并使用二进制补码算术来表示。</p>
<blockquote>
<p>There is also a set of predeclared integer types with implementation-specific sizes:</p>
</blockquote>
<p>还有一组具有基于特定实现的大小的预声明的整数类型：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uint     either 32 or 64 bits</span></span>
<span class="line"><span style="color:#babed8">int      same size as uint</span></span>
<span class="line"><span style="color:#babed8">uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value</span></span></code></pre>
<blockquote>
<p>To avoid portability issues all numeric types are defined types and thus distinct except byte, which is an alias for uint8, and rune, which is an alias for int32. Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, int32 and int are not the same type even though they may have the same size on a particular architecture.</p>
</blockquote>
<p>为了避免可移植性问题，所有数字类型都是已定义的类型，因此除了 byte （ uint8 的别名）和 rune （ int32 的别名）之外都是不同的。<br/>
当不同的数值类型混合在表达式或赋值中时，需要进行显式转换。<br/>
例如， int32 和 int 不是同一类型，尽管它们在特定架构上可能大小是相同的。</p>
<h3 id="string-types-字符串类型">String types 字符串类型</h3>
<blockquote>
<p>A string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string; it is a defined type.</p>
</blockquote>
<p>字符串类型表示字符串值的集合。字符串值是一个（可能为空的）字节序列。字节数称为字符串的长度，并且永远不为负。字符串是不可变的：一旦创建，就不可能更改字符串的内容。预声明的字符串类型是 string ；它是一个已定义的类型。</p>
<blockquote>
<p>The length of a string s can be discovered using the built-in function len. The length is a compile-time constant if the string is a constant. A string’s bytes can be accessed by integer indices 0 through len(s)-1. It is illegal to take the address of such an element; if s[i] is the i’th byte of a string, &amp;s[i] is invalid.</p>
</blockquote>
<p>字符串 s 的长度可以通过内置函数 len 来查看。如果字符串是常量，则长度是编译时常量。字符串的字节可以通过 0 到 len(s)-1 的整数索引来访问。获取像这样的元素的地址是非法的；如果 s[i] 是字符串的第 i 个字节，则 <code>&amp;s[i]</code> 是无效的。</p>
<h3 id="array-types-数组类型">Array types 数组类型</h3>
<blockquote>
<p>An array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.</p>
</blockquote>
<p>数组是单一类型元素的编号序列，这种类型称为元素类型。元素的数量称为数组的长度，并且永远不为负数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ArrayType   = &quot;[&quot; ArrayLength &quot;]&quot; ElementType .</span></span>
<span class="line"><span style="color:#babed8">ArrayLength = Expression .</span></span>
<span class="line"><span style="color:#babed8">ElementType = Type .</span></span></code></pre>
<blockquote>
<p>The length is part of the array’s type; it must evaluate to a non-negative constant representable by a value of type int. The length of array a can be discovered using the built-in function len. The elements can be addressed by integer indices 0 through len(a)-1. Array types are always one-dimensional but may be composed to form multi-dimensional types.</p>
</blockquote>
<p>长度是数组类型的一部分；它必须计算为由 int 类型的值表示的非负常量。数组 a 的长度可以通过内置函数 len 来查看。这些元素可以通过 0 到 len(a)-1 的整数索引来寻址。数组类型始终是一维的，但也可以组合成多维类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">[32]byte</span></span>
<span class="line"><span style="color:#babed8">[2*N] struct { x, y int32 }</span></span>
<span class="line"><span style="color:#babed8">[1000]*float64</span></span>
<span class="line"><span style="color:#babed8">[3][5]int</span></span>
<span class="line"><span style="color:#babed8">[2][2][2]float64  // same as [2]([2]([2]float64))</span></span></code></pre>
<blockquote>
<p>An array type T may not have an element of type T, or of a type containing T as a component, directly or indirectly, if those containing types are only array or struct types.</p>
</blockquote>
<p>数组类型 T 可能没有 T 类型的元素，或者如果那些包含类型的元素只是数组或结构体类型，也可以直接或间接地包含 T 作为其一部分的类型的元素。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// invalid array types</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	T1 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">T1                 </span><span style="color:#676E95;font-style:italic">// element type of T1 is T1</span></span>
<span class="line"><span style="color:#BABED8">	T2 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]struct{</span><span style="color:#BABED8"> f T2 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">     </span><span style="color:#676E95;font-style:italic">// T2 contains T2 as component of a struct</span></span>
<span class="line"><span style="color:#BABED8">	T3 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">T4                 </span><span style="color:#676E95;font-style:italic">// T3 contains T3 as component of a struct in T4</span></span>
<span class="line"><span style="color:#BABED8">	T4 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f T3 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">         </span><span style="color:#676E95;font-style:italic">// T4 contains T4 as component of array T3 in a struct</span></span>
<span class="line"><span style="color:#BABED8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// valid array types</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	T5 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]*</span><span style="color:#BABED8">T5                </span><span style="color:#676E95;font-style:italic">// T5 contains T5 as component of a pointer</span></span>
<span class="line"><span style="color:#BABED8">	T6 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]func()</span><span style="color:#BABED8"> T6          </span><span style="color:#676E95;font-style:italic">// T6 contains T6 as component of a function type</span></span>
<span class="line"><span style="color:#BABED8">	T7 </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">[]</span><span style="color:#BABED8">T7 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">   </span><span style="color:#676E95;font-style:italic">// T7 contains T7 as component of a slice in a struct</span></span>
<span class="line"><span style="color:#BABED8">)</span></span></code></pre>
<h3 id="slice-types-切片类型">Slice types 切片类型</h3>
<blockquote>
<p>A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is nil.</p>
</blockquote>
<p>切片是底层数组的一个连续段的描述符，并提供了对该数组中元素的编号序列方式的访问。切片类型标识了其元素类型的所有数组的切片集合。元素的数量称为切片的长度，并且永远不为负数。未初始化的切片的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">SliceType = &quot;[&quot; &quot;]&quot; ElementType .</span></span></code></pre>
<blockquote>
<p>The length of a slice s can be discovered by the built-in function len; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through len(s)-1. The slice index of a given element may be less than the index of the same element in the underlying array.</p>
</blockquote>
<p>切片 s 的长度可以通过内置函数 len 来查看；与数组不同的是，它在执行过程中可能会发生变化。这些元素可以通过 0 到 len(s)-1 的整数索引来寻址。给定元素的切片索引可能小于底层数组中相同元素的索引。</p>
<blockquote>
<p>A slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.</p>
</blockquote>
<p>切片一旦初始化，就始终与存储其元素的底层数组相关联。因此，切片与其数组以及同一数组的其他切片共享（同一份）存储；相比较而言，不同的数组一定是代表了不同的存储。</p>
<blockquote>
<p>The array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice a can be discovered using the built-in function cap(a).</p>
</blockquote>
<p>切片底层的数组可以延伸到超出切片的末尾。容量是这个范围的度量：它是切片长度与超出切片之外的数组部分的长度之和；可以通过从原始切片中切出新切片来创建一个长度达到该容量的切片。切片 a 的容量可以使用内置函数 cap(a) 来查看。</p>
<blockquote>
<p>A new, initialized slice value for a given element type T may be made using the built-in function make, which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with make always allocates a new, hidden array to which the returned slice value refers. That is, executing</p>
</blockquote>
<p>可以使用内置函数 make 为给定元素类型 T 生成新的初始化切片值， make 函数接收一个切片类型和指定了长度、（可选）容量的参数。使用 make 创建的切片总是分配一个新的隐藏数组，返回的切片值会引用该数组。也就是说，执行（下面的）</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#82AAFF">make</span><span style="color:#89DDFF">([]</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> length</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> capacity</span><span style="color:#89DDFF">)</span></span></code></pre>
<blockquote>
<p>produces the same slice as allocating an array and slicing it, so these two expressions are equivalent:</p>
</blockquote>
<p>生成的切片与分配数组再对其进行切片产生的切片相同，因此（以下）这两个表达式是等价的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#82AAFF">make</span><span style="color:#89DDFF">([]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">50</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">100</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#82AAFF">new</span><span style="color:#89DDFF">([</span><span style="color:#F78C6C">100</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)[</span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">:</span><span style="color:#F78C6C">50</span><span style="color:#89DDFF">]</span></span></code></pre>
<blockquote>
<p>Like arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.</p>
</blockquote>
<p>与数组一样，切片始终是一维的，但可以组合起来构造更高维的对象。对于数组的数组，内部数组在结构上总是相同的长度；但是，对于切片的切片（或切片的数组），内部长度可能会动态地变化。另外，内部切片必须单独初始化。</p>
<h3 id="struct-types-结构体类型">Struct types 结构体类型</h3>
<blockquote>
<p>A struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.</p>
</blockquote>
<p>结构体是具名元素（称作字段）的一个序列，每个元素都有名字和类型。字段名称可以显式地指定（标识符列表）或隐式地指定（嵌入字段）。在结构体中，非空白字段的名称必须是唯一的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">StructType    = &quot;struct&quot; &quot;{&quot; { FieldDecl &quot;;&quot; } &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .</span></span>
<span class="line"><span style="color:#babed8">EmbeddedField = [ &quot;*&quot; ] TypeName [ TypeArgs ] .</span></span>
<span class="line"><span style="color:#babed8">Tag           = string_lit .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// An empty struct.</span></span>
<span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// A struct with 6 fields.</span></span>
<span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	x</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y </span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#BABED8">	u </span><span style="color:#C792EA">float32</span></span>
<span class="line"><span style="color:#BABED8">	_ </span><span style="color:#C792EA">float32</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// padding</span></span>
<span class="line"><span style="color:#BABED8">	A </span><span style="color:#89DDFF">*[]</span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#BABED8">	F </span><span style="color:#89DDFF">func()</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.</p>
</blockquote>
<p>使用了类型声明但却没有显式的字段名的字段称作嵌入字段。嵌入字段必须指定为类型名 T 或指向非接口类型名 *T 的指针，并且 T 本身可以不是指针类型。非限定的类型名充当了字段名。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4</span></span>
<span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	T1        </span><span style="color:#676E95;font-style:italic">// field name is T1</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">*</span><span style="color:#BABED8">T2       </span><span style="color:#676E95;font-style:italic">// field name is T2</span></span>
<span class="line"><span style="color:#BABED8">	P</span><span style="color:#89DDFF">.</span><span style="color:#BABED8">T3      </span><span style="color:#676E95;font-style:italic">// field name is T3</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">*</span><span style="color:#BABED8">P</span><span style="color:#89DDFF">.</span><span style="color:#BABED8">T4     </span><span style="color:#676E95;font-style:italic">// field name is T4</span></span>
<span class="line"><span style="color:#BABED8">	x</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y </span><span style="color:#C792EA">int</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// field names are x and y</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>The following declaration is illegal because field names must be unique in a struct type:</p>
</blockquote>
<p>以下声明是非法的，因为字段名在结构体类型中必须唯一：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	T     </span><span style="color:#676E95;font-style:italic">// conflicts with embedded field *T and *P.T</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">*</span><span style="color:#BABED8">T    </span><span style="color:#676E95;font-style:italic">// conflicts with embedded field T and *P.T</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">*</span><span style="color:#BABED8">P</span><span style="color:#89DDFF">.</span><span style="color:#BABED8">T  </span><span style="color:#676E95;font-style:italic">// conflicts with embedded field T and *T</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>A field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.</p>
</blockquote>
<p>如果 x.f 是表示字段或方法 f 中的合法的选择器，那么结构体 x 中的嵌入字段的字段或方法 f 就称作提升。</p>
<blockquote>
<p>Promoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.</p>
</blockquote>
<p>提升字段的作用与结构体的普通字段类似，但提升字段不能用作结构体的组合字面量中的字段名称。</p>
<blockquote>
<p>Given a struct type S and a named type T, promoted methods are included in the method set of the struct as follows:</p>
</blockquote>
<p>给定一个结构体类型 S 和一个具名类型 T ，提升的方法将包含在该结构体的方法集中，如下所示：</p>
<blockquote>
<ul>
<li>If S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T.</li>
</ul>
</blockquote>
<p>如果 S 包含嵌入字段 T ，则 S 和 *S 的方法集都会包含接收者 T 的方法集。 *S 的方法集还会包含带有接收者 *T 的提升方法。</p>
<blockquote>
<ul>
<li>If S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or *T.</li>
</ul>
</blockquote>
<p>如果 S 包含嵌入字段 *T ，则 S 和 *S 的方法集都会包含接收者 T 或 *T 的提升方法。</p>
<blockquote>
<p>A field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.</p>
</blockquote>
<p>字段声明后面可以跟一个可选的字符串字面量标签，该标签成为相应字段声明中所有字段的属性。空标签字符串等价于标签不存在。这些标签通过反射接口变得可见，并且会参与结构体的类型标识，但在其他情况下则会被忽略掉。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	x</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y </span><span style="color:#C792EA">float64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;&quot;</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// an empty tag string is like an absent tag</span></span>
<span class="line"><span style="color:#BABED8">	name </span><span style="color:#C792EA">string</span><span style="color:#BABED8">  </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">any string is permitted as a tag</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#BABED8">	_    </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">4</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">byte</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">ceci n&#39;est pas un champ de structure</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// A struct corresponding to a TimeStamp protocol buffer.</span></span>
<span class="line"><span style="color:#676E95;font-style:italic">// The tag strings define the protocol buffer field numbers;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic">// they follow the convention outlined by the reflect package.</span></span>
<span class="line"><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	microsec  </span><span style="color:#C792EA">uint64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">`</span><span style="color:#C3E88D">protobuf:&quot;1&quot;</span><span style="color:#89DDFF">`</span></span>
<span class="line"><span style="color:#BABED8">	serverIP6 </span><span style="color:#C792EA">uint64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">`</span><span style="color:#C3E88D">protobuf:&quot;2&quot;</span><span style="color:#89DDFF">`</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>A struct type T may not contain a field of type T, or of a type containing T as a component, directly or indirectly, if those containing types are only array or struct types.</p>
</blockquote>
<p>如果那些包含类型的字段只是数组或结构体类型的话，结构体类型 T 就不能直接或间接地包含 T 类型的字段，也不能直接或间接地包含 T 作为类型的一部分的字段。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// invalid struct types</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	T1 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> T1 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">            </span><span style="color:#676E95;font-style:italic">// T1 contains a field of T1</span></span>
<span class="line"><span style="color:#BABED8">	T2 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">T2 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">      </span><span style="color:#676E95;font-style:italic">// T2 contains T2 as component of an array</span></span>
<span class="line"><span style="color:#BABED8">	T3 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> T4 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">            </span><span style="color:#676E95;font-style:italic">// T3 contains T3 as component of an array in struct T4</span></span>
<span class="line"><span style="color:#BABED8">	T4 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">T3 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">      </span><span style="color:#676E95;font-style:italic">// T4 contains T4 as component of struct T3 in an array</span></span>
<span class="line"><span style="color:#BABED8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// valid struct types</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	T5 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">T5 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">         </span><span style="color:#676E95;font-style:italic">// T5 contains T5 as component of a pointer</span></span>
<span class="line"><span style="color:#BABED8">	T6 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">func()</span><span style="color:#BABED8"> T6 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">   </span><span style="color:#676E95;font-style:italic">// T6 contains T6 as component of a function type</span></span>
<span class="line"><span style="color:#BABED8">	T7 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">][]</span><span style="color:#BABED8">T7 </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">    </span><span style="color:#676E95;font-style:italic">// T7 contains T7 as component of a slice in an array</span></span>
<span class="line"><span style="color:#BABED8">)</span></span></code></pre>
<h3 id="pointer-types-指针类型">Pointer types 指针类型</h3>
<blockquote>
<p>A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.</p>
</blockquote>
<p>指针类型标识了一个指向给定类型变量的所有指针的集合，称作指针的基本类型。<br/>
未初始化指针的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">PointerType = &quot;*&quot; BaseType .</span></span>
<span class="line"><span style="color:#babed8">BaseType    = Type .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">*Point</span></span>
<span class="line"><span style="color:#babed8">*[4]int</span></span></code></pre>
<h3 id="function-types-函数类型">Function types 函数类型</h3>
<blockquote>
<p>A function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.</p>
</blockquote>
<p>函数类型表示具有相同参数和返回值类型的所有函数的集合。<br/>
函数类型的未初始化变量的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">FunctionType   = &quot;func&quot; Signature .</span></span>
<span class="line"><span style="color:#babed8">Signature      = Parameters [ Result ] .</span></span>
<span class="line"><span style="color:#babed8">Result         = Parameters | Type .</span></span>
<span class="line"><span style="color:#babed8">Parameters     = &quot;(&quot; [ ParameterList [ &quot;,&quot; ] ] &quot;)&quot; .</span></span>
<span class="line"><span style="color:#babed8">ParameterList  = ParameterDecl { &quot;,&quot; ParameterDecl } .</span></span>
<span class="line"><span style="color:#babed8">ParameterDecl  = [ IdentifierList ] [ &quot;...&quot; ] Type .</span></span></code></pre>
<blockquote>
<p>Within a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.</p>
</blockquote>
<p>在参数或结果列表中，名称（标识符列表）必须全部都存在或全部都不存在。<br/>
如果存在，则每个名称代表指定类型的一项（参数或返回值），并且签名中的所有非空白名称必须是唯一的。<br/>
如果不存在，则每种类型代表该类型的一项。<br/>
参数和结果列表总是用括号括起来，除非只有一个无命名的返回值，它可以写成不带括号的类型。</p>
<blockquote>
<p>The final incoming parameter in a function signature may have a type prefixed with <code>...</code>. A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.</p>
</blockquote>
<p>函数签名中的最终传入的参数也许带有前缀为 <code>...</code> 的类型。<br/>
具有这种参数的函数称为参数可变的，并且可以调用该参数的零个或多个实参。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">func()</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">x </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> _ </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> z </span><span style="color:#C792EA">float32</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#C792EA">bool</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> b </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> z </span><span style="color:#C792EA">float32</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#C792EA">bool</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">prefix </span><span style="color:#C792EA">string</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> values </span><span style="color:#89DDFF">...</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> b </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> z </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> opt </span><span style="color:#89DDFF">...interface{})</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">success </span><span style="color:#C792EA">bool</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*[]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">func(</span><span style="color:#BABED8">n </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">p </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">)</span></span></code></pre>
<h3 id="interface-types-接口类型">Interface types 接口类型</h3>
<blockquote>
<p>An interface type defines a type set. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.</p>
</blockquote>
<p>接口类型定义了一个类型集。接口类型的变量可以储存接口类型集中的任何类型的值。这样的类型就说它实现了接口。接口类型的未初始化变量的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">InterfaceType  = &quot;interface&quot; &quot;{&quot; { InterfaceElem &quot;;&quot; } &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">InterfaceElem  = MethodElem | TypeElem .</span></span>
<span class="line"><span style="color:#babed8">MethodElem     = MethodName Signature .</span></span>
<span class="line"><span style="color:#babed8">MethodName     = identifier .</span></span>
<span class="line"><span style="color:#babed8">TypeElem       = TypeTerm { &quot;|&quot; TypeTerm } .</span></span>
<span class="line"><span style="color:#babed8">TypeTerm       = Type | UnderlyingType .</span></span>
<span class="line"><span style="color:#babed8">UnderlyingType = &quot;~&quot; Type .</span></span></code></pre>
<blockquote>
<p>An interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.</p>
</blockquote>
<p>接口类型是由接口元素列表指定。接口元素可以是方法，也可以是类型元素，其中类型元素是一个或多个类型项的联合。类型项可以是单一类型，也可以是单一底层类型。</p>
<h4 id="basic-interfaces-基础接口">Basic interfaces 基础接口</h4>
<blockquote>
<p>In its most basic form an interface specifies a (possibly empty) list of methods. The type set defined by such an interface is the set of types which implement all of those methods, and the corresponding method set consists exactly of the methods specified by the interface. Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces.</p>
</blockquote>
<p>在接口最基本的形式中指定了一个（可能为空的）方法列表。这种接口定义的类型集是实现所有这些方法的类型集，并且相应的方法集恰好由该接口指定的方法组成。其类型集可以完全由方法列表定义的接口称作基本接口。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// A simple File interface.</span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	Read([]byte) (int, error)</span></span>
<span class="line"><span style="color:#babed8">	Write([]byte) (int, error)</span></span>
<span class="line"><span style="color:#babed8">	Close() error</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>The name of each explicitly specified method must be unique and not blank.</p>
</blockquote>
<p>每个显式指定的方法名必须唯一的且不为空。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	String() string</span></span>
<span class="line"><span style="color:#babed8">	String() string  // illegal: String not unique</span></span>
<span class="line"><span style="color:#babed8">	_(x int)         // illegal: method must have non-blank name</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>More than one type may implement an interface. For instance, if two types S1 and S2 have the method set</p>
</blockquote>
<p>不止一种类型可以实现一个接口。例如，如果两个类型 S1 和 S2 设置了（如下）方法集</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func (p T) Read(p []byte) (n int, err error)</span></span>
<span class="line"><span style="color:#babed8">func (p T) Write(p []byte) (n int, err error)</span></span>
<span class="line"><span style="color:#babed8">func (p T) Close() error</span></span></code></pre>
<blockquote>
<p>(where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2, regardless of what other methods S1 and S2 may have or share.</p>
</blockquote>
<p>（其中 T 代表 S1 或 S2 ），则 File 接口由 S1 和 S2 实现，无论 S1 和 S2 可能拥有或共享了什么其他方法。</p>
<blockquote>
<p>Every type that is a member of the type set of an interface implements that interface. Any given type may implement several distinct interfaces. For instance, all types implement the empty interface which stands for the set of all (non-interface) types:</p>
</blockquote>
<p>接口的类型集的成员的每个类型，都实现了该接口。<br/>
任意给定类型都可以实现多个不同的接口。<br/>
例如，所有类型都实现了空接口，空接口代表所有（非接口）类型的集合：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">interface{}</span></span></code></pre>
<blockquote>
<p>For convenience, the predeclared type any is an alias for the empty interface.</p>
</blockquote>
<p>为了方便起见，预声明的类型 any 是空接口的别名。</p>
<blockquote>
<p>Similarly, consider this interface specification, which appears within a type declaration to define an interface called Locker:</p>
</blockquote>
<p>同样，考虑到这一接口规范，（以下内容）出现在类型声明中来定义一个名为 Locker 的接口：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Locker</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">interface</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Lock</span><span style="color:#89DDFF">()</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Unlock</span><span style="color:#89DDFF">()</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>If S1 and S2 also implement</p>
</blockquote>
<p>如果 S1 和 S2 也实现（以下内容）</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">p T</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">Lock</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">p T</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">Unlock</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>they implement the Locker interface as well as the File interface.</p>
</blockquote>
<p>它们实现了 Locker 接口和 File 接口。</p>
<h4 id="embedded-interfaces-内嵌接口">Embedded interfaces 内嵌接口</h4>
<blockquote>
<p>In a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element. This is called embedding interface E in T. The type set of T is the intersection of the type sets defined by T’s explicitly declared methods and the type sets of T’s embedded interfaces. In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E.</p>
</blockquote>
<p>在稍微更一般的形式中，接口 T 可以使用（可能是限定的）接口类型名 E 作为接口元素。<br/>
这称为在 T 中嵌入接口 E 。<br/>
T 的类型集是 T 显式声明的方法定义的类型集与 T 的嵌入接口的类型集的交集。<br/>
换言之， T 的类型集是既实现了 T 的所有显式声明的方法又实现了 E 的所有方法的所有类型的集合。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Reader</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">interface</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Read</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">p </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">byte</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">n </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> err </span><span style="color:#C792EA">error</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Close</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#C792EA">error</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Writer</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">interface</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Write</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">p </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">byte</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">n </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> err </span><span style="color:#C792EA">error</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#82AAFF">Close</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#C792EA">error</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// ReadWriter&#39;s methods are Read, Write, and Close.</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">ReadWriter</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">interface</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	Reader  </span><span style="color:#676E95;font-style:italic">// includes methods of Reader in ReadWriter&#39;s method set</span></span>
<span class="line"><span style="color:#BABED8">	Writer  </span><span style="color:#676E95;font-style:italic">// includes methods of Writer in ReadWriter&#39;s method set</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>When embedding interfaces, methods with the same names must have identical signatures.</p>
</blockquote>
<p>嵌入接口时，同名方法的签名必须相同。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type ReadCloser interface {</span></span>
<span class="line"><span style="color:#babed8">	Reader   // includes methods of Reader in ReadCloser&#39;s method set</span></span>
<span class="line"><span style="color:#babed8">	Close()  // illegal: signatures of Reader.Close and Close are different</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h4 id="general-interfaces-通用接口">General interfaces 通用接口</h4>
<blockquote>
<p>In their most general form, an interface element may also be an arbitrary type term T, or a term of the form ~T specifying the underlying type T, or a union of terms t1|t2|…|tn. Together with method specifications, these elements enable the precise definition of an interface’s type set as follows:</p>
</blockquote>
<p>在最通用的形式中，界面元素也可以是任意类型项 T ，或指定底层类型 T 的 <code>~T</code> 形式的项，或者项 <code>t1|t2|…|tn</code> 的并集。这些元素与方法规范一起实现了接口类型集的精确定义，如下所示：</p>
<blockquote>
<ul>
<li>The type set of the empty interface is the set of all non-interface types.</li>
</ul>
</blockquote>
<p>空接口的类型集，是所有非接口类型的集合。</p>
<blockquote>
<ul>
<li>The type set of a non-empty interface is the intersection of the type sets of its interface elements.</li>
</ul>
</blockquote>
<p>非空接口的类型集，是其接口元素的类型集的交集。</p>
<blockquote>
<ul>
<li>The type set of a method specification is the set of all non-interface types whose method sets include that method.</li>
</ul>
</blockquote>
<p>方法规范的类型集，是其方法集包括该方法的所有非接口类型的集合。</p>
<blockquote>
<ul>
<li>The type set of a non-interface type term is the set consisting of just that type.</li>
</ul>
</blockquote>
<p>非接口类型项的类型集是只由该类型组成的集合。</p>
<blockquote>
<ul>
<li>The type set of a term of the form ~T is the set of all types whose underlying type is T.</li>
</ul>
</blockquote>
<p><code>~T</code> 形式的项的类型集，是底层类型为 T 的所有类型的集合。</p>
<blockquote>
<ul>
<li>The type set of a union of terms t1|t2|…|tn is the union of the type sets of the terms.</li>
</ul>
</blockquote>
<p><code>t1|t2|…|tn</code> 项并集的类型集，是这些项的类型集的并集。</p>
<blockquote>
<p>The quantification “the set of all non-interface types” refers not just to all (non-interface) types declared in the program at hand, but all possible types in all possible programs, and hence is infinite. Similarly, given the set of all non-interface types that implement a particular method, the intersection of the method sets of those types will contain exactly that method, even if all types in the program at hand always pair that method with another method.</p>
</blockquote>
<p>对“所有非接口类型的集合”的量化，不仅指当前程序中声明的所有（非接口）类型，还指所有可能程的序中的所有可能的类型，因此是无限的。<br/>
类似地，给定实现特定方法的所有非接口类型的集合，这些类型的方法集的交集将恰好包含该方法，即使当前程序中的所有类型总是将该方法与另一个方法配对。</p>
<blockquote>
<p>By construction, an interface’s type set never contains an interface type.</p>
</blockquote>
<p>根据构造，接口的类型集一定不会包含接口类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// An interface representing only the type int.</span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// An interface representing all types with underlying type int.</span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	~int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// An interface representing all types with underlying type int that implement the String method.</span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	~int</span></span>
<span class="line"><span style="color:#babed8">	String() string</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// An interface representing an empty type set: there is no type that is both an int and a string.</span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	int</span></span>
<span class="line"><span style="color:#babed8">	string</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>In a term of the form ~T, the underlying type of T must be itself, and T cannot be an interface.</p>
</blockquote>
<p>在 <code>~T</code> 形式的项中， T 的底层类型必须是其自身，并且 T 不能是一个接口。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type MyInt int</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	~[]byte  // the underlying type of []byte is itself</span></span>
<span class="line"><span style="color:#babed8">	~MyInt   // illegal: the underlying type of MyInt is not MyInt</span></span>
<span class="line"><span style="color:#babed8">	~error   // illegal: error is an interface</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>Union elements denote unions of type sets:</p>
</blockquote>
<p>联合元素表示类型集的联合：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// The Float interface represents all floating-point types</span></span>
<span class="line"><span style="color:#babed8">// (including any named types whose underlying types are</span></span>
<span class="line"><span style="color:#babed8">// either float32 or float64).</span></span>
<span class="line"><span style="color:#babed8">type Float interface {</span></span>
<span class="line"><span style="color:#babed8">	~float32 | ~float64</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>The type T in a term of the form T or ~T cannot be a type parameter, and the type sets of all non-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty). Given a type parameter P:</p>
</blockquote>
<p>T 或 <code>~T</code> 形式的项中的类型 T 不能是类型参数，并且所有非接口项的类型集必须是成对不相交的（类型集的成对交集必须为空）。<br/>
给定类型参数 P ：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">interface {</span></span>
<span class="line"><span style="color:#babed8">	P                // illegal: P is a type parameter</span></span>
<span class="line"><span style="color:#babed8">	int | ~P         // illegal: P is a type parameter</span></span>
<span class="line"><span style="color:#babed8">	~int | MyInt     // illegal: the type sets for ~int and MyInt are not disjoint (~int includes MyInt)</span></span>
<span class="line"><span style="color:#babed8">	float32 | Float  // overlapping type sets but Float is an interface</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>Implementation restriction: A union (with more than one term) cannot contain the predeclared identifier comparable or interfaces that specify methods, or embed comparable or interfaces that specify methods.</p>
</blockquote>
<p>实现限制：联合（具有多个项）不能包含预声明的标识符 <code>comparable</code> 或特定方法的接口，也不能嵌入 <code>comparable</code> 或特定方法的接口。</p>
<blockquote>
<p>Interfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.</p>
</blockquote>
<p>非基本接口只能用作类型约束，或者用作用于约束的其他接口的元素。<br/>
它们不能是值或者变量的类型，也不能是其他非接口类型的一部分。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x Float                     // illegal: Float is not a basic interface</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var x interface{} = Float(nil)  // illegal</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type Floatish struct {</span></span>
<span class="line"><span style="color:#babed8">	f Float                 // illegal</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>An interface type T may not embed a type element that is, contains, or embeds T, directly or indirectly.</p>
</blockquote>
<p>接口类型 T 不可以嵌入一个直接或间接地包含或嵌入了 T 的类型元素。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// illegal: Bad may not embed itself</span></span>
<span class="line"><span style="color:#babed8">type Bad interface {</span></span>
<span class="line"><span style="color:#babed8">	Bad</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// illegal: Bad1 may not embed itself using Bad2</span></span>
<span class="line"><span style="color:#babed8">type Bad1 interface {</span></span>
<span class="line"><span style="color:#babed8">	Bad2</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">type Bad2 interface {</span></span>
<span class="line"><span style="color:#babed8">	Bad1</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// illegal: Bad3 may not embed a union containing Bad3</span></span>
<span class="line"><span style="color:#babed8">type Bad3 interface {</span></span>
<span class="line"><span style="color:#babed8">	~int | ~string | Bad3</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// illegal: Bad4 may not embed an array containing Bad4 as element type</span></span>
<span class="line"><span style="color:#babed8">type Bad4 interface {</span></span>
<span class="line"><span style="color:#babed8">	[10]Bad4</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h4 id="implementing-an-interface-实现一个接口">Implementing an interface 实现一个接口</h4>
<blockquote>
<p>A type T implements an interface I if</p>
</blockquote>
<p>如果（满足以下任一条件），就说类型 T 实现了接口 I</p>
<blockquote>
<ul>
<li>T is not an interface and is an element of the type set of I; or</li>
</ul>
</blockquote>
<p>T 不是接口，而是 I 的类型集的元素；或者</p>
<blockquote>
<ul>
<li>T is an interface and the type set of T is a subset of the type set of I.</li>
</ul>
</blockquote>
<p>T 是一个接口， T 的类型集是 I 的类型集的子集。</p>
<blockquote>
<p>A value of type T implements an interface if T implements the interface.</p>
</blockquote>
<p>如果 T 实现了某个接口，则 T 类型的值也实现了这个接口。</p>
<h3 id="map-types-map-类型">Map types Map 类型</h3>
<blockquote>
<p>A map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is nil.</p>
</blockquote>
<p>map 是一种称作元素类型的类型的无序元素组，由另一种称作键类型的类型的一组唯一键进行索引。<br/>
未初始化的 map 的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">MapType     = &quot;map&quot; &quot;[&quot; KeyType &quot;]&quot; ElementType .</span></span>
<span class="line"><span style="color:#babed8">KeyType     = Type .</span></span></code></pre>
<blockquote>
<p>The comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.</p>
</blockquote>
<p>必须为键类型的操作数完全定义比较运算符 <code>==</code> 和 <code>!=</code> ；因此键类型不能是函数、 map 或切片。<br/>
如果键类型是接口类型，则必须为动态的键值来定义这些比较运算符；失败的话会导致运行时 panic 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">map[string]int</span></span>
<span class="line"><span style="color:#babed8">map[*T]struct{ x, y float64 }</span></span>
<span class="line"><span style="color:#babed8">map[string]interface{}</span></span></code></pre>
<blockquote>
<p>The number of map elements is called its length. For a map m, it can be discovered using the built-in function len and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the delete and clear built-in function.</p>
</blockquote>
<p>map 的元素的数量称作 map 的长度。<br/>
对于 map m ，可以使用内置函数 len 来查看，并且长度可能在运行过程中发生变化。<br/>
可以在运行期间使用赋值来添加元素，并使用索引表达式来检索元素；<br/>
它们可以使用内置函数 delete 和 clear 来删除。</p>
<blockquote>
<p>A new, empty map value is made using the built-in function make, which takes the map type and an optional capacity hint as arguments:</p>
</blockquote>
<p>一个新的空 map 值是用内置函数 make 来创建的， make 函数将 map 的类型和可选的容量提示作为实参：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">make(map[string]int)</span></span>
<span class="line"><span style="color:#babed8">make(map[string]int, 100)</span></span></code></pre>
<blockquote>
<p>The initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no elements may be added.</p>
</blockquote>
<p>初始容量不会限制其大小： map 会增长来容纳其中存储的项的数量，但 nil map 除​​外。 nil map 相当于空的 map ，但是并不能添加任何元素。</p>
<h3 id="channel-types-通道类型">Channel types 通道类型</h3>
<blockquote>
<p>A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.</p>
</blockquote>
<p>通道提供了一种并发执行函数的机制，通过发送和接收指定元素类型的值来进行通信。<br/>
未初始化通道的值为 nil 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ChannelType = ( &quot;chan&quot; | &quot;chan&quot; &quot;&lt;-&quot; | &quot;&lt;-&quot; &quot;chan&quot; ) ElementType .</span></span></code></pre>
<blockquote>
<p>The optional <code>&lt;-</code> operator specifies the channel direction, send or receive. If a direction is given, the channel is directional, otherwise it is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.</p>
</blockquote>
<p>可选的 <code>&lt;-</code> 运算符指定了通道为单向、发送（只发）或接收（只收）。如果指定方向，则通道是单向的，否则就是双向的。通过分配或显式转换，通道可以被限制为只能发送或只能接收。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">chan T          // can be used to send and receive values of type T</span></span>
<span class="line"><span style="color:#babed8">chan&lt;- float64  // can only be used to send float64s</span></span>
<span class="line"><span style="color:#babed8">&lt;-chan int      // can only be used to receive ints</span></span></code></pre>
<blockquote>
<p>The <code>&lt;-</code> operator associates with the leftmost chan possible:</p>
</blockquote>
<p><code>&lt;-</code> 运算符与最左边的 <code>chan</code> 可能产生关联：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">chan&lt;- chan int    // same as chan&lt;- (chan int)</span></span>
<span class="line"><span style="color:#babed8">chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)</span></span>
<span class="line"><span style="color:#babed8">&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)</span></span>
<span class="line"><span style="color:#babed8">chan (&lt;-chan int)</span></span></code></pre>
<blockquote>
<p>A new, initialized channel value can be made using the built-in function make, which takes the channel type and an optional capacity as arguments:</p>
</blockquote>
<p>一个新的初始化了的通道值是通过内置函数 make 来创建的， make 函数将通道类型和可选容量作为实参：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">make(chan int, 100)</span></span></code></pre>
<blockquote>
<p>The capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication.</p>
</blockquote>
<p>用元素数量表示的容量，设置了通道中缓冲区的大小。<br/>
如果容量为零或不存在，则通道无缓冲，并且只有当发送方和接收方都准备好时，通信才会成功。<br/>
否则，如果缓冲区未满（发送）或不为空（接收），则通道将会被缓冲，并且通信会成功而不会阻塞。<br/>
nil 通道永远也不会准备好进行通信。</p>
<blockquote>
<p>A channel may be closed with the built-in function close. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.</p>
</blockquote>
<p>可以使用内置函数 close 来关闭通道。<br/>
接收操作符的多值赋值形式报告了在通道关闭之前，接收到的值是否已经被发送。</p>
<blockquote>
<p>A single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.</p>
</blockquote>
<p>单个通道可以用于对任意个数协程中的发送语句、接收操作以及对内置函数 cap 和 len 的调用，而无需进一步同步。<br/>
通道充当了先进先出队列。<br/>
比如，如果一个协程在通道上发送值，而第二个协程接收这些值，则这些值将按照发送的顺序来接收。</p>
<h2 id="properties-of-types-and-values-类型和值的属性">Properties of types and values 类型和值的属性</h2>
<h3 id="underlying-types-底层类型">Underlying types 底层类型</h3>
<blockquote>
<p>Each type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T’s underlying type is the underlying type of the type to which T refers in its declaration. For a type parameter that is the underlying type of its type constraint, which is always an interface.</p>
</blockquote>
<p>每个类型 T 都有一个底层类型：如果 T 是预声明的布尔、数字或字符串类型之一，或者类型字面量，则相应的底层类型为 T 自身。<br/>
否则， T 的底层类型是 T 在其声明中引用的类型的底层类型。对于作为其类型约束的底层类型的类型参数，它始终是一个接口。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	A1 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#BABED8">	A2 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> A1</span></span>
<span class="line"><span style="color:#BABED8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	B1 </span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#BABED8">	B2 B1</span></span>
<span class="line"><span style="color:#BABED8">	B3 </span><span style="color:#89DDFF">[]</span><span style="color:#BABED8">B1</span></span>
<span class="line"><span style="color:#BABED8">	B4 B3</span></span>
<span class="line"><span style="color:#BABED8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> f</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">P any</span><span style="color:#89DDFF">](</span><span style="color:#BABED8">x P</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>The underlying type of string, A1, A2, B1, and B2 is string. The underlying type of []B1, B3, and B4 is []B1. The underlying type of P is interface.</p>
</blockquote>
<p><code>string</code> 、 <code>A1</code> 、 <code>A2</code> 、 <code>B1</code> 和 <code>B2</code> 的底层类型是 <code>string</code> 。<br/>
<code>B3</code> 和 <code>B4</code> 的底层类型是 <code>[]B1</code> 。<br/>
<code>P</code> 的底层类型是 <code>interface{}</code> 。</p>
<h3 id="core-types-核心类型">Core types 核心类型</h3>
<blockquote>
<p>Each non-interface type T has a core type, which is the same as the underlying type of T.</p>
</blockquote>
<p>每个非接口类型 T 都有一个核心类型，它与 T 的底层类型相同。</p>
<blockquote>
<p>An interface T has a core type if one of the following conditions is satisfied:</p>
</blockquote>
<p>如果满足以下条件之一，则接口 T 具有核心类型：</p>
<blockquote>
<ol>
<li>There is a single type U which is the underlying type of all types in the type set of T; or</li>
</ol>
</blockquote>
<p>有一个单独的类型 U ，它是 T 类型集中所有类型的底层类型；或者</p>
<blockquote>
<ol start="2">
<li>the type set of T contains only channel types with identical element type E, and all directional channels have the same direction.</li>
</ol>
</blockquote>
<p>T 的类型集仅包含具有相同元素类型 E 的通道类型，并且所有单向通道都具有相同的方向。</p>
<blockquote>
<p>No other interfaces have a core type.</p>
</blockquote>
<p>没有其他接口具有核心类型。</p>
<blockquote>
<p>The core type of an interface is, depending on the condition that is satisfied, either:</p>
</blockquote>
<p>根据（以下）满足的条件，接口的核心类型是：</p>
<blockquote>
<ol>
<li>the type U; or</li>
</ol>
</blockquote>
<p>类型 U ；或者</p>
<blockquote>
<ol start="2">
<li>the type chan E if T contains only bidirectional channels, or the type <code>chan&lt;- E</code> or <code>&lt;-chan E</code> depending on the direction of the directional channels present.</li>
</ol>
</blockquote>
<p>如果 T 仅包含双向通道，则为 <code>chan E</code> 类型，或者根据现有的单向通道的方向，为 <code>chan&lt;- E</code> 或 <code>&lt;-chan E</code> 类型。</p>
<blockquote>
<p>By definition, a core type is never a defined type, type parameter, or interface type.</p>
</blockquote>
<p>根据定义，核心类型一定不是已定义的类型、类型参数或接口类型。</p>
<blockquote>
<p>Examples of interfaces with core types:</p>
</blockquote>
<p>（以下是）具有核心类型的接口示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Celsius</span><span style="color:#BABED8"> </span><span style="color:#C792EA">float32</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Kelvin</span><span style="color:#BABED8">  </span><span style="color:#C792EA">float32</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">                          </span><span style="color:#676E95;font-style:italic">// int</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> Celsius</span><span style="color:#89DDFF">|</span><span style="color:#BABED8">Kelvin </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">               </span><span style="color:#676E95;font-style:italic">// float32</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> ~</span><span style="color:#89DDFF">chan</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">                    </span><span style="color:#676E95;font-style:italic">// chan int</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> ~</span><span style="color:#89DDFF">chan</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">|</span><span style="color:#BABED8">~</span><span style="color:#89DDFF">chan&lt;-</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">        </span><span style="color:#676E95;font-style:italic">// chan&lt;- int</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> ~</span><span style="color:#89DDFF">[]*</span><span style="color:#BABED8">data</span><span style="color:#89DDFF">;</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">String</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">    </span><span style="color:#676E95;font-style:italic">// []*data</span></span></code></pre>
<blockquote>
<p>Examples of interfaces without core types:</p>
</blockquote>
<p>（以下是）没有核心类型的接口示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">interface{}</span><span style="color:#BABED8">                               </span><span style="color:#676E95;font-style:italic">// no single underlying type</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> Celsius</span><span style="color:#89DDFF">|</span><span style="color:#C792EA">float64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">              </span><span style="color:#676E95;font-style:italic">// no single underlying type</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">chan</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">chan&lt;-</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">     </span><span style="color:#676E95;font-style:italic">// channels have different element types</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&lt;-chan</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">chan&lt;-</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">      </span><span style="color:#676E95;font-style:italic">// directional channels have different directions</span></span></code></pre>
<blockquote>
<p>Some operations (slice expressions, append and copy) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, []byte and string, which are the underlying types of all types in the type set of interface T, the core type of T is called bytestring.</p>
</blockquote>
<p>某些操作（切片表达式、 append 追加 和 copy 复制 ）依赖于接受字节切片和字符串的稍宽松的核心类型的形式。<br/>
具体而言，如果刚好有两个类型 <code>[]byte</code> 和 <code>string</code> ，它们是接口 T 的类型集中所有类型的底层类型，则核心类型 T 就称做 <code>bytestring</code> 。</p>
<blockquote>
<p>Examples of interfaces with bytestring core types:</p>
</blockquote>
<p>（以下是）具有 <code>bytestring</code> 核心类型的接口示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">                          </span><span style="color:#676E95;font-style:italic">// int (same as ordinary core type)</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">byte</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">              </span><span style="color:#676E95;font-style:italic">// bytestring</span></span>
<span class="line"><span style="color:#89DDFF">interface{</span><span style="color:#BABED8"> ~</span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">byte</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> myString </span><span style="color:#89DDFF">}</span><span style="color:#BABED8">           </span><span style="color:#676E95;font-style:italic">// bytestring</span></span></code></pre>
<blockquote>
<p>Note that bytestring is not a real type; it cannot be used to declare variables or compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.</p>
</blockquote>
<p>注意， <code>bytestring</code> 并不是一个真实存在的类型；<br/>
<code>bytestring</code> 不能用于声明变量或组成其他类型。<br/>
<code>bytestring</code> 的存在只是为了描述从字节序列（可能是字节切片或字符串）中读取的某些操作的行为。</p>
<h3 id="type-identity-类型标识">Type identity 类型标识</h3>
<blockquote>
<p>Two types are either identical or different.</p>
</blockquote>
<p>两种类型要么相同，要么不同。</p>
<blockquote>
<p>A named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:</p>
</blockquote>
<p>具名类型始终不同于其他任何类型。<br/>
否则，如果两个类型的底层类型字面量在结构上是等效的，那么就称它们是相同的；也就是说，它们具有相同的字面结构，并且相应的部分也都具有相同的类型。<br/>
具体如下：</p>
<blockquote>
<ul>
<li>Two array types are identical if they have identical element types and the same array length.</li>
</ul>
</blockquote>
<p>如果两个数组类型具有相同的元素类型和相同的数组长度，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two slice types are identical if they have identical element types.</li>
</ul>
</blockquote>
<p>如果两个切片类型具有相同的元素类型，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Non-exported field names from different packages are always different.</li>
</ul>
</blockquote>
<p>如果两个结构体类型具有相同的字段序列，并且相应的字段也具有相同的名称、相同的类型和相同的标记，那么它们就是相同的。<br/>
不同包中的非导出字段名总是不同的。</p>
<blockquote>
<ul>
<li>Two pointer types are identical if they have identical base types.</li>
</ul>
</blockquote>
<p>如果两个指针类型具有相同的基础类型，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.</li>
</ul>
</blockquote>
<p>如果两个函数类型具有相同数量的参数和返回值，相应的参数和返回值类型相同，并且两个函数都是可变参数或都不是，那么它们就是相同的。<br/>
参数和返回值名称不需要匹配。</p>
<blockquote>
<ul>
<li>Two interface types are identical if they define the same type set.</li>
</ul>
</blockquote>
<p>如果两个接口类型定义了相同的类型集，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two map types are identical if they have identical key and element types.</li>
</ul>
</blockquote>
<p>如果两个 map 类型具有相同的键和元素类型，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two channel types are identical if they have identical element types and the same direction.</li>
</ul>
</blockquote>
<p>如果两个通道类型具有相同的元素类型和一致的方向，那么它们就是相同的。</p>
<blockquote>
<ul>
<li>Two instantiated types are identical if their defined types and all type arguments are identical.</li>
</ul>
</blockquote>
<p>如果两个实例化类型的定义类型和所有类型实参都相同，那么它们就是相同的。</p>
<blockquote>
<p>Given the declarations</p>
</blockquote>
<p>给定（如下）声明</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> (</span></span>
<span class="line"><span style="color:#BABED8">	A0 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#BABED8">	A1 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> A0</span></span>
<span class="line"><span style="color:#BABED8">	A2 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> b </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">	A3 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#BABED8">	A4 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">A3</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">A0</span></span>
<span class="line"><span style="color:#BABED8">	A5 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">x </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> _ </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*[]</span><span style="color:#C792EA">string</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	B0 A0</span></span>
<span class="line"><span style="color:#BABED8">	B1 </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#BABED8">	B2 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> b </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">	B3 </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> c </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">	B4 </span><span style="color:#89DDFF">func(</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">B0</span></span>
<span class="line"><span style="color:#BABED8">	B5 </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">x </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y </span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">A1</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">	C0 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> B0</span></span>
<span class="line"><span style="color:#BABED8">	D0</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">P1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> P2 any</span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">struct{</span><span style="color:#BABED8"> x P1</span><span style="color:#89DDFF">;</span><span style="color:#BABED8"> y P2 </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">	E0 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> D0</span><span style="color:#89DDFF">[</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#89DDFF">]</span></span>
<span class="line"><span style="color:#BABED8">)</span></span></code></pre>
<blockquote>
<p>these types are identical:</p>
</blockquote>
<p>（其中以下）这些类型是相同的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">A0, A1, and []string</span></span>
<span class="line"><span style="color:#babed8">A2 and struct{ a, b int }</span></span>
<span class="line"><span style="color:#babed8">A3 and int</span></span>
<span class="line"><span style="color:#babed8">A4, func(int, float64) *[]string, and A5</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">B0 and C0</span></span>
<span class="line"><span style="color:#babed8">D0[int, string] and E0</span></span>
<span class="line"><span style="color:#babed8">[]int and []int</span></span>
<span class="line"><span style="color:#babed8">struct{ a, b *B5 } and struct{ a, b *B5 }</span></span>
<span class="line"><span style="color:#babed8">func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5</span></span></code></pre>
<blockquote>
<p><code>B0 and B1 are different because they are new types created by distinct type definitions; func(int, float64) *B0 and func(x int, y float64) *[]string are different because B0 is different from []string; and P1 and P2 are different because they are different type parameters. D0[int, string] and struct{ x int; y string } are different because the former is an instantiated defined type while the latter is a type literal (but they are still assignable).</code></p>
</blockquote>
<p>B0 和 B1 是不同的，因为它们是由不同类型定义创建的新​​类型；<br/>
<code>func(int, float64) *B0</code> 和 <code>func(x int, y float64) *[]string</code> 不同，因为 <code>B0</code> 与 <code>[]string</code> 不同；<br/>
<code>P1</code> 和 <code>P2</code> 是不同的，因为它们是不同的类型参数。<br/>
<code>D0[int, string]</code> 和 <code>struct{ x int; y string }</code> 是不同的，因为前者是实例化的定义类型，而后者是类型字面量（但它们仍然是可赋值的）。</p>
<h3 id="assignability-可赋值性">Assignability 可赋值性</h3>
<blockquote>
<p>A value x of type V is assignable to a variable of type T (“x is assignable to T”) if one of the following conditions applies:</p>
</blockquote>
<p>如果满足以下条件之一， V 类型的值 x 就可以赋给 T 类型的变量（“称 x 是可赋值给 T 的”） ：</p>
<blockquote>
<ul>
<li>V and T are identical.</li>
</ul>
</blockquote>
<p>V 和 T 相同。</p>
<blockquote>
<ul>
<li>V and T have identical underlying types but are not type parameters and at least one of V or T is not a named type.</li>
</ul>
</blockquote>
<p>V 和 T 具有相同的基础类型，但不是类型参数，且 V 或 T 至少其中之一不是具名类型。</p>
<blockquote>
<ul>
<li>V and T are channel types with identical element types, V is a bidirectional channel, and at least one of V or T is not a named type.</li>
</ul>
</blockquote>
<p>V 和 T 是具有相同元素类型的通道类型， V 是双向通道， V 或 T 至少其中之一不是具名类型。</p>
<blockquote>
<ul>
<li>T is an interface type, but not a type parameter, and x implements T.</li>
</ul>
</blockquote>
<p>T 是接口类型，但不是类型参数，并且 x 实现了 T 。</p>
<blockquote>
<ul>
<li>x is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type, but not a type parameter.</li>
</ul>
</blockquote>
<p>x 是预声明的标识符 nil ， T 是指针、函数、切片、 map 、通道或接口类型，但不是类型参数。</p>
<blockquote>
<ul>
<li>x is an untyped constant representable by a value of type T.</li>
</ul>
</blockquote>
<p>x 是一个可由 T 类型的值表示的无类型常量。</p>
<blockquote>
<p>Additionally, if x’s type V or T are type parameters, x is assignable to a variable of type T if one of the following conditions applies:</p>
</blockquote>
<p>此外，如果 x 的类型 V 或 T 是类型参数，且满足以下条件之一，则 x 可赋值给 T 类型的变量：</p>
<blockquote>
<ul>
<li>x is the predeclared identifier nil, T is a type parameter, and x is assignable to each type in T’s type set.</li>
</ul>
</blockquote>
<p>x 是预声明的标识符 nil ， T 是类型参数， x 可赋值给 T 的类型集中的每种类型。</p>
<blockquote>
<ul>
<li>V is not a named type, T is a type parameter, and x is assignable to each type in T’s type set.</li>
</ul>
</blockquote>
<p>V 不是具名类型， T 是类型参数， x 可赋值给 T 的类型集中的每种类型。</p>
<blockquote>
<ul>
<li>V is a type parameter and T is not a named type, and values of each type in V’s type set are assignable to T.</li>
</ul>
</blockquote>
<p>V 是类型参数， T 不是具名类型， V 的类型集中的每种类型的值都可以赋值给 T 。</p>
<h3 id="representability-可表示性">Representability 可表示性</h3>
<blockquote>
<p>A constant x is representable by a value of type T, where T is not a type parameter, if one of the following conditions applies:</p>
</blockquote>
<p>如果满足以下条件之一，则常量 x 就可由类型 T 的值表示，其中 T 不是类型参数：</p>
<blockquote>
<ul>
<li>x is in the set of values determined by T.</li>
</ul>
</blockquote>
<p>x 位于由 T 确定的值集中。</p>
<blockquote>
<ul>
<li>T is a floating-point type and x can be rounded to T’s precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.</li>
</ul>
</blockquote>
<p>T 是浮点类型， x 可以四舍五入到 T 的精度而不会溢出。四舍五入使用的是 IEEE 754 舍入到偶数的规则，但 IEEE 负零会进一步简化为无符号零。<br/>
注意，常量值永远不会产生 IEEE 负零、NaN 或无穷大。</p>
<blockquote>
<ul>
<li>T is a complex type, and x’s components real(x) and imag(x) are representable by values of T’s component type (float32 or float64).</li>
</ul>
</blockquote>
<p>T 是一个复数类型， x 的实部 real(x) 和虚部 imag(x) 可以用 T 的部分类型的值表示（ float32 或 float64 ）。</p>
<blockquote>
<p>If T is a type parameter, x is representable by a value of type T if x is representable by a value of each type in T’s type set.</p>
</blockquote>
<p>如果 T 是类型参数，且 x 可以由 T 的类型集中的每种类型的值表示，则 x 可以由 T 类型的值表示。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x                   T           x is representable by a value of T because</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">&#39;a&#39;                 byte        97 is in the set of byte values</span></span>
<span class="line"><span style="color:#babed8">97                  rune        rune is an alias for int32, and 97 is in the set of 32-bit integers</span></span>
<span class="line"><span style="color:#babed8">&quot;foo&quot;               string      &quot;foo&quot; is in the set of string values</span></span>
<span class="line"><span style="color:#babed8">1024                int16       1024 is in the set of 16-bit integers</span></span>
<span class="line"><span style="color:#babed8">42.0                byte        42 is in the set of unsigned 8-bit integers</span></span>
<span class="line"><span style="color:#babed8">1e10                uint64      10000000000 is in the set of unsigned 64-bit integers</span></span>
<span class="line"><span style="color:#babed8">2.718281828459045   float32     2.718281828459045 rounds to 2.7182817 which is in the set of float32 values</span></span>
<span class="line"><span style="color:#babed8">-1e-1000            float64     -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0</span></span>
<span class="line"><span style="color:#babed8">0i                  int         0 is an integer value</span></span>
<span class="line"><span style="color:#babed8">(42 + 0i)           float32     42.0 (with zero imaginary part) is in the set of float32 values</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x                   T           x is not representable by a value of T because</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">0                   bool        0 is not in the set of boolean values</span></span>
<span class="line"><span style="color:#babed8">&#39;a&#39;                 string      &#39;a&#39; is a rune, it is not in the set of string values</span></span>
<span class="line"><span style="color:#babed8">1024                byte        1024 is not in the set of unsigned 8-bit integers</span></span>
<span class="line"><span style="color:#babed8">-1                  uint16      -1 is not in the set of unsigned 16-bit integers</span></span>
<span class="line"><span style="color:#babed8">1.1                 int         1.1 is not an integer value</span></span>
<span class="line"><span style="color:#babed8">42i                 float32     (0 + 42i) is not in the set of float32 values</span></span>
<span class="line"><span style="color:#babed8">1e1000              float64     1e1000 overflows to IEEE +Inf after rounding</span></span></code></pre>
<h3 id="method-sets-方法集">Method sets 方法集</h3>
<blockquote>
<p>The method set of a type determines the methods that can be called on an operand of that type. Every type has a (possibly empty) method set associated with it:</p>
</blockquote>
<p>类型的方法集决定了可以对该类型的操作数调用哪些方法。<br/>
每个类型都有一个与之关联的方法集，方法集可以为空：</p>
<blockquote>
<ul>
<li>The method set of a defined type T consists of all methods declared with receiver type T.</li>
</ul>
</blockquote>
<p>定义类型 T 的方法集，由 T 类型接收者声明的所有方法组成。</p>
<blockquote>
<ul>
<li>The method set of a pointer to a defined type T (where T is neither a pointer nor an interface) is the set of all methods declared with receiver *T or T.</li>
</ul>
</blockquote>
<p>指向已定义类型 T （其中 T 既不能是指针也不能是接口）的指针的方法集，是 *T 或 T 类型的接收者声明的所有方法的集合。</p>
<blockquote>
<ul>
<li>The method set of an interface type is the intersection of the method sets of each type in the interface’s type set (the resulting method set is usually just the set of declared methods in the interface).</li>
</ul>
</blockquote>
<p>接口类型的方法集，是接口类型集中每个类型的方法集的交集（结果方法集通常只是接口中声明的方法集）。</p>
<blockquote>
<p>Further rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on struct types. Any other type has an empty method set.</p>
</blockquote>
<p>进一步的规则适用于包含嵌入字段的结构体（以及指向结构体的指针），如结构体类型部分中所描述的那样。<br/>
任何其他类型都有一个空的方法集。</p>
<blockquote>
<p>In a method set, each method must have a unique non-blank method name.</p>
</blockquote>
<p>在方法集中，每个方法都必须具有唯一的非空白方法名。</p>
<h2 id="blocks-块">Blocks 块</h2>
<blockquote>
<p>A block is a possibly empty sequence of declarations and statements within matching brace brackets.</p>
</blockquote>
<p>块是匹配大括号内的声明和语句序列，块可能为空。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Block = &quot;{&quot; StatementList &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">StatementList = { Statement &quot;;&quot; } .</span></span></code></pre>
<blockquote>
<p>In addition to explicit blocks in the source code, there are implicit blocks:</p>
</blockquote>
<p>源代码中除了显式的块之外，还有隐式的块：</p>
<blockquote>
<ol>
<li>The universe block encompasses all Go source text.</li>
</ol>
</blockquote>
<p>全局块包含了所有 Go 源代码文本。</p>
<blockquote>
<ol start="2">
<li>Each package has a package block containing all Go source text for that package.</li>
</ol>
</blockquote>
<p>每个包都有一个包块，包含了该包的所有 Go 源代码文本。</p>
<blockquote>
<ol start="3">
<li>Each file has a file block containing all Go source text in that file.</li>
</ol>
</blockquote>
<p>每个文件都有一个文件块，其中包含该文件中的所有 Go 源文本。</p>
<blockquote>
<ol start="4">
<li>Each “if”, “for”, and “switch” statement is considered to be in its own implicit block.</li>
</ol>
</blockquote>
<p>每个”if”、“for”和”switch”语句都被视为是位于自己的隐式块中。</p>
<blockquote>
<ol start="5">
<li>Each clause in a “switch” or “select” statement acts as an implicit block.</li>
</ol>
</blockquote>
<p>“switch”或”select”语句中的每个子句都充当了一个隐式块。</p>
<blockquote>
<p>Blocks nest and influence scoping.</p>
</blockquote>
<p>块是层层嵌套的，这会影响作用域。</p>
<h2 id="declarations-and-scope-声明和作用域">Declarations and scope 声明和作用域</h2>
<blockquote>
<p>A declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.</p>
</blockquote>
<p>声明是将非空标识符绑定到常量、类型、类型参数、变量、函数、标签或包上。<br/>
程序中的每个标识符都必须声明。<br/>
标识符不能在同一块中声明两次，并且标识符不能同时在文件和包块中声明。</p>
<blockquote>
<p>The blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier init may only be used for init function declarations, and like the blank identifier it does not introduce a new binding.</p>
</blockquote>
<p>空白标识符可以像声明中的其他任何标识符一样使用，但它不会引入绑定，因此也不会被声明。<br/>
在包块中，标识符 init 只能用于 init 函数声明中，并且与空白标识符一样不会引入新的绑定。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Declaration   = ConstDecl | TypeDecl | VarDecl .</span></span>
<span class="line"><span style="color:#babed8">TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .</span></span></code></pre>
<blockquote>
<p>The scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.</p>
</blockquote>
<p>声明的标识符的作用域是源代码文本的范围，其中标识符表示指定的常量、类型、变量、函数、标签或包。</p>
<blockquote>
<p>Go is lexically scoped using blocks:</p>
</blockquote>
<p>Go 使用块来确定词法作用域：</p>
<blockquote>
<ol>
<li>The scope of a predeclared identifier is the universe block.</li>
</ol>
</blockquote>
<p>预声明标识符的作用域是全局块。</p>
<blockquote>
<ol start="2">
<li>The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.</li>
</ol>
</blockquote>
<p>在顶层（任何函数外部）声明的常量、类型、变量或函数（但不是方法）的标识符的作用域是包的块。</p>
<blockquote>
<ol start="3">
<li>The scope of the package name of an imported package is the file block of the file containing the import declaration.</li>
</ol>
</blockquote>
<p>导入包的包名作用域是包含导入声明的文件的文件块。</p>
<blockquote>
<ol start="4">
<li>The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.</li>
</ol>
</blockquote>
<p>用于表示方法接收者、函数参数或结果变量的标识符的作用域是函数体。</p>
<blockquote>
<ol start="5">
<li>The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.</li>
</ol>
</blockquote>
<p>表示函数类型参数或由方法接收者声明的标识符的作用域，是从函数名称之后开始，直到函数体末尾结束。</p>
<blockquote>
<ol start="6">
<li>The scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.</li>
</ol>
</blockquote>
<p>表示类型的类型参数的标识符的作用域，是从类型名称之后开始，直到 TypeSpec 末尾结束。</p>
<blockquote>
<ol start="7">
<li>The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.</li>
</ol>
</blockquote>
<p>函数内部声明的常量或变量标识符的作用域，是从 ConstSpec 或 VarSpec（用于短变量声明的 ShortVarDecl）的末尾开始，直到最内层包含块的末尾结束。</p>
<blockquote>
<ol start="8">
<li>The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.</li>
</ol>
</blockquote>
<p>函数内部声明的类型标识符的作用域，是从 TypeSpec 中的标识符开始，到最内层包含块的末尾结束。</p>
<blockquote>
<p>An identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.</p>
</blockquote>
<p>在块中声明的标识符可以在内部块中重新声明。<br/>
当内部声明的标识符在作用域内时，它表示内部声明所声明的实体。</p>
<blockquote>
<p>The package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.</p>
</blockquote>
<p><code>pacakge 包名</code> 不是声明；<br/>
包名不会出现在任何作用域内。<br/>
包名的作用是识别那些属于同一包的文件，并指定导入声明的默认包名。</p>
<h3 id="label-scopes-标签作用域">Label scopes 标签作用域</h3>
<blockquote>
<p>Labels are declared by labeled statements and are used in the “break”, “continue”, and “goto” statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.</p>
</blockquote>
<p>标签由带标签的语句来声明，并用在”break”、“continue”和”goto”语句中。<br/>
定义一个从不使用的标签是非法的。<br/>
与其他标识符相比，标签不是块级作用域的，并且也不会与不是标签的标识符冲突。<br/>
标签的作用域是声明它的函数体，不包括任何嵌套函数的函数体。</p>
<h3 id="blank-identifier-空白标识符">Blank identifier 空白标识符</h3>
<blockquote>
<p>The blank identifier is represented by the underscore character _. It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignment statements.</p>
</blockquote>
<p>空白标识符由下划线字符 _ 来表示。<br/>
它用作匿名占位符，而不是常规的（非空白）标识符，并且在声明、操作数和赋值语句中有特殊含义。</p>
<h3 id="predeclared-identifiers-预声明标识符">Predeclared identifiers 预声明标识符</h3>
<blockquote>
<p>The following identifiers are implicitly declared in the universe block:</p>
</blockquote>
<p>以下标识符在全局块中已经隐式声明：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Types:</span></span>
<span class="line"><span style="color:#babed8">	any bool byte comparable</span></span>
<span class="line"><span style="color:#babed8">	complex64 complex128 error float32 float64</span></span>
<span class="line"><span style="color:#babed8">	int int8 int16 int32 int64 rune string</span></span>
<span class="line"><span style="color:#babed8">	uint uint8 uint16 uint32 uint64 uintptr</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">Constants:</span></span>
<span class="line"><span style="color:#babed8">	true false iota</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">Zero value:</span></span>
<span class="line"><span style="color:#babed8">	nil</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">Functions:</span></span>
<span class="line"><span style="color:#babed8">	append cap close complex copy delete imag len</span></span>
<span class="line"><span style="color:#babed8">	make new panic print println real recover</span></span></code></pre>
<h3 id="exported-identifiers-导出标识符">Exported identifiers 导出标识符</h3>
<blockquote>
<p>An identifier may be exported to permit access to it from another package. An identifier is exported if both:</p>
</blockquote>
<p>标识符可以被导出以便可以从另一个包来访问到它。<br/>
如果以下条件都满足，则标识符就会被导出：</p>
<blockquote>
<ol>
<li>the first character of the identifier’s name is a Unicode uppercase letter (Unicode character category Lu); and</li>
</ol>
</blockquote>
<p>标识符名称的第一个字符应该是 Unicode 大写字母（Unicode 的字符类别 Lu，就是大写字母的代号）；以及（下一条也要满足）</p>
<blockquote>
<ol start="2">
<li>the identifier is declared in the package block or it is a field name or method name.</li>
</ol>
</blockquote>
<p>标识符在包块中声明，或者是字段名称或方法名称。</p>
<blockquote>
<p>All other identifiers are not exported.</p>
</blockquote>
<p>其他所有标识符都不会被导出。</p>
<h3 id="uniqueness-of-identifiers-标识符的唯一性">Uniqueness of identifiers 标识符的唯一性</h3>
<blockquote>
<p>Given a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.</p>
</blockquote>
<p>给定一组标识符，如果一个标识符与该组中的其他每个标识符都不同，则该标识符就是唯一的。<br/>
如果两个标识符的拼写不同，或者它们出现在不同的包中并且是未导出的，则它们就是不同的。否则，就认为它们是相同的。</p>
<h3 id="constant-declarations-常量声明">Constant declarations 常量声明</h3>
<blockquote>
<p>A constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.</p>
</blockquote>
<p>常量声明将标识符列表（一组常量的名称）绑定到一组常量表达式的值上。<br/>
标识符的数量必须与表达式的数量相同，并且左边的第n个标识符绑定到右边第n个表达式的值上。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ConstDecl      = &quot;const&quot; ( ConstSpec | &quot;(&quot; { ConstSpec &quot;;&quot; } &quot;)&quot; ) .</span></span>
<span class="line"><span style="color:#babed8">ConstSpec      = IdentifierList [ [ Type ] &quot;=&quot; ExpressionList ] .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">IdentifierList = identifier { &quot;,&quot; identifier } .</span></span>
<span class="line"><span style="color:#babed8">ExpressionList = Expression { &quot;,&quot; Expression } .</span></span></code></pre>
<blockquote>
<p>If the type is present, all constants take the type specified, and the expressions must be assignable to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal’s fractional part is zero.</p>
</blockquote>
<p>如果类型存在，则所有常量均采用指定的类型，并且表达式必须是可分配给该类型的，该类型不能是类型参数。<br/>
如果类型被省略，则常量采用相应表达式的各个类型。<br/>
如果表达式的值是无类型常量，则声明的常量保持无类型并且常量标识符表示了常量值。<br/>
例如，如果表达式是浮点字面量，则常量标识符表示了一个浮点字常量，即使字面量的小数部分为零。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const Pi float64 = 3.14159265358979323846</span></span>
<span class="line"><span style="color:#babed8">const zero = 0.0         // untyped floating-point constant</span></span>
<span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	size int64 = 1024</span></span>
<span class="line"><span style="color:#babed8">	eof        = -1  // untyped integer constant</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8">const a, b, c = 3, 4, &quot;foo&quot;  // a = 3, b = 4, c = &quot;foo&quot;, untyped integer and string constants</span></span>
<span class="line"><span style="color:#babed8">const u, v float32 = 0, 3    // u = 0.0, v = 3.0</span></span></code></pre>
<blockquote>
<p>Within a parenthesized const declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the iota constant generator this mechanism permits light-weight declaration of sequential values:</p>
</blockquote>
<p>在括号括起来的 <code>const</code> 声明列表中，除了第一个 <code>ConstSpec</code> 之外的任何表达式列表中都可以省略表达式列表。<br/>
这样的一个空列表相当于前面第一个非空表达式列表及其类型（如果有的话）的文本替换。<br/>
因此，省略表达式列表就相当于重复前面的列表。<br/>
标识符的数量必须与前面列表中的表达式的数量相同。<br/>
与 <code>iota</code> 常量生成器一起，该机制允许顺序值的轻量级声明：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	Sunday = iota</span></span>
<span class="line"><span style="color:#babed8">	Monday</span></span>
<span class="line"><span style="color:#babed8">	Tuesday</span></span>
<span class="line"><span style="color:#babed8">	Wednesday</span></span>
<span class="line"><span style="color:#babed8">	Thursday</span></span>
<span class="line"><span style="color:#babed8">	Friday</span></span>
<span class="line"><span style="color:#babed8">	Partyday</span></span>
<span class="line"><span style="color:#babed8">	numberOfDays  // this constant is not exported</span></span>
<span class="line"><span style="color:#babed8">)</span></span></code></pre>
<h3 id="iota-枚举">Iota 枚举</h3>
<blockquote>
<p>Within a constant declaration, the predeclared identifier iota represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:</p>
</blockquote>
<p>在常量声明中，预声明的标识符 <code>iota</code> 代表连续的无类型整型常量。<br/>
它的值是该常量声明中相应的 <code>ConstSpec</code> 的索引，从零开始。<br/>
它可用于构造一组相关常量：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	c0 = iota  // c0 == 0</span></span>
<span class="line"><span style="color:#babed8">	c1 = iota  // c1 == 1</span></span>
<span class="line"><span style="color:#babed8">	c2 = iota  // c2 == 2</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	a = 1 &lt;&lt; iota  // a == 1  (iota == 0)</span></span>
<span class="line"><span style="color:#babed8">	b = 1 &lt;&lt; iota  // b == 2  (iota == 1)</span></span>
<span class="line"><span style="color:#babed8">	c = 3          // c == 3  (iota == 2, unused)</span></span>
<span class="line"><span style="color:#babed8">	d = 1 &lt;&lt; iota  // d == 8  (iota == 3)</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	u         = iota * 42  // u == 0     (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">	v float64 = iota * 42  // v == 42.0  (float64 constant)</span></span>
<span class="line"><span style="color:#babed8">	w         = iota * 42  // w == 84    (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">const x = iota  // x == 0</span></span>
<span class="line"><span style="color:#babed8">const y = iota  // y == 0</span></span></code></pre>
<blockquote>
<p>By definition, multiple uses of iota in the same ConstSpec all have the same value:</p>
</blockquote>
<p>按照定义，在同一个 <code>ConstSpec</code> 中多次使用 <code>iota</code> 都具有相同的值：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)</span></span>
<span class="line"><span style="color:#babed8">	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)</span></span>
<span class="line"><span style="color:#babed8">	_, _                                  //                        (iota == 2, unused)</span></span>
<span class="line"><span style="color:#babed8">	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)</span></span>
<span class="line"><span style="color:#babed8">)</span></span></code></pre>
<blockquote>
<p>This last example exploits the implicit repetition of the last non-empty expression list.</p>
</blockquote>
<p>最后一个示例利用了最后一个非空表达式列表的隐式重复（的特点）。</p>
<h3 id="type-declarations-类型声明">Type declarations 类型声明</h3>
<blockquote>
<p>A type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.</p>
</blockquote>
<p>类型声明将标识符（类型名称）绑定到类型上。<br/>
类型声明有两种形式：别名声明和类型定义。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">TypeDecl = &quot;type&quot; ( TypeSpec | &quot;(&quot; { TypeSpec &quot;;&quot; } &quot;)&quot; ) .</span></span>
<span class="line"><span style="color:#babed8">TypeSpec = AliasDecl | TypeDef .</span></span></code></pre>
<h4 id="alias-declarations-别名声明">Alias declarations 别名声明</h4>
<blockquote>
<p>An alias declaration binds an identifier to the given type.</p>
</blockquote>
<p>别名声明将标识符绑定到给定类型上。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">AliasDecl = identifier &quot;=&quot; Type .</span></span></code></pre>
<blockquote>
<p>Within the scope of the identifier, it serves as an alias for the type.</p>
</blockquote>
<p>在标识符的作用域内，它充当了类型的别名。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type (</span></span>
<span class="line"><span style="color:#babed8">	nodeList = []*Node  // nodeList and []*Node are identical types</span></span>
<span class="line"><span style="color:#babed8">	Polar    = polar    // Polar and polar denote identical types</span></span>
<span class="line"><span style="color:#babed8">)</span></span></code></pre>
<h4 id="type-definitions-类型定义">Type definitions 类型定义</h4>
<blockquote>
<p>A type definition creates a new, distinct type with the same underlying type and operations as the given type and binds an identifier, the type name, to it.</p>
</blockquote>
<p>类型定义创建了一个新的、不同的类型，这个类型具有与给定类型相同的底层类型和操作，并将标识符（类型名称）绑定到它上。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">TypeDef = identifier [ TypeParameters ] Type .</span></span></code></pre>
<blockquote>
<p>The new type is called a defined type. It is different from any other type, including the type it is created from.</p>
</blockquote>
<p>新类型称为已定义类型。它不同于任何其他类型，包括与创建它的类型也不同。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type (</span></span>
<span class="line"><span style="color:#babed8">	Point struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types</span></span>
<span class="line"><span style="color:#babed8">	polar Point                   // polar and Point denote different types</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type TreeNode struct {</span></span>
<span class="line"><span style="color:#babed8">	left, right *TreeNode</span></span>
<span class="line"><span style="color:#babed8">	value any</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type Block interface {</span></span>
<span class="line"><span style="color:#babed8">	BlockSize() int</span></span>
<span class="line"><span style="color:#babed8">	Encrypt(src, dst []byte)</span></span>
<span class="line"><span style="color:#babed8">	Decrypt(src, dst []byte)</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:</p>
</blockquote>
<p>已定义的类型可以具有与之相关联的方法。<br/>
它不继承任何绑定到给定类型上的方法，但接口类型或组合类型元素的方法集保持不变：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// A Mutex is a data type with two methods, Lock and Unlock.</span></span>
<span class="line"><span style="color:#babed8">type Mutex struct         { /* Mutex fields */ }</span></span>
<span class="line"><span style="color:#babed8">func (m *Mutex) Lock()    { /* Lock implementation */ }</span></span>
<span class="line"><span style="color:#babed8">func (m *Mutex) Unlock()  { /* Unlock implementation */ }</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// NewMutex has the same composition as Mutex but its method set is empty.</span></span>
<span class="line"><span style="color:#babed8">type NewMutex Mutex</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// The method set of PtrMutex&#39;s underlying type *Mutex remains unchanged,</span></span>
<span class="line"><span style="color:#babed8">// but the method set of PtrMutex is empty.</span></span>
<span class="line"><span style="color:#babed8">type PtrMutex *Mutex</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// The method set of *PrintableMutex contains the methods</span></span>
<span class="line"><span style="color:#babed8">// Lock and Unlock bound to its embedded field Mutex.</span></span>
<span class="line"><span style="color:#babed8">type PrintableMutex struct {</span></span>
<span class="line"><span style="color:#babed8">	Mutex</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// MyBlock is an interface type that has the same method set as Block.</span></span>
<span class="line"><span style="color:#babed8">type MyBlock Block</span></span></code></pre>
<blockquote>
<p>Type definitions may be used to define different boolean, numeric, or string types and associate methods with them:</p>
</blockquote>
<p>类型定义可用于定义不同的布尔、数字或字符串类型，并将方法与它们关联：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type TimeZone int</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">const (</span></span>
<span class="line"><span style="color:#babed8">	EST TimeZone = -(5 + iota)</span></span>
<span class="line"><span style="color:#babed8">	CST</span></span>
<span class="line"><span style="color:#babed8">	MST</span></span>
<span class="line"><span style="color:#babed8">	PST</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (tz TimeZone) String() string {</span></span>
<span class="line"><span style="color:#babed8">	return fmt.Sprintf(&quot;GMT%+dh&quot;, tz)</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>If the type definition specifies type parameters, the type name denotes a generic type. Generic types must be instantiated when they are used.</p>
</blockquote>
<p>如果类型定义指定了类型参数，则类型名称标识了一个泛型类型。<br/>
泛型类型在使用时必须实例化。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type List[T any] struct {</span></span>
<span class="line"><span style="color:#babed8">	next  *List[T]</span></span>
<span class="line"><span style="color:#babed8">	value T</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>In a type definition the given type cannot be a type parameter.</p>
</blockquote>
<p>在类型定义中，给定的类型不能是类型参数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T[P any] P    // illegal: P is a type parameter</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func f[T any]() {</span></span>
<span class="line"><span style="color:#babed8">	type L T   // illegal: T is a type parameter declared by the enclosing function</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A generic type may also have methods associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.</p>
</blockquote>
<p>泛型类型也可能具有与之关联的方法。<br/>
在这种情况下，方法接收者必须声明与泛型类型定义中现有的相同个数个的类型参数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// The method Len returns the number of elements in the linked list l.</span></span>
<span class="line"><span style="color:#babed8">func (l *List[T]) Len() int  { … }</span></span></code></pre>
<h3 id="type-parameter-declarations-类型参数声明">Type parameter declarations 类型参数声明</h3>
<blockquote>
<p>A type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses.</p>
</blockquote>
<p>类型参数列表声明了泛型函数或类型声明的类型参数。<br/>
类型参数列表看起来像一个普通的函数参数列表，只是（区别在于）类型参数名称必须全部是存在的并且列表要用方括号而不是圆括号括起来。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">TypeParameters  = &quot;[&quot; TypeParamList [ &quot;,&quot; ] &quot;]&quot; .</span></span>
<span class="line"><span style="color:#babed8">TypeParamList   = TypeParamDecl { &quot;,&quot; TypeParamDecl } .</span></span>
<span class="line"><span style="color:#babed8">TypeParamDecl   = IdentifierList TypeConstraint .</span></span></code></pre>
<blockquote>
<p>All non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a place holder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type.</p>
</blockquote>
<p>列表中的所有非空白名称必须是唯一的。<br/>
每个名称都声明了一个类型参数，它是一个新的、不同的命名类型，用来充当声明中（截至此处）未知类型的占位符。<br/>
在泛型函数或类型的实例化时，类型形参将会被替换为类型实参。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">[P any]</span></span>
<span class="line"><span style="color:#babed8">[S interface{ ~[]byte|string }]</span></span>
<span class="line"><span style="color:#babed8">[S ~[]E, E any]</span></span>
<span class="line"><span style="color:#babed8">[P Constraint[int]]</span></span>
<span class="line"><span style="color:#babed8">[_ any]</span></span></code></pre>
<blockquote>
<p>Just as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its type constraint.</p>
</blockquote>
<p>正如每个普通函数参数都有一个参数类型一样，每个类型参数都有一个相应的（元）类型，称为类型约束。</p>
<blockquote>
<p>A parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter P with a constraint C such that the text P C forms a valid expression:</p>
</blockquote>
<p>当泛型类型的类型参数列表声明了带有约束 C 的单个类型参数 P 以使文本 P 和 C 形成有效的表达式时，就会出现解析歧义：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T[P *C] …</span></span>
<span class="line"><span style="color:#babed8">type T[P (C)] …</span></span>
<span class="line"><span style="color:#babed8">type T[P *C|Q] …</span></span>
<span class="line"><span style="color:#babed8">…</span></span></code></pre>
<blockquote>
<p>In these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an interface or use a trailing comma:</p>
</blockquote>
<p>在这些罕见情形下，类型参数列表与表达式是无法区分的，并且类型声明会被解析为数组类型声明。<br/>
要消除这种歧义，需要将约束嵌入到接口中，或在结尾加上逗号：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T[P interface{*C}] …</span></span>
<span class="line"><span style="color:#babed8">type T[P *C,] …</span></span></code></pre>
<blockquote>
<p>Type parameters may also be declared by the receiver specification of a method declaration associated with a generic type.</p>
</blockquote>
<p>类型参数也可以由与泛型类型相关联的方法声明的接收者规范来声明。</p>
<blockquote>
<p>Within a type parameter list of a generic type T, a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to T.</p>
</blockquote>
<p>在泛型类型 T 的类型参数列表中，类型约束不能（直接地或间接地通过另一个泛型类型的类型参数列表来）引用 T 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T1[P T1[P]] …                    // illegal: T1 refers to itself</span></span>
<span class="line"><span style="color:#babed8">type T2[P interface{ T2[int] }] …     // illegal: T2 refers to itself</span></span>
<span class="line"><span style="color:#babed8">type T3[P interface{ m(T3[int])}] …   // illegal: T3 refers to itself</span></span>
<span class="line"><span style="color:#babed8">type T4[P T5[P]] …                    // illegal: T4 refers to T5 and</span></span>
<span class="line"><span style="color:#babed8">type T5[P T4[P]] …                    //          T5 refers to T4</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type T6[P int] struct{ f *T6[P] }     // ok: reference to T6 is not in type parameter list</span></span></code></pre>
<h4 id="type-constraints-类型约束">Type constraints 类型约束</h4>
<blockquote>
<p>A type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter.</p>
</blockquote>
<p>类型约束是一个接口，它定义了相应类型参数所允许的类型参数的集合，并控制该类型参数的值支持哪些操作。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">TypeConstraint = TypeElem .</span></span></code></pre>
<blockquote>
<p>If the constraint is an interface literal of the form <code>interface{E}</code> where E is an embedded type element (not a method), in a type parameter list the enclosing <code>interface{ … }</code> may be omitted for convenience:</p>
</blockquote>
<p>如果约束是 <code>interface{E}</code> 形式的接口字面量，其中 E 是嵌入类型元素（不是方法），则在类型参数列表中的闭合的 <code>interface{ … }</code> 为了方便可以省略掉：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">[T []P]                      // = [T interface{[]P}]</span></span>
<span class="line"><span style="color:#babed8">[T ~int]                     // = [T interface{~int}]</span></span>
<span class="line"><span style="color:#babed8">[T int|string]               // = [T interface{int|string}]</span></span>
<span class="line"><span style="color:#babed8">type Constraint ~int         // illegal: ~int is not in a type parameter list</span></span></code></pre>
<blockquote>
<p>The predeclared interface type comparable denotes the set of all non-interface types that are strictly comparable.</p>
</blockquote>
<p>预声明的接口类型 <code>comparable</code> 表示严格可比较的所有非接口类型的集合。</p>
<blockquote>
<p>Even though interfaces that are not type parameters are comparable, they are not strictly comparable and therefore they do not implement comparable. However, they satisfy comparable.</p>
</blockquote>
<p>尽管不是类型参数的接口也是可比较的，但它们并非严格可比较，因此它们并未实现 <code>comparable</code> 。不过，它们还是能满足 <code>comparable</code> 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">int                          // implements comparable (int is strictly comparable)</span></span>
<span class="line"><span style="color:#babed8">[]byte                       // does not implement comparable (slices cannot be compared)</span></span>
<span class="line"><span style="color:#babed8">interface{}                  // does not implement comparable (see above)</span></span>
<span class="line"><span style="color:#babed8">interface{ ~int | ~string }  // type parameter only: implements comparable (int, string types are stricly comparable)</span></span>
<span class="line"><span style="color:#babed8">interface{ comparable }      // type parameter only: implements comparable (comparable implements itself)</span></span>
<span class="line"><span style="color:#babed8">interface{ ~int | ~[]byte }  // type parameter only: does not implement comparable (slices are not comparable)</span></span>
<span class="line"><span style="color:#babed8">interface{ ~struct{ any } }  // type parameter only: does not implement comparable (field any is not strictly comparable)</span></span></code></pre>
<blockquote>
<p>The comparable interface and interfaces that (directly or indirectly) embed comparable may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.</p>
</blockquote>
<p><code>comparable</code> 接口和（直接或间接地）嵌入 <code>comparable</code> 的接口只能用作类型约束。<br/>
它们不能是值的类型或变量的类型，也不能是其他非接口类型的一部分。</p>
<h4 id="satisfying-a-type-constraint-满足类型约束">Satisfying a type constraint 满足类型约束</h4>
<blockquote>
<p>A type argument T satisfies a type constraint C if T is an element of the type set defined by C; i.e., if T implements C. As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument. More precisely:</p>
</blockquote>
<p>如果类型实参 T 是约束 C 定义的类型集的元素，则类型参数 T 满足类型约束 C ；也就是说，如果 T 实现了 C 的话。<br/>
例外的，严格可比较类型约束也可以由可比较（不一定是严格可比较）的类型参数来满足。<br/>
更确切地说：</p>
<blockquote>
<p>A type T satisfies a constraint C if</p>
</blockquote>
<p>如果（满足以下条件，那么）类型 T 就满足约束 C ：</p>
<blockquote>
<ul>
<li>T implements C; or</li>
</ul>
</blockquote>
<p>T 实现了 C；或者</p>
<blockquote>
<ul>
<li>C can be written in the form <code>interface{ comparable; E }</code>, where E is a basic interface and T is comparable and implements E.</li>
</ul>
</blockquote>
<p>C 可以写成 <code>interface{ comparable; E }</code> 的形式，其中 E 是一个基本接口，且 T 是可比较的、实现了 E 的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type argument      type constraint                // constraint satisfaction</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">int                interface{ ~int }              // satisfied: int implements interface{ ~int }</span></span>
<span class="line"><span style="color:#babed8">string             comparable                     // satisfied: string implements comparable (string is stricty comparable)</span></span>
<span class="line"><span style="color:#babed8">[]byte             comparable                     // not satisfied: slices are not comparable</span></span>
<span class="line"><span style="color:#babed8">any                interface{ comparable; int }   // not satisfied: any does not implement interface{ int }</span></span>
<span class="line"><span style="color:#babed8">any                comparable                     // satisfied: any is comparable and implements the basic interface any</span></span>
<span class="line"><span style="color:#babed8">struct{f any}      comparable                     // satisfied: struct{f any} is comparable and implements the basic interface any</span></span>
<span class="line"><span style="color:#babed8">any                interface{ comparable; m() }   // not satisfied: any does not implement the basic interface interface{ m() }</span></span>
<span class="line"><span style="color:#babed8">interface{ m() }   interface{ comparable; m() }   // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }</span></span></code></pre>
<blockquote>
<p>Because of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).</p>
</blockquote>
<p>因为约束满足规则中的例外，将类型参数类型的操作数进行比较，可能会引发运行时 panic （即使可比较的类型参数始终是严格可比较的）。</p>
<h3 id="variable-declarations-变量声明">Variable declarations 变量声明</h3>
<blockquote>
<p>A variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.</p>
</blockquote>
<p>变量声明创建一个或多个变量，将相应的标识符绑定到变量上，并为每个变量赋予一个类型和一个初始值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">VarDecl     = &quot;var&quot; ( VarSpec | &quot;(&quot; { VarSpec &quot;;&quot; } &quot;)&quot; ) .</span></span>
<span class="line"><span style="color:#babed8">VarSpec     = IdentifierList ( Type [ &quot;=&quot; ExpressionList ] | &quot;=&quot; ExpressionList ) .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> i </span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> U</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> V</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> W </span><span style="color:#C792EA">float64</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> k </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> x</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y </span><span style="color:#C792EA">float32</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">2</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span></span>
<span class="line"><span style="color:#BABED8">	i       </span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#BABED8">	u</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> v</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> s </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">2.0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3.0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">bar</span><span style="color:#89DDFF">&quot;</span></span>
<span class="line"><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> re</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> im </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">complexSqrt</span><span style="color:#89DDFF">(-</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> _</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> found </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> entries</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">name</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// map lookup; only interested in &quot;found&quot;</span></span></code></pre>
<blockquote>
<p>If a list of expressions is given, the variables are initialized with the expressions following the rules for assignment statements. Otherwise, each variable is initialized to its zero value.</p>
</blockquote>
<p>如果给出了表达式列表，则变量将按照赋值语句的规则来初始化表达式。<br/>
否则，每个变量都将被初始化为它的零值。</p>
<blockquote>
<p>If a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type bool. The predeclared value nil cannot be used to initialize a variable with no explicit type.</p>
</blockquote>
<p>如果类型存在，则每个变量都会被赋这个类型。
否则，每个变量都会在赋值中被赋相应初始化值的类型。<br/>
如果该值是无类型常量，则首先将其隐式转换为其默认类型；<br/>
如果它是无类型布尔值，则首先将其隐式转换为 bool 类型。<br/>
预声明的值 nil 不能用于初始化一个没有显式类型的变量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> d </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> math</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Sin</span><span style="color:#89DDFF">(</span><span style="color:#F78C6C">0.5</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// d is float64</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> i </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">42</span><span style="color:#BABED8">             </span><span style="color:#676E95;font-style:italic">// i is int</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> t</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> ok </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> x</span><span style="color:#89DDFF">.(</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">      </span><span style="color:#676E95;font-style:italic">// t is T, ok is bool</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> n </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">nil</span><span style="color:#BABED8">            </span><span style="color:#676E95;font-style:italic">// illegal</span></span></code></pre>
<blockquote>
<p>Implementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.</p>
</blockquote>
<p>实现限制：如果一个变量从未被使用过，则编译器可能会认为在函数体中声明这个变量是非法的。</p>
<h3 id="short-variable-declarations-短变量声明">Short variable declarations 短变量声明</h3>
<blockquote>
<p>A short variable declaration uses the syntax:</p>
</blockquote>
<p>短变量声明使用以下语法：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ShortVarDecl = IdentifierList &quot;:=&quot; ExpressionList .</span></span></code></pre>
<blockquote>
<p>It is shorthand for a regular variable declaration with initializer expressions but no types:</p>
</blockquote>
<p>它是对一个带有初始化表达式但没有类型的常规变量声明的简写：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">&quot;var&quot; IdentifierList &quot;=&quot; ExpressionList .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">i</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> j </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">10</span></span>
<span class="line"><span style="color:#BABED8">f </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func()</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF;font-style:italic">return</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">7</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">ch </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">make</span><span style="color:#89DDFF">(chan</span><span style="color:#BABED8"> </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">r</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> w</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> _ </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> os</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Pipe</span><span style="color:#89DDFF">()</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// os.Pipe() returns a connected pair of Files and an error, if any</span></span>
<span class="line"><span style="color:#BABED8">_</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> _ </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">coord</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">p</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">   </span><span style="color:#676E95;font-style:italic">// coord() returns three values; only interested in y coordinate</span></span></code></pre>
<blockquote>
<p>Unlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of := must be unique.</p>
</blockquote>
<p>与常规变量声明不同，短变量声明可以重声明变量，前提是重声明的变量最初在同一个块（如果该块是函数体，则指的是在同一个参数列表）中先前用相同类型声明，并且至少有一个非空变量是新的。<br/>
因此，重声明只能出现在多变量的短声明中。<br/>
重声明不会引入新变量；它只是为原始值分配一个新值。<br/>
<code>:=</code> 左侧的非空白变量名称必须是唯一的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">field1, offset := nextField(str, 0)</span></span>
<span class="line"><span style="color:#babed8">field2, offset := nextField(str, offset)  // redeclares offset</span></span>
<span class="line"><span style="color:#babed8">x, y, x := 1, 2, 3                        // illegal: x repeated on left side of :=</span></span></code></pre>
<blockquote>
<p>Short variable declarations may appear only inside functions. In some contexts such as the initializers for “if”, “for”, or “switch” statements, they can be used to declare local temporary variables.</p>
</blockquote>
<p>短变量声明只能出现在函数内部。<br/>
在某些上下文例如”if”、“for”或”switch”语句里的初始化中，短变量可用于声明局部的临时变量。</p>
<h3 id="function-declarations-函数声明">Function declarations 函数声明</h3>
<blockquote>
<p>A function declaration binds an identifier, the function name, to a function.</p>
</blockquote>
<p>函数声明将标识符即函数名称绑定到函数上。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">FunctionDecl = &quot;func&quot; FunctionName [ TypeParameters ] Signature [ FunctionBody ] .</span></span>
<span class="line"><span style="color:#babed8">FunctionName = identifier .</span></span>
<span class="line"><span style="color:#babed8">FunctionBody = Block .</span></span></code></pre>
<blockquote>
<p>If the function’s signature declares result parameters, the function body’s statement list must end in a terminating statement.</p>
</blockquote>
<p>如果函数的签名声明了结果参数，则函数体的语句列表必须以终止语句结束。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func IndexRune(s string, r rune) int {</span></span>
<span class="line"><span style="color:#babed8">	for i, c := range s {</span></span>
<span class="line"><span style="color:#babed8">		if c == r {</span></span>
<span class="line"><span style="color:#babed8">			return i</span></span>
<span class="line"><span style="color:#babed8">		}</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">	// invalid: missing return statement</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>If the function declaration specifies type parameters, the function name denotes a generic function. A generic function must be instantiated before it can be called or used as a value.</p>
</blockquote>
<p>如果函数声明指定了类型参数，则该函数名标识了一个泛型函数。<br/>
泛型函数必须先被实例化，然后才能被调用或作为值来使用。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func min[T ~int|~float64](x, y T) T {</span></span>
<span class="line"><span style="color:#babed8">	if x &lt; y {</span></span>
<span class="line"><span style="color:#babed8">		return x</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">	return y</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.</p>
</blockquote>
<p>没有类型参数的函数声明可以省略函数体。这样的声明提供了在 Go 外部实现的函数的签名，例如（下面的）一个汇编例程。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func flushICache(begin, end uintptr)  // implemented externally</span></span></code></pre>
<h3 id="method-declarations-方法声明">Method declarations 方法声明</h3>
<blockquote>
<p>A method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver’s base type.</p>
</blockquote>
<p>方法是带有接收器的函数。<br/>
方法声明将方法名称这样一个标识符绑定到方法上，并将该方法与接收者的基础类型相关联。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">MethodDecl = &quot;func&quot; Receiver MethodName Signature [ FunctionBody ] .</span></span>
<span class="line"><span style="color:#babed8">Receiver   = Parameters .</span></span></code></pre>
<blockquote>
<p>The receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type T or a pointer to a defined type T, possibly followed by a list of type parameter names [P1, P2, …] enclosed in square brackets. T is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type T or *T.</p>
</blockquote>
<p>接收者是通过方法名称前面的一个额外参数部分指定的。<br/>
该参数部分必须声明一个不可变参数，即接收者。<br/>
接收者的类型必须是已定义类型 T 或指向已定义类型 T 的指针，后面可能是括在方括号中的类型参数名称列表 [P1, P2, …] 。<br/>
T 称为接收者基本类型。<br/>
接收者基本类型不能是指针或接口类型，并且必须与方法在同一个包中定义。<br/>
也就是说该方法绑定到其接收者的基类型，并且方法名称只在类型 T 或 *T 的选择器中是可见的。</p>
<blockquote>
<p>A non-blank receiver identifier must be unique in the method signature. If the receiver’s value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.</p>
</blockquote>
<p>非空白接收者的标识符在方法签名中必须是唯一的。<br/>
如果方法体内没有引用接收者的值，则声明中可以省略其标识符。<br/>
这对函数和方法的参数也同样适用。</p>
<blockquote>
<p>For a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.</p>
</blockquote>
<p>对于一个基础类型，绑定到它的方法的非空名称必须是唯一的。<br/>
如果基础类型是结构体类型，则非空方法和字段名必须不同。</p>
<blockquote>
<p>Given defined type Point the declarations</p>
</blockquote>
<p>给定（如下）已定义类型 Point 的声明</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func (p *Point) Length() float64 {</span></span>
<span class="line"><span style="color:#babed8">	return math.Sqrt(p.x * p.x + p.y * p.y)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (p *Point) Scale(factor float64) {</span></span>
<span class="line"><span style="color:#babed8">	p.x *= factor</span></span>
<span class="line"><span style="color:#babed8">	p.y *= factor</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>bind the methods Length and Scale, with receiver type *Point, to the base type Point.</p>
</blockquote>
<p>将方法 Length() 和 Scale() 与接收者类型 *Point 绑定到基本类型 Point 。</p>
<blockquote>
<p>If the receiver base type is a generic type, the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an instantiation of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.</p>
</blockquote>
<p>如果接收者基础类型是泛型类型，则接收者的规范必须为要使用的方法声明相应的类型参数。<br/>
这使得接收者类型参数可供该方法使用。<br/>
从语法上看，此类型参数声明看起来像接收者基础类型的实例化：类型参数必须是表示所声明的类型参数的标识符，一个对应于接收者基础类型的每个类型参数。<br/>
类型参数名称不需要与接收者基础类型定义中相应的参数名称相匹配，且所有的非空白参数名称在接收者参数部分和方法签名中必须是唯一的。<br/>
接收者类型参数约束隐含在接收者基本类型定义中：相应的类型参数具有相应的约束。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type Pair[A, B any] struct {</span></span>
<span class="line"><span style="color:#babed8">	a A</span></span>
<span class="line"><span style="color:#babed8">	b B</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (p Pair[A, B]) Swap() Pair[B, A]  { … }  // receiver declares A, B</span></span>
<span class="line"><span style="color:#babed8">func (p Pair[First, _]) First() First  { … }  // receiver declares First, corresponds to A in Pair</span></span></code></pre>
<h2 id="expressions-表达式">Expressions 表达式</h2>
<blockquote>
<p>An expression specifies the computation of a value by applying operators and functions to operands.</p>
</blockquote>
<p>一个表达式通过将运算符和函数应用于操作数来确定一个值（如何）计算。</p>
<h3 id="operands-操作数">Operands 操作数</h3>
<blockquote>
<p>Operands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.</p>
</blockquote>
<p>操作数标识了表达式中的基本的值。<br/>
操作数可以是一个字面量，或者一个用于表示常量、或变量、或函数的(可能是被限定的)非空标识符，或者一个括号表达式。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">Operand     </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> Literal </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> OperandName </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> TypeArgs </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">(</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> Expression </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">)</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">Literal     </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> BasicLit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> CompositeLit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> FunctionLit </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">BasicLit    </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> int_lit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> float_lit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> imaginary_lit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> rune_lit </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> string_lit </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">OperandName </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> identifier </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> QualifiedIdent </span><span style="color:#89DDFF">.</span></span></code></pre>
<blockquote>
<p>An operand name denoting a generic function may be followed by a list of type arguments; the resulting operand is an instantiated function.</p>
</blockquote>
<p>标识了一个泛型函数的操作数名，后面可以跟一列类型参数；<br/>
生成的操作数是一个实例化的函数。</p>
<blockquote>
<p>The blank identifier may appear as an operand only on the left-hand side of an assignment statement.</p>
</blockquote>
<p>空白标识符只能作为操作数出现在赋值语句的左侧。</p>
<blockquote>
<p>Implementation restriction: A compiler need not report an error if an operand’s type is a type parameter with an empty type set. Functions with such type parameters cannot be instantiated; any attempt will lead to an error at the instantiation site.</p>
</blockquote>
<p>实现限制：<br/>
如果操作数的类型是具有空类型集的类型参数，则编译器不需要报告错误。<br/>
具有这种类型参数的函数无法实例化；<br/>
任何尝试都会导致实例化处出现错误。</p>
<h3 id="qualified-identifiers-限定标识符">Qualified identifiers 限定标识符</h3>
<blockquote>
<p>A qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.</p>
</blockquote>
<p>限定标识符是用包名为前缀作限定的标识符。<br/>
包名和标识符都不可以为空。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">QualifiedIdent </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> PackageName </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">.</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> identifier </span><span style="color:#89DDFF">.</span></span></code></pre>
<blockquote>
<p>A qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.</p>
</blockquote>
<p>限定标识符访问不同包中的标识符，标识符必须是已导入的。<br/>
标识符必须被导出并在该包的包块中声明。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">math</span><span style="color:#89DDFF">.</span><span style="color:#BABED8">Sin </span><span style="color:#676E95;font-style:italic">// denotes the Sin function in package math</span></span></code></pre>
<h3 id="composite-literals-组合字面量">Composite literals 组合字面量</h3>
<blockquote>
<p>Composite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.</p>
</blockquote>
<p>每次计算组合字面量时，组合字面量都会构造新的组合值。<br/>
组合字面量由一个后面跟着花括号包括的元素列表的字面量的类型组成。<br/>
每个元素可以选择性地在前面加上一个对应的键。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">CompositeLit  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> LiteralType LiteralValue </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">LiteralType   </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> StructType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> ArrayType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">[</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">...</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">]</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> ElementType </span><span style="color:#89DDFF">|</span></span>
<span class="line"><span style="color:#BABED8">                SliceType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> MapType </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> TypeName </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> TypeArgs </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">LiteralValue  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">{</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> ElementList </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">,</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">}</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">ElementList   </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> KeyedElement </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">,</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> KeyedElement </span><span style="color:#89DDFF">}</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">KeyedElement  </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#BABED8"> Key </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">:</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> Element </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">Key           </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> FieldName </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> Expression </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> LiteralValue </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">FieldName     </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> identifier </span><span style="color:#89DDFF">.</span></span>
<span class="line"><span style="color:#BABED8">Element       </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> Expression </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> LiteralValue </span><span style="color:#89DDFF">.</span></span></code></pre>
<blockquote>
<p>The LiteralType’s core type T must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of type T; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.</p>
</blockquote>
<p>字面量类型的核心类型 T 必须是结构体、数组、切片或 map 类型（语法强制执行此约束，除非类型是以 TypeName 形式给出的）。<br/>
元素和键的类型必须可分配给 T 类型的相应字段、元素和键类型；不会有额外的转换。<br/>
这个键被解释为结构体字面量的字段名，或数组和切片字面量的索引，或 map 字面量的键。<br/>
对于 map 字面量，所有元素都必须有一个键。<br/>
指定具有相同字段名称或常量键值的多个元素（的做法）是错误的。<br/>
对于非常量 map 的键，请参阅有关计算顺序的部分。</p>
<blockquote>
<p>For struct literals the following rules apply:</p>
</blockquote>
<p>对于结构体字面量，适用以下规则：</p>
<blockquote>
<ul>
<li>A key must be a field name declared in the struct type.</li>
</ul>
</blockquote>
<p>键必须是在结构体类型中声明的字段名。</p>
<blockquote>
<ul>
<li>An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.</li>
</ul>
</blockquote>
<p>不包含任何键的元素列表，必须按照声明字段的顺序列出每个结构体字段的元素。</p>
<blockquote>
<ul>
<li>If any element has a key, every element must have a key.</li>
</ul>
</blockquote>
<p>如果任意元素都有一个键，那么每个元素都必须有一个键。</p>
<blockquote>
<ul>
<li>An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.</li>
</ul>
</blockquote>
<p>包含键的元素列表不需要每个结构体字段都有一个元素。省略的字段会获得该字段的零值。</p>
<blockquote>
<ul>
<li>A literal may omit the element list; such a literal evaluates to the zero value for its type.</li>
</ul>
</blockquote>
<p>字面量可以省略元素列表；这种字面量的计算结果是其类型的零值。</p>
<blockquote>
<ul>
<li>It is an error to specify an element for a non-exported field of a struct belonging to a different package.</li>
</ul>
</blockquote>
<p>为属于不同包的结构体的非导出字段指定元素（的做法）是错误的。</p>
<blockquote>
<p>Given the declarations</p>
</blockquote>
<p>给定以下声明</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Point3D</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> x</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> y</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> z </span><span style="color:#C792EA">float64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Line</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">struct</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> p</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> q Point3D </span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>one may write</p>
</blockquote>
<p>也可以写成这样：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">origin </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> Point3D</span><span style="color:#89DDFF">{}</span><span style="color:#BABED8">                            </span><span style="color:#676E95;font-style:italic">// zero value for Point3D</span></span>
<span class="line"><span style="color:#BABED8">line </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> Line</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">origin</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> Point3D</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">y</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">4</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> z</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">12.3</span><span style="color:#89DDFF">}}</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// zero value for line.q.x</span></span></code></pre>
<blockquote>
<p>For array and slice literals the following rules apply:</p>
</blockquote>
<p>对于数组和切片字面量，适用以下规则：</p>
<blockquote>
<ul>
<li>Each element has an associated integer index marking its position in the array.</li>
</ul>
</blockquote>
<p>每个元素都有一个对应的整数索引，（用于）标记其在数组中的位置。</p>
<blockquote>
<ul>
<li>An element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type int; and if it is typed it must be of integer type.</li>
</ul>
</blockquote>
<p>带有键的元素，使用键作为它的索引。键必须是由 int 类型的值表示的非负常量；如果它是有类型的，那么它必须是整数类型。</p>
<blockquote>
<ul>
<li>An element without a key uses the previous element’s index plus one. If the first element has no key, its index is zero.</li>
</ul>
</blockquote>
<p>没有键的元素就使用前一个元素的索引加一。如果第一个元素没有键，则第一个元素的索引为零。</p>
<blockquote>
<p>Taking the address of a composite literal generates a pointer to a unique variable initialized with the literal’s value.</p>
</blockquote>
<p>获取组合字面量的地址会生成一个指向用该组合字面量的值初始化的唯一变量的指针。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> pointer </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">Point3D </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&amp;</span><span style="color:#BABED8">Point3D</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">y</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">1000</span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>Note that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.</p>
</blockquote>
<p>请注意，切片或 map 类型的零值与同一类型的已初始化但为空的值不同。<br/>
因此，获取空切片或 map 组合字面量的地址的效果，与使用 new 分配新切片或 map 值的效果并不相同。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">p1 </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&amp;[]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">{}</span><span style="color:#BABED8">    </span><span style="color:#676E95;font-style:italic">// p1 points to an initialized, empty slice with value []int{} and length 0</span></span>
<span class="line"><span style="color:#BABED8">p2 </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">new</span><span style="color:#89DDFF">([]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// p2 points to an uninitialized slice with value nil and length 0</span></span></code></pre>
<blockquote>
<p>The length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation … specifies an array length equal to the maximum element index plus one.</p>
</blockquote>
<p>数组字面量的长度是字面量类型中指定的长度。<br/>
如果字面量中提供的元素（个数）少于长度，则缺失的元素会被设置为数组元素类型的零值。<br/>
为元素提供越界索引（的做法）是错误的。<br/>
符号 <code>...</code> 指定的数组长度，等于最大的元素索引加一。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">buffer </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">{}</span><span style="color:#BABED8">             </span><span style="color:#676E95;font-style:italic">// len(buffer) == 10</span></span>
<span class="line"><span style="color:#BABED8">intSet </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">6</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">5</span><span style="color:#89DDFF">}</span><span style="color:#BABED8">       </span><span style="color:#676E95;font-style:italic">// len(intSet) == 6</span></span>
<span class="line"><span style="color:#BABED8">days </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[...]</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">{</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">Sat</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">Sun</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">}</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// len(days) == 2</span></span></code></pre>
<blockquote>
<p>A slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form</p>
</blockquote>
<p>切片字面量描述了整个底层数组字面量。<br/>
因此，切片字面量的长度和容量是最大的元素索引加一。<br/>
切片字面量具有以下形式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">[]</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">x1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> x2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> … xn</span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>and is shorthand for a slice operation applied to an array:</p>
</blockquote>
<p>是应用于数组的切片操作的简写：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">tmp </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#BABED8">n</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">x1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> x2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> … xn</span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#BABED8">tmp</span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">0</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> n</span><span style="color:#89DDFF">]</span></span></code></pre>
<blockquote>
<p>Within a composite literal of array, slice, or map type T, elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of T. Similarly, elements or keys that are addresses of composite literals may elide the &amp;T when the element or key type is *T.</p>
</blockquote>
<p>在数组、切片或 map 类型 T 的组合字面量中，本身就是组合字面量的元素或 map 键可能会省略相应的字面量类型（如果它与对应元素或 T 类型的 key 相同时）<br/>
类似的，当作为组合字面量的地址的元素或键为 <code>*T</code> 时，元素或键可能会省略 <code>&amp;T</code> 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">[...]</span><span style="color:#BABED8">Point</span><span style="color:#89DDFF">{{</span><span style="color:#F78C6C">1.5</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">3.5</span><span style="color:#89DDFF">},</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">}}</span><span style="color:#BABED8">     </span><span style="color:#676E95;font-style:italic">// same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}</span></span>
<span class="line"><span style="color:#89DDFF">[][]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">{{</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">},</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">4</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">5</span><span style="color:#89DDFF">}}</span><span style="color:#BABED8">          </span><span style="color:#676E95;font-style:italic">// same as [][]int{[]int{1, 2, 3}, []int{4, 5}}</span></span>
<span class="line"><span style="color:#89DDFF">[][]</span><span style="color:#BABED8">Point</span><span style="color:#89DDFF">{{{</span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">},</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">}}}</span><span style="color:#BABED8">         </span><span style="color:#676E95;font-style:italic">// same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}</span></span>
<span class="line"><span style="color:#89DDFF">map[</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">Point</span><span style="color:#89DDFF">{</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">orig</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">}}</span><span style="color:#BABED8">    </span><span style="color:#676E95;font-style:italic">// same as map[string]Point{&quot;orig&quot;: Point{0, 0}}</span></span>
<span class="line"><span style="color:#89DDFF">map[</span><span style="color:#BABED8">Point</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">{{</span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">}:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">orig</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">}</span><span style="color:#BABED8">    </span><span style="color:#676E95;font-style:italic">// same as map[Point]string{Point{0, 0}: &quot;orig&quot;}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">PPoint</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">*</span><span style="color:#BABED8">Point</span></span>
<span class="line"><span style="color:#89DDFF">[</span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">]*</span><span style="color:#BABED8">Point</span><span style="color:#89DDFF">{{</span><span style="color:#F78C6C">1.5</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">3.5</span><span style="color:#89DDFF">},</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{}}</span><span style="color:#BABED8">          </span><span style="color:#676E95;font-style:italic">// same as [2]*Point{&amp;Point{1.5, -3.5}, &amp;Point{}}</span></span>
<span class="line"><span style="color:#89DDFF">[</span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">PPoint</span><span style="color:#89DDFF">{{</span><span style="color:#F78C6C">1.5</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">3.5</span><span style="color:#89DDFF">},</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{}}</span><span style="color:#BABED8">          </span><span style="color:#676E95;font-style:italic">// same as [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}</span></span></code></pre>
<blockquote>
<p>A parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an “if”, “for”, or “switch” statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.</p>
</blockquote>
<p>当使用 LiteralType 的 TypeName 形式的组合字面量作为 “if”、“for”或”switch”语句块的关键字和左大括号之间的操作数时，会出现解析歧义，并且组合字面量不包含在圆括号、方括号或花括号中。<br/>
在这种罕见的情况下，字面量的左大括号被错误地解析为引入语句块的大括号。<br/>
为了解决歧义，组合字面量必须用括号括起来。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF;font-style:italic">if</span><span style="color:#BABED8"> x </span><span style="color:#89DDFF">==</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">T</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8">b</span><span style="color:#89DDFF">,</span><span style="color:#BABED8">c</span><span style="color:#89DDFF">}[</span><span style="color:#BABED8">i</span><span style="color:#89DDFF">])</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic">if</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">x </span><span style="color:#89DDFF">==</span><span style="color:#BABED8"> T</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">a</span><span style="color:#89DDFF">,</span><span style="color:#BABED8">b</span><span style="color:#89DDFF">,</span><span style="color:#BABED8">c</span><span style="color:#89DDFF">}[</span><span style="color:#BABED8">i</span><span style="color:#89DDFF">])</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span></code></pre>
<blockquote>
<p>Examples of valid array, slice, and map literals:</p>
</blockquote>
<p>（以下是）有效的数组、切片和 map 字面量的示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// list of prime numbers</span></span>
<span class="line"><span style="color:#BABED8">primes </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">5</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">7</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">9</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">2147483647</span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// vowels[ch] is true if ch is a vowel</span></span>
<span class="line"><span style="color:#BABED8">vowels </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">128</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">bool</span><span style="color:#89DDFF">{</span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">a</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">e</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">i</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">o</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">u</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&#39;</span><span style="color:#C3E88D">y</span><span style="color:#89DDFF">&#39;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">true}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}</span></span>
<span class="line"><span style="color:#BABED8">filter </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float32</span><span style="color:#89DDFF">{-</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">4</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">0.1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">0.1</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">9</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// frequencies in Hz for equal-tempered scale (A4 = 440Hz)</span></span>
<span class="line"><span style="color:#BABED8">noteFrequency </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">map[</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float32</span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">C0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">16.35</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">D0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">18.35</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">E0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">20.60</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">F0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">21.83</span><span style="color:#89DDFF">,</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">G0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">24.50</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">A0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">27.50</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">B0</span><span style="color:#89DDFF">&quot;</span><span style="color:#89DDFF">:</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">30.87</span><span style="color:#89DDFF">,</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<h3 id="function-literals-函数字面量">Function literals 函数字面量</h3>
<blockquote>
<p>A function literal represents an anonymous function. Function literals cannot declare type parameters.</p>
</blockquote>
<p>函数字面量表示一个匿名函数。函数字面量不能声明类型形参。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">FunctionLit = &quot;func&quot; Signature FunctionBody .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(a, b int, z float64) bool { return a*b &lt; int(z) }</span></span></code></pre>
<blockquote>
<p>A function literal can be assigned to a variable or invoked directly.</p>
</blockquote>
<p>一个函数字面量可以被赋值给一个变量或者被直接调用。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">f := func(x, y int) int { return x + y }</span></span>
<span class="line"><span style="color:#babed8">func(ch chan int) { ch &lt;- ACK }(replyChan)</span></span></code></pre>
<blockquote>
<p>Function literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.</p>
</blockquote>
<p>函数字面量是闭包：它们可以引用上下文函数中定义的变量。<br/>
这些变量在上下文函数和该函数字面量之间共享，并且只要变量一直存活，就是可访问的。</p>
<h3 id="primary-expressions-主表达式">Primary expressions 主表达式</h3>
<blockquote>
<p>Primary expressions are the operands for unary and binary expressions.</p>
</blockquote>
<p>主表达式是一元和二元表达式的操作数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">PrimaryExpr =</span></span>
<span class="line"><span style="color:#babed8">	Operand |</span></span>
<span class="line"><span style="color:#babed8">	Conversion |</span></span>
<span class="line"><span style="color:#babed8">	MethodExpr |</span></span>
<span class="line"><span style="color:#babed8">	PrimaryExpr Selector |</span></span>
<span class="line"><span style="color:#babed8">	PrimaryExpr Index |</span></span>
<span class="line"><span style="color:#babed8">	PrimaryExpr Slice |</span></span>
<span class="line"><span style="color:#babed8">	PrimaryExpr TypeAssertion |</span></span>
<span class="line"><span style="color:#babed8">	PrimaryExpr Arguments .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">Selector       = &quot;.&quot; identifier .</span></span>
<span class="line"><span style="color:#babed8">Index          = &quot;[&quot; Expression [ &quot;,&quot; ] &quot;]&quot; .</span></span>
<span class="line"><span style="color:#babed8">Slice          = &quot;[&quot; [ Expression ] &quot;:&quot; [ Expression ] &quot;]&quot; |</span></span>
<span class="line"><span style="color:#babed8">                 &quot;[&quot; [ Expression ] &quot;:&quot; Expression &quot;:&quot; Expression &quot;]&quot; .</span></span>
<span class="line"><span style="color:#babed8">TypeAssertion  = &quot;.&quot; &quot;(&quot; Type &quot;)&quot; .</span></span>
<span class="line"><span style="color:#babed8">Arguments      = &quot;(&quot; [ ( ExpressionList | Type [ &quot;,&quot; ExpressionList ] ) [ &quot;...&quot; ] [ &quot;,&quot; ] ] &quot;)&quot; .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x</span></span>
<span class="line"><span style="color:#babed8">2</span></span>
<span class="line"><span style="color:#babed8">(s + &quot;.txt&quot;)</span></span>
<span class="line"><span style="color:#babed8">f(3.1415, true)</span></span>
<span class="line"><span style="color:#babed8">Point{1, 2}</span></span>
<span class="line"><span style="color:#babed8">m[&quot;foo&quot;]</span></span>
<span class="line"><span style="color:#babed8">s[i : j + 1]</span></span>
<span class="line"><span style="color:#babed8">obj.color</span></span>
<span class="line"><span style="color:#babed8">f.p[i].x()</span></span></code></pre>
<h3 id="selectors-选择器">Selectors 选择器</h3>
<blockquote>
<p>For a primary expression x that is not a package name, the selector expression</p>
</blockquote>
<p>对于一个不是包名的主表达式 x ，（以下）选择器表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x.f</span></span></code></pre>
<blockquote>
<p>denotes the field or method f of the value x (or sometimes *x; see below). The identifier f is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of f. If x is a package name, see the section on qualified identifiers.</p>
</blockquote>
<p>表示值 x 的字段 f 或方法 f （有时也可能是 *x ；参见下文）。<br/>
标识符 f 称作（字段或方法的）选择器；<br/>
f 不能是空白标识符。<br/>
选择器表达式的类型是 f 的类型。<br/>
如果 x 是包名，请参阅有关限定标识符的章节。</p>
<blockquote>
<p>A selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested embedded field of T. The number of embedded fields traversed to reach f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an embedded field A in T is the depth of f in A plus one.</p>
</blockquote>
<p>选择器 f 可以表示 T 类型的一个字段或方法，也可以指向一个 T 的层层嵌套的字段或方法 f 。<br/>
遍历来到达 f （所经过的）内嵌字段个数叫做它在 T 中的深度。<br/>
T 中声明的字段或方法 f 的深度为零。<br/>
在 T 的内嵌字段 A 中声明的字段或方法的深度，是 f 在 A 中的深度加 1 。</p>
<blockquote>
<p>The following rules apply to selectors:</p>
</blockquote>
<p>以下规则适用于选择器：</p>
<blockquote>
<ol>
<li>For a value x of type T or *T where T is not a pointer or interface type, x.f denotes the field or method at the shallowest depth in T where there is such an f. If there is not exactly one f with shallowest depth, the selector expression is illegal.</li>
</ol>
</blockquote>
<p>对于 T 或 *T 类型的值 x ，（ T 不是指针或接口类型）， x.f 表示 T 中深度最浅的字段或方法（如果确实有这样一个 f 字段或方法）。<br/>
如果最浅深度处有不止一个 f （或者没有 f ），则这个选择器表达式是非法的。</p>
<blockquote>
<ol start="2">
<li>For a value x of type I where I is an interface type, x.f denotes the actual method with name f of the dynamic value of x. If there is no method with name f in the method set of I, the selector expression is illegal.</li>
</ol>
</blockquote>
<p>对于 I 类型的值 x （ I 是接口类型）， x.f 表示带有 x 的动态值、名为 f 的实际方法。<br/>
如果 I 的方法集中没有名为 f 的方法，则选择器表达式是非法的。</p>
<blockquote>
<ol start="3">
<li>As an exception, if the type of x is a defined pointer type and (*x).f is a valid selector expression denoting a field (but not a method), x.f is shorthand for (*x).f.</li>
</ol>
</blockquote>
<p>作为例外，如果 x 的类型是已定义的指针类型，并且 <code>(*x).f</code> 是表示字段（而非方法）的有效的选择器表达式，则 <code>x.f</code> 是 <code>(*x).f</code> 的简写。</p>
<blockquote>
<ol start="4">
<li>In all other cases, x.f is illegal.</li>
</ol>
</blockquote>
<p>其他所有情况下的 <code>x.f</code> 都是非法的。</p>
<blockquote>
<ol start="5">
<li>If x is of pointer type and has the value nil and x.f denotes a struct field, assigning to or evaluating x.f causes a run-time panic.</li>
</ol>
</blockquote>
<p>如果 x 是指针类型，并且带有 nil 值，并且 <code>x.f</code> 表示结构体字段，则赋值给 <code>x.f</code> 或者计算 <code>x.f</code> 会导致运行时 panic 。</p>
<blockquote>
<ol start="6">
<li>If x is of interface type and has the value nil, calling or evaluating the method x.f causes a run-time panic.</li>
</ol>
</blockquote>
<p>如果 x 是接口类型并且带有 nil 值，则调用或计算 <code>x.f</code> 方法会导致运行时 panic 。</p>
<blockquote>
<p>For example, given the declarations:</p>
</blockquote>
<p>例如，给定（如下）声明：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T0 struct {</span></span>
<span class="line"><span style="color:#babed8">	x int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (*T0) M0()</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type T1 struct {</span></span>
<span class="line"><span style="color:#babed8">	y int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (T1) M1()</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type T2 struct {</span></span>
<span class="line"><span style="color:#babed8">	z int</span></span>
<span class="line"><span style="color:#babed8">	T1</span></span>
<span class="line"><span style="color:#babed8">	*T0</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (*T2) M2()</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type Q *T2</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var t T2     // with t.T0 != nil</span></span>
<span class="line"><span style="color:#babed8">var p *T2    // with p != nil and (*p).T0 != nil</span></span>
<span class="line"><span style="color:#babed8">var q Q = p</span></span></code></pre>
<blockquote>
<p>one may write:</p>
</blockquote>
<p>有人可能会写出（下面这些）：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t.z          // t.z</span></span>
<span class="line"><span style="color:#babed8">t.y          // t.T1.y</span></span>
<span class="line"><span style="color:#babed8">t.x          // (*t.T0).x</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">p.z          // (*p).z</span></span>
<span class="line"><span style="color:#babed8">p.y          // (*p).T1.y</span></span>
<span class="line"><span style="color:#babed8">p.x          // (*(*p).T0).x</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">q.x          // (*(*q).T0).x        (*q).x is a valid field selector</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">p.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver</span></span>
<span class="line"><span style="color:#babed8">p.M1()       // ((*p).T1).M1()      M1 expects T1 receiver</span></span>
<span class="line"><span style="color:#babed8">p.M2()       // p.M2()              M2 expects *T2 receiver</span></span>
<span class="line"><span style="color:#babed8">t.M2()       // (&amp;t).M2()           M2 expects *T2 receiver, see section on Calls</span></span></code></pre>
<blockquote>
<p>but the following is invalid:</p>
</blockquote>
<p>但是以下声明就是无效的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">q.M0()       // (*q).M0 is valid but not a field selector</span></span></code></pre>
<h3 id="method-expressions-方法表达式">Method expressions 方法表达式</h3>
<blockquote>
<p>If M is in the method set of type T, T.M is a function that is callable as a regular function with the same arguments as M prefixed by an additional argument that is the receiver of the method.</p>
</blockquote>
<p>如果 M 在类型 T 的方法集中， T.M 是一个可作为常规函数调用的函数，这个函数的实参，和把作为方法的接收者的附加参数作为前缀的 M 相同。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">MethodExpr    = ReceiverType &quot;.&quot; MethodName .</span></span>
<span class="line"><span style="color:#babed8">ReceiverType  = Type .</span></span></code></pre>
<blockquote>
<p>Consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.</p>
</blockquote>
<p>考虑一个带有两个方法 Mv 和 Mp 的结构体类型 T ， Mv 的接收者是类型 T ， Mp 的接收者是 *T 类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T struct {</span></span>
<span class="line"><span style="color:#babed8">	a int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">func (tv  T) Mv(a int) int         { return 0 }  // value receiver</span></span>
<span class="line"><span style="color:#babed8">func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var t T</span></span></code></pre>
<blockquote>
<p>The expression</p>
</blockquote>
<p>这个表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">T.Mv</span></span></code></pre>
<blockquote>
<p>yields a function equivalent to Mv but with an explicit receiver as its first argument; it has signature</p>
</blockquote>
<p>生成一个等价于 Mv 的函数，但带有一个显式的接收者作为函数的第一个实参；这个函数有（如下的）签名</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(tv T, a int) int</span></span></code></pre>
<blockquote>
<p>That function may be called normally with an explicit receiver, so these five invocations are equivalent:</p>
</blockquote>
<p>这个函数可以用显式的接收者正常调用，因此这五个调用是等价的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t.Mv(7)</span></span>
<span class="line"><span style="color:#babed8">T.Mv(t, 7)</span></span>
<span class="line"><span style="color:#babed8">(T).Mv(t, 7)</span></span>
<span class="line"><span style="color:#babed8">f1 := T.Mv; f1(t, 7)</span></span>
<span class="line"><span style="color:#babed8">f2 := (T).Mv; f2(t, 7)</span></span></code></pre>
<blockquote>
<p>Similarly, the expression</p>
</blockquote>
<p>类似地，（如下）表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">(*T).Mp</span></span></code></pre>
<blockquote>
<p>yields a function value representing Mp with signature</p>
</blockquote>
<p>生成一个带有（如下）签名的函数值表示 Mp</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(tp *T, f float32) float32</span></span></code></pre>
<blockquote>
<p>For a method with a value receiver, one can derive a function with an explicit pointer receiver, so</p>
</blockquote>
<p>对于一个带有值接收者的方法，一个可以派生出带有显式指针接收者的函数，因此</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">(*T).Mv</span></span></code></pre>
<blockquote>
<p>yields a function value representing Mv with signature</p>
</blockquote>
<p>生成一个带有（如下）签名的的函数值表示 Mv</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(tv *T, a int) int</span></span></code></pre>
<blockquote>
<p>Such a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.</p>
</blockquote>
<p>这样的一个函数通过接收者间接地来创建一个值，以便将这个值作为接收者传递给底层方法；<br/>
这个方法不会重写在函数调用中被传递了地址的值。</p>
<blockquote>
<p>The final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.</p>
</blockquote>
<p>最后一种情况是指针接收者方法的值接收者函数，这是非法的，因为指针接收者方法并不在这个值类型的方法集中。</p>
<blockquote>
<p>Function values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given f := T.Mv, f is invoked as f(t, 7) not t.f(7). To construct a function that binds the receiver, use a function literal or method value.</p>
</blockquote>
<p>从方法派生出的函数值，用函数调用的语法来调用；<br/>
接收者作为调用的第一个实参来提供。<br/>
也就是说，给定 <code>f := T.Mv</code> ， f 被作为 <code>f(t, 7)</code> 而不是 <code>t.f(7)</code> 来调用。<br/>
（如果）要构造一个绑定了接收者的函数，请使用函数字面量或方法值。</p>
<blockquote>
<p>It is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.</p>
</blockquote>
<p>从一个接口类型的方法派生出一个函数值，是合法的。<br/>
生成的函数，使用这个接口类型的显式接收者。</p>
<h3 id="method-values-方法值">Method values 方法值</h3>
<blockquote>
<p>If the expression x has static type T and M is in the method set of type T, x.M is called a method value. The method value x.M is a function value that is callable with the same arguments as a method call of x.M. The expression x is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.</p>
</blockquote>
<p>如果表达式 x 具有静态类型 T ，且 M 属于 T 类型的方法集中，则 x.M 就叫做一个方法值。<br/>
x.M 方法值是一个可以被与 x.M 的方法调用中相同的实参来调用的函数值。<br/>
在方法值的计算过程中，表达式 x 会被计算并保存；<br/>
然后，保存的副本可以被用作以后可能会被执行的任何调用中的接收方。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type S struct { *T }</span></span>
<span class="line"><span style="color:#babed8">type T int</span></span>
<span class="line"><span style="color:#babed8">func (t T) M() { print(t) }</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">t := new(T)</span></span>
<span class="line"><span style="color:#babed8">s := S{T: t}</span></span>
<span class="line"><span style="color:#babed8">f := t.M                    // receiver *t is evaluated and stored in f</span></span>
<span class="line"><span style="color:#babed8">g := s.M                    // receiver *(s.T) is evaluated and stored in g</span></span>
<span class="line"><span style="color:#babed8">*t = 42                     // does not affect stored receivers in f and g</span></span></code></pre>
<blockquote>
<p>The type T may be an interface or non-interface type.</p>
</blockquote>
<p>类型 T 可以是接口类型，也可以是非接口类型。</p>
<blockquote>
<p>As in the discussion of method expressions above, consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.</p>
</blockquote>
<p>与上面对方法表达式的讨论一样，考虑一个具有两个方法的结构体类型 T ：<br/>
方法 Mv 的接收者属于 T 类型；<br/>
方法 Mp 的接收者属于 *T 类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T struct {</span></span>
<span class="line"><span style="color:#babed8">	a int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">func (tv  T) Mv(a int) int         { return 0 }  // value receiver</span></span>
<span class="line"><span style="color:#babed8">func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var t T</span></span>
<span class="line"><span style="color:#babed8">var pt *T</span></span>
<span class="line"><span style="color:#babed8">func makeT() T</span></span></code></pre>
<blockquote>
<p>The expression</p>
</blockquote>
<p>表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t.Mv</span></span></code></pre>
<blockquote>
<p>yields a function value of type</p>
</blockquote>
<p>生成如下类型的函数值</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(int) int</span></span></code></pre>
<blockquote>
<p>These two invocations are equivalent:</p>
</blockquote>
<p>（以下）这两个调用是等效的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t.Mv(7)</span></span>
<span class="line"><span style="color:#babed8">f := t.Mv; f(7)</span></span></code></pre>
<blockquote>
<p>Similarly, the expression</p>
</blockquote>
<p>类似的，（以下）表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">pt.Mp</span></span></code></pre>
<blockquote>
<p>yields a function value of type</p>
</blockquote>
<p>生成如下类型的函数值</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func(float32) float32</span></span></code></pre>
<blockquote>
<p>As with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv.</p>
</blockquote>
<p>与选择器一样，一个使用了指针的对值接收器的非接口方法的引用，将会自动取消对该指针的引用： pt.Mv 等价于 (*pt).Mv 。</p>
<blockquote>
<p>As with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: t.Mp is equivalent to (&amp;t).Mp.</p>
</blockquote>
<p>与方法调用一样，一个使用可寻址值的对指针接收者的非接口方法的引用，将自动获取该值的地址： t.Mp 等价于 (&amp;t).Mp 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">f := t.Mv; f(7)   // like t.Mv(7)</span></span>
<span class="line"><span style="color:#babed8">f := pt.Mp; f(7)  // like pt.Mp(7)</span></span>
<span class="line"><span style="color:#babed8">f := pt.Mv; f(7)  // like (*pt).Mv(7)</span></span>
<span class="line"><span style="color:#babed8">f := t.Mp; f(7)   // like (&amp;t).Mp(7)</span></span>
<span class="line"><span style="color:#babed8">f := makeT().Mp   // invalid: result of makeT() is not addressable</span></span></code></pre>
<blockquote>
<p>Although the examples above use non-interface types, it is also legal to create a method value from a value of interface type.</p>
</blockquote>
<p>尽管上述例子中用到的都是非接口类型，但其实从接口类型的值创建一个方法值也是合法的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var i interface { M(int) } = myVal</span></span>
<span class="line"><span style="color:#babed8">f := i.M; f(7)  // like i.M(7)</span></span></code></pre>
<h3 id="index-expressions-索引表达式">Index expressions 索引表达式</h3>
<blockquote>
<p>A primary expression of the form</p>
</blockquote>
<p>如下形式的主表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a[x]</span></span></code></pre>
<blockquote>
<p>denotes the element of the array, pointer to array, slice, string or map a indexed by x. The value x is called the index or map key, respectively. The following rules apply:</p>
</blockquote>
<p>表示由 x 索引数组的元素，或者指向数组的指针，或切片，或字符串的 a 。<br/>
值 x 分别称为索引，或 map 的键。<br/>
以下规则适用：</p>
<blockquote>
<p>If a is neither a map nor a type parameter:</p>
</blockquote>
<p>如果 a 既不是 map 也不是类型参数:</p>
<blockquote>
<ul>
<li>the index x must be an untyped constant or its core type must be an integer</li>
</ul>
</blockquote>
<p>索引 x 必须是无类型常量，或者其核心类型必须是整数</p>
<blockquote>
<ul>
<li>a constant index must be non-negative and representable by a value of type int</li>
</ul>
</blockquote>
<p>常量索引必须是非负数，并且可以用 int 类型的值表示</p>
<blockquote>
<ul>
<li>a constant index that is untyped is given type int</li>
</ul>
</blockquote>
<p>无类型常量的索引，会被赋 int 类型</p>
<blockquote>
<ul>
<li>the index x is in range if <code>0 &lt;= x &lt; len(a)</code>, otherwise it is out of range</li>
</ul>
</blockquote>
<p>索引 x 在 <code>0 &lt;= x &lt; len(a)</code> 范围内，否则就会越界</p>
<blockquote>
<p>For a of array type A:</p>
</blockquote>
<p>对于数组类型 A 的值 a ：</p>
<blockquote>
<ul>
<li>a constant index must be in range</li>
</ul>
</blockquote>
<p>常量索引必须在范围内</p>
<blockquote>
<ul>
<li>if x is out of range at run time, a run-time panic occurs</li>
</ul>
</blockquote>
<p>如果 x 在运行时越界，那么会发生运行时 panic</p>
<blockquote>
<ul>
<li>a[x] is the array element at index x and the type of a[x] is the element type of A</li>
</ul>
</blockquote>
<p>a[x] 是索引 x 处的数组元素， a[x] 的类型是 A 的元素类型</p>
<blockquote>
<p>For a of pointer to array type:</p>
</blockquote>
<p>对于指向数组类型的指针 a ：</p>
<blockquote>
<ul>
<li>a[x] is shorthand for (*a)[x]</li>
</ul>
</blockquote>
<p>a[x] 是 (*a)[x] 的简写</p>
<blockquote>
<p>For a of slice type S:</p>
</blockquote>
<p>对于切片类型 S 的值 a  ：</p>
<blockquote>
<ul>
<li>if x is out of range at run time, a run-time panic occurs</li>
</ul>
</blockquote>
<p>如果 x 在运行时越界，那么就会发生运行时死机</p>
<blockquote>
<ul>
<li>a[x] is the slice element at index x and the type of a[x] is the element type of S</li>
</ul>
</blockquote>
<p>a[x] 是索引 x 处的切片元素，那么 a[x] 的类型是 S 的元素类型</p>
<blockquote>
<p>For a of string type:</p>
</blockquote>
<p>对于字符串类型的值 a :</p>
<blockquote>
<ul>
<li>a constant index must be in range if the string a is also constant</li>
</ul>
</blockquote>
<p>如果字符串 a 也是常量，那么常量索引必须在范围内</p>
<blockquote>
<ul>
<li>if x is out of range at run time, a run-time panic occurs</li>
</ul>
</blockquote>
<p>如果 x 在运行时越界，那么 x 会发生运行时 panic</p>
<blockquote>
<ul>
<li>a[x] is the non-constant byte value at index x and the type of a[x] is byte</li>
</ul>
</blockquote>
<p>a[x] 是索引 x 处的非常量字节值，且类型 a[x] 的类型是 byte</p>
<blockquote>
<ul>
<li>a[x] may not be assigned to</li>
</ul>
</blockquote>
<p>a[x] 可能不会被分配</p>
<blockquote>
<p>For a of map type M:</p>
</blockquote>
<p>对于 map 类型 M 的值 a ：</p>
<blockquote>
<ul>
<li>x’s type must be assignable to the key type of M</li>
</ul>
</blockquote>
<p>x 的类型必须可以分配 M 类型的键</p>
<blockquote>
<ul>
<li>if the map contains an entry with key x, a[x] is the map element with key x and the type of a[x] is the element type of M</li>
</ul>
</blockquote>
<p>如果 map 包含带键 x 的条目，那么 a[x] 是带键 x 的 map 元素，且 a[x] 的类型是 M 的元素类型</p>
<blockquote>
<ul>
<li>if the map is nil or does not contain such an entry, a[x] is the zero value for the element type of M</li>
</ul>
</blockquote>
<p>如果 map 为 nil ，或者不包含这样的条目，那么 a[x] 就是 M 的元素类型的零值</p>
<blockquote>
<p>For a of type parameter type P:</p>
</blockquote>
<p>对于 P 类型的类型参数 a ：</p>
<blockquote>
<ul>
<li>The index expression a[x] must be valid for values of all types in P’s type set.</li>
</ul>
</blockquote>
<p>索引表达式 a[x] 必须对 P 的类型集中的所有类型的值都有效。</p>
<blockquote>
<ul>
<li>The element types of all types in P’s type set must be identical. In this context, the element type of a string type is byte.</li>
</ul>
</blockquote>
<p>P 的类型集中所有类型的元素类型必须一致。在这个上下文中，字符串类型的元素类型是 byte。</p>
<blockquote>
<ul>
<li>If there is a map type in the type set of P, all types in that type set must be map types, and the respective key types must be all identical.</li>
</ul>
</blockquote>
<p>如果有一个 map 类型处于 P 的类型集中，那么该类型集中的所有类型都必须是 map 类型，并且相应的键类型必须全部一致。</p>
<blockquote>
<ul>
<li>a[x] is the array, slice, or string element at index x, or the map element with key x of the type argument that P is instantiated with, and the type of a[x] is the type of the (identical) element types.</li>
</ul>
</blockquote>
<p>a[x] 是索引 x 处的数组、切片或字符串元素，或者 P 实例化时使用的类型实参的键 x 的 map 元素，并且 a[x] 的类型是（一致的）元素类型的类型。</p>
<blockquote>
<ul>
<li>a[x] may not be assigned to if P’s type set includes string types.</li>
</ul>
</blockquote>
<p>如果 P 的类型集包含字符串类型，那么 a[x] 可能不会被分配到。</p>
<blockquote>
<p>Otherwise a[x] is illegal.</p>
</blockquote>
<p>否则 a[x] 就是非法的。</p>
<blockquote>
<p>An index expression on a map a of type map[K]V used in an assignment statement or initialization of the special form</p>
</blockquote>
<p>在赋值语句或特殊形式的初始化中，使用的 map[K]V 类型的一个map a 上的索引表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">v, ok = a[x]</span></span>
<span class="line"><span style="color:#babed8">v, ok := a[x]</span></span>
<span class="line"><span style="color:#babed8">var v, ok = a[x]</span></span></code></pre>
<blockquote>
<p>yields an additional untyped boolean value. The value of ok is true if the key x is present in the map, and false otherwise.</p>
</blockquote>
<p>产生一个额外的无类型布尔值。<br/>
如果键 x 存在于 map 中，那么 ok 的值为 true，否则为 false 。</p>
<blockquote>
<p>Assigning to an element of a nil map causes a run-time panic.</p>
</blockquote>
<p>分配给 nil map 的元素会导致运行时 panic 。</p>
<p><em>上面这一条是很显然的，但程序员却常常忘记初始化 map 而不小心去索引一个 nil map 。</em><br/>
<em>下面是常见的错误代码：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> m </span><span style="color:#89DDFF">map[</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#BABED8">m</span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">200</span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">OK</span><span style="color:#89DDFF">&quot;</span></span></code></pre>
<p><em>这个代码是错误的， m 只是被声明了类型，还没有被初始化，所以是 nil 。</em><br/>
<em>代码运行会报错：panic: assignment to entry in nil map</em><br/>
<em>下面是订正后的正确代码：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">m </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">make</span><span style="color:#89DDFF">(map[</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#BABED8">m</span><span style="color:#89DDFF">[</span><span style="color:#F78C6C">200</span><span style="color:#89DDFF">]</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">OK</span><span style="color:#89DDFF">&quot;</span></span></code></pre>
<h3 id="slice-expressions-切片表达式">Slice expressions 切片表达式</h3>
<blockquote>
<p>Slice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.</p>
</blockquote>
<p>Slice 表达式可以从字符串、数组、指向数组的指针或切片来构造子字符串或切片。<br/>
有两个变式: 一个指定了最低和最高边界的简单形式，另一个同样指定了容量的边界的完整形式。</p>
<h4 id="simple-slice-expressions-简单切片表达式">Simple slice expressions 简单切片表达式</h4>
<blockquote>
<p>The primary expression</p>
</blockquote>
<p>主表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a[low : high]</span></span></code></pre>
<blockquote>
<p>constructs a substring or slice. The core type of a must be a string, array, pointer to array, slice, or a bytestring. The indices low and high select which elements of operand a appear in the result. The result has indices starting at 0 and length equal to high - low. After slicing the array a</p>
</blockquote>
<p>构造子字符串或切片。<br/>
a 的核心类型必须是字符串、数组、指向数组的指针、切片或字节字符串。<br/>
低位和高位的索引会选择操作数 a 的哪些元素出现在结果中。<br/>
结果的索引从0开始，长度等于 <code>high - low</code> 。<br/>
在对数组 a 进行切片之后，</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a := [5]int{1, 2, 3, 4, 5}</span></span>
<span class="line"><span style="color:#babed8">s := a[1:4]</span></span></code></pre>
<blockquote>
<p>the slice s has type []int, length 3, capacity 4, and elements</p>
</blockquote>
<p>切片 s 具有类型 []int，长度为3，容量为4，且元素为</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s[0] == 2</span></span>
<span class="line"><span style="color:#babed8">s[1] == 3</span></span>
<span class="line"><span style="color:#babed8">s[2] == 4</span></span></code></pre>
<blockquote>
<p>For convenience, any of the indices may be omitted. A missing low index defaults to zero; a missing high index defaults to the length of the sliced operand:</p>
</blockquote>
<p>为了方便，任何索引都可以省略。<br/>
缺少的低位索引默认为零；<br/>
缺少的高位索引默认为切片操作数的长度：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a[2:]  // same as a[2 : len(a)]</span></span>
<span class="line"><span style="color:#babed8">a[:3]  // same as a[0 : 3]</span></span>
<span class="line"><span style="color:#babed8">a[:]   // same as a[0 : len(a)]</span></span></code></pre>
<blockquote>
<p>If a is a pointer to an array, a[low : high] is shorthand for (*a)[low : high].</p>
</blockquote>
<p>如果 a 是指向数组的指针， 那么 <code>a[low : high]</code> 是 <code>(*a)[low : high]</code> 的简写。</p>
<blockquote>
<p>For arrays or strings, the indices are in range if <code>0 &lt;= low &lt;= high &lt;= len(a)</code>, otherwise they are out of range. For slices, the upper index bound is the slice capacity cap(a) rather than the length. A constant index must be non-negative and representable by a value of type int; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy <code>low &lt;= high</code>. If the indices are out of range at run time, a run-time panic occurs.</p>
</blockquote>
<p>对于数组或字符串，如果有 <code>0 &lt;= low &lt;= high &lt;= len(a)</code> ，那么索引是在范围内的，否则它们就会越界。<br/>
对于切片，索引上限是切片容量 cap(a) 而不是长度。<br/>
常量索引必须是非负数，并且可以由 int 类型的值表示；<br/>
对于数组或常量字符串，常量索引也必须在范围内。<br/>
如果两个索引都是常量，则它们必须满足 <code>low &lt;= high</code> 。<br/>
如果索引在运行时越界，则会发生运行时 panic 。</p>
<blockquote>
<p>Except for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type string. If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.</p>
</blockquote>
<p>除了无类型字符串之外，如果切片操作数是字符串或切片，那么切片操作的结果是与操作数类型相同的非常量值。<br/>
对于无类型字符串操作数，结果是字符串类型的非常量值。<br/>
如果切片操作数是数组，那么它必须是可寻址的，并且切片操作的结果是与数组具有相同元素类型的切片。</p>
<blockquote>
<p>If the sliced operand of a valid slice expression is a nil slice, the result is a nil slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.</p>
</blockquote>
<p>如果有效的切片表达式的切片操作数是一个 nil 切片，则结果也为 nil 切片。<br/>
否则，如果结果是切片，则它与操作数共享其基础数组。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a [10]int</span></span>
<span class="line"><span style="color:#babed8">s1 := a[3:7]   // underlying array of s1 is array a; &amp;s1[2] == &amp;a[5]</span></span>
<span class="line"><span style="color:#babed8">s2 := s1[1:4]  // underlying array of s2 is underlying array of s1 which is array a; &amp;s2[1] == &amp;a[5]</span></span>
<span class="line"><span style="color:#babed8">s2[1] = 42     // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var s []int</span></span>
<span class="line"><span style="color:#babed8">s3 := s[:0]    // s3 == nil</span></span></code></pre>
<h4 id="full-slice-expressions-完整切片表达式">Full slice expressions 完整切片表达式</h4>
<blockquote>
<p>The primary expression</p>
</blockquote>
<p>主表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a[low : high : max]</span></span></code></pre>
<blockquote>
<p>constructs a slice of the same type, and with the same length and elements as the simple slice expression a[low : high]. Additionally, it controls the resulting slice’s capacity by setting it to max - low. Only the first index may be omitted; it defaults to 0. The core type of a must be an array, pointer to array, or slice (but not a string). After slicing the array a</p>
</blockquote>
<p>构造了一个与简单切片表达式 <code>a[low : high]</code> 具有相同类型且具有相同长度和元素的切片。<br/>
此外，它还将生成的切片的容量设置为 <code>max - low</code> 。<br/>
只有第一个索引才可以省略；它默认为 0。<br/>
a 的核心类型必须是一个数组，或指向数组的指针，或切片（但不是字符串）。<br/>
在对数组 a 进行切片之后，</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a := [5]int{1, 2, 3, 4, 5}</span></span>
<span class="line"><span style="color:#babed8">t := a[1:3:5]</span></span></code></pre>
<blockquote>
<p>the slice t has type []int, length 2, capacity 4, and elements</p>
</blockquote>
<p>切片 t 具有 []int 类型，长度为 2、容量为 4 ，且元素为</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t[0] == 2</span></span>
<span class="line"><span style="color:#babed8">t[1] == 3</span></span></code></pre>
<blockquote>
<p>As for simple slice expressions, if a is a pointer to an array, a[low : high : max] is shorthand for (*a)[low : high : max]. If the sliced operand is an array, it must be addressable.</p>
</blockquote>
<p>对于简单切片表达式，如果 a 是指向数组的指针，那么 <code>(*a)[low : high : max]</code> 可以简写为 <code>a[low : high : max]</code> 。<br/>
如果切片操作数是一个数组，则它必须是可寻址的。</p>
<blockquote>
<p>The indices are in range if <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>, otherwise they are out of range. A constant index must be non-negative and representable by a value of type int; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.</p>
</blockquote>
<p>索引应该在 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code> 的范围内，否则就会越界。<br/>
常量索引必须是非负数，并且可由 int 类型的值表示；<br/>
对于数组，常量索引也必须在范围内。<br/>
如果多个索引都是常量，则存在的常量必须处于彼此相对的范围内。<br/>
如果索引在运行时越界，则会发生运行时 panic 。</p>
<h3 id="type-assertions-类型断言">Type assertions 类型断言</h3>
<blockquote>
<p>For an expression x of interface type, but not a type parameter, and a type T, the primary expression</p>
</blockquote>
<p>对于接口类型但不是类型参数的表达式 x ，以及类型 T ，以下的主要表达式：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x.(T)</span></span></code></pre>
<blockquote>
<p>asserts that x is not nil and that the value stored in x is of type T. The notation x.(T) is called a type assertion.</p>
</blockquote>
<p>断言出 x 不为 nil ，并且存储在 x 中的值是类型 T 。<br/>
这种写法 x.(T) 称为类型断言。</p>
<blockquote>
<p>More precisely, if T is not an interface type, x.(T) asserts that the dynamic type of x is identical to the type T. In this case, T must implement the (interface) type of x; otherwise the type assertion is invalid since it is not possible for x to store a value of type T. If T is an interface type, x.(T) asserts that the dynamic type of x implements the interface T.</p>
</blockquote>
<p>更准确地说，如果 T 不是一个接口类型，则 x.(T) 断言的 x 的动态类型与类型 T 相同。<br/>
在这种情况下， T 必须实现 x 的（接口）类型；否则，类型断言无效，因为 x 不可能存储 T 类型的值。<br/>
如果 T 为接口类型，则 x.(T) 断言为 x 的动态类型实现了接口 T 。</p>
<blockquote>
<p>If the type assertion holds, the value of the expression is the value stored in x and its type is T. If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of x is known only at run time, the type of x.(T) is known to be T in a correct program.</p>
</blockquote>
<p>如果类型断言成立，则表达式的值是存储在 x 中的值，且类型为 T 。<br/>
如果类型断言为 false，则会发生运行时 panic 。<br/>
换言之，即使 x 的动态类型仅仅是在运行时才是已知的，但 x.(T) 的类型在正确的程序中也被认为是 T 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x interface{} = 7          // x has dynamic type int and value 7</span></span>
<span class="line"><span style="color:#babed8">i := x.(int)                   // i has type int and value 7</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type I interface { m() }</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func f(y I) {</span></span>
<span class="line"><span style="color:#babed8">	s := y.(string)        // illegal: string does not implement I (missing method m)</span></span>
<span class="line"><span style="color:#babed8">	r := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader</span></span>
<span class="line"><span style="color:#babed8">	…</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A type assertion used in an assignment statement or initialization of the special form</p>
</blockquote>
<p>赋值语句或特殊形式的初始化中使用的类型断言（如下）：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">v, ok = x.(T)</span></span>
<span class="line"><span style="color:#babed8">v, ok := x.(T)</span></span>
<span class="line"><span style="color:#babed8">var v, ok = x.(T)</span></span>
<span class="line"><span style="color:#babed8">var v, ok interface{} = x.(T) // dynamic types of v and ok are T and bool</span></span></code></pre>
<blockquote>
<p>yields an additional untyped boolean value. The value of ok is true if the assertion holds. Otherwise it is false and the value of v is the zero value for type T. No run-time panic occurs in this case.</p>
</blockquote>
<p>生成一个额外的无类型布尔值。<br/>
如果断言成立，则 ok 的值为 true ；<br/>
否则 ok 的值为 false ，且 v 的值为 T 类型的零值。<br/>
在这种情况下，不会发生运行时 panic。</p>
<h3 id="calls-调用">Calls 调用</h3>
<blockquote>
<p>Given an expression f with a core type F of function type,</p>
</blockquote>
<p>给定一个带有核心类型 F 的函数类型的表达式 f ，</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">f(a1, a2, … an)</span></span></code></pre>
<blockquote>
<p>calls f with arguments a1, a2, … an. Except for one special case, arguments must be single-valued expressions assignable to the parameter types of F and are evaluated before the function is called. The type of the expression is the result type of F. A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.</p>
</blockquote>
<p>带参数 a1, a2, … an 的调用 f .<br/>
除了一种特殊情况外，参数必须是可分配给 F 类型形参的单值表达式，并在调用函数之前计算。<br/>
表达式的类型即为 F 的结果类型。<br/>
方法调用也是类似的，但方法本身被指定为方法的接收者类型的值的选择器。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">math.Atan2(x, y)  // function call</span></span>
<span class="line"><span style="color:#babed8">var pt *Point</span></span>
<span class="line"><span style="color:#babed8">pt.Scale(3.5)     // method call with receiver pt</span></span></code></pre>
<blockquote>
<p>If f denotes a generic function, it must be instantiated before it can be called or used as a function value.</p>
</blockquote>
<p>如果 f 标识了一个泛型函数，则 f 必须先实例化它，然后才能调用它或将其用作函数值。</p>
<blockquote>
<p>In a function call, the function value and arguments are evaluated in the usual order. After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution. The return parameters of the function are passed by value back to the caller when the function returns.</p>
</blockquote>
<p>在函数调用中，函数值和实参按通常的顺序计算。<br/>
计算后，调用的参数将会按值传递给函数，被调用的函数开始执行。<br/>
当函数返回时，函数的返回参数按值传递回调用方。</p>
<blockquote>
<p>Calling a nil function value causes a run-time panic.</p>
</blockquote>
<p>调用 nil 函数值会导致运行时 panic 。</p>
<blockquote>
<p>As a special case, if the return values of a function or method g are equal in number and individually assignable to the parameters of another function or method f, then the call f(g(parameters_of_g)) will invoke f after binding the return values of g to the parameters of f in order. The call of f must contain no parameters other than the call of g, and g must have at least one return value. If f has a final … parameter, it is assigned the return values of g that remain after assignment of regular parameters.</p>
</blockquote>
<p>作为特殊情况，如果一个函数或方法的返回值数量相等，并且可以单独分配给另一个函数或方法 f 的参数，那么调用 <code>f(g(parameters_of_g))</code> 将在按顺序绑定 g 的返回值到 f 的参数上之后再调用 f 。<br/>
调用 f 不能有除了 g 调用之外的任何参数，并且 g 必须至少有一个返回值。<br/>
如果末尾有 … 参数，那么会分配 g 的分配了常规参数后剩余的返回值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func Split(s string, pos int) (string, string) {</span></span>
<span class="line"><span style="color:#babed8">	return s[0:pos], s[pos:]</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func Join(s, t string) string {</span></span>
<span class="line"><span style="color:#babed8">	return s + t</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">if Join(Split(value, len(value)/2)) != value {</span></span>
<span class="line"><span style="color:#babed8">	log.Panic(&quot;test fails&quot;)</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A method call x.m() is valid if the method set of (the type of) x contains m and the argument list can be assigned to the parameter list of m. If x is addressable and &amp;x’s method set contains m, x.m() is shorthand for (&amp;x).m():</p>
</blockquote>
<p>如果 x （的类型）的方法集包含 m ，并且实参列表可以分配给 m 的参数列表，那么方法调用 <code>x.m()</code> 有效。<br/>
如果 x 可寻址并且 &amp;x 的方法集包含 m ，那么 <code>x.m()</code> 是 <code>(&amp;x).m()</code> 的简写：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var p Point</span></span>
<span class="line"><span style="color:#babed8">p.Scale(3.5)</span></span></code></pre>
<blockquote>
<p>There is no distinct method type and there are no method literals.</p>
</blockquote>
<p>没有独立的方法类型（它一定和某个结构体相关），也没有方法字面量（ Go 中有函数字面量，也就是匿名函数；但是 Go 没有方法字面量，即没有匿名方法）。</p>
<h3 id="passing-arguments-to--parameters-传递实参给形如的形参">Passing arguments to … parameters 传递实参给形如…的形参</h3>
<blockquote>
<p>If f is variadic with a final parameter p of type …T, then within f the type of p is equivalent to type []T. If f is invoked with no actual arguments for p, the value passed to p is nil. Otherwise, the value passed is a new slice of type []T with a new underlying array whose successive elements are the actual arguments, which all must be assignable to T. The length and capacity of the slice is therefore the number of arguments bound to p and may differ for each call site.</p>
</blockquote>
<p>如果 f 是带有最终参数 p 为 类型 …T 的可变参数，则对于 f ，类型 p 等价于类型 []T 。<br/>
如果调用 f 时没有提供实际的实参给 p ，则 f 传递给 p 的值为 nil 。<br/>
否则，传递的值是具有新基础数组的 []T 类型的新切片，其连续元素作为实际实参，所有参数都必须是可分配给 T 的。<br/>
因此，切片的长度和容量即为绑定到 p 的实参个数，这对于每个调用点可能会有所不同。</p>
<blockquote>
<p>Given the function and calls</p>
</blockquote>
<p>给定（如下）函数和调用：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func Greeting(prefix string, who ...string)</span></span>
<span class="line"><span style="color:#babed8">Greeting(&quot;nobody&quot;)</span></span>
<span class="line"><span style="color:#babed8">Greeting(&quot;hello:&quot;, &quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;)</span></span></code></pre>
<blockquote>
<p>within Greeting, who will have the value nil in the first call, and []stringEileen in the second.</p>
</blockquote>
<p>在 Greeting 中，第一次调用获得的值是 nil ，而第二次调用获得的值是 <code>[]string{&quot;Joe&quot;, &quot;Anna&quot;, &quot;Eileen&quot;}</code> 。</p>
<blockquote>
<p>If the final argument is assignable to a slice type []T and is followed by …, it is passed unchanged as the value for a …T parameter. In this case no new slice is created.</p>
</blockquote>
<p>如果最后一个实参是可分配给切片类型 []T 的，并且后跟 … ，则作为 …T 参数的值传递时保持不变。<br/>
在这种情况下，不会创建新的切片。</p>
<blockquote>
<p>Given the slice s and call</p>
</blockquote>
<p>给定（如下）切片 s 和调用：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s := []string{&quot;James&quot;, &quot;Jasmine&quot;}</span></span>
<span class="line"><span style="color:#babed8">Greeting(&quot;goodbye:&quot;, s...)</span></span></code></pre>
<blockquote>
<p>within Greeting, who will have the same value as s with the same underlying array.</p>
</blockquote>
<p>在 Greeting 中，将获得与 s 相同的值，且基础数组相同。</p>
<h3 id="instantiations-实例化">Instantiations 实例化</h3>
<blockquote>
<p>A generic function or type is <em>instantiated</em> by substituting <em>type arguments</em> for the type parameters. Instantiation proceeds in two steps:</p>
</blockquote>
<p>泛型函数或类型是通过把类型形参替换成<em>类型实参</em>来<em>实例化</em>的。<br/>
实例化分两步进行：</p>
<blockquote>
<ol>
<li>Each type argument is substituted for its corresponding type parameter in the generic declaration. This substitution happens across the entire function or type declaration, including the type parameter list itself and any types in that list.</li>
</ol>
</blockquote>
<p>泛型声明中，每个类型实参都会替代其对应的类型形参。<br/>
此替换发生在整个函数或类型声明中，包括类型形参列表本身以及该列表中的任何类型。</p>
<blockquote>
<ol start="2">
<li>After substitution, each type argument must satisfy the constraint (instantiated, if necessary) of the corresponding type parameter. Otherwise instantiation fails.</li>
</ol>
</blockquote>
<p>替换后，每个类型实参必须满足相应类型形参的约束（如有必要，实例化）。<br/>
否则，实例化将失败。</p>
<blockquote>
<p>Instantiating a type results in a new non-generic named type; instantiating a function produces a new non-generic function.</p>
</blockquote>
<p>实例化一个类型会产生一个新的非泛型的具名类型；<br/>
实例化一个函数会产生一个新的非泛型函数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type parameter list    type arguments    after substitution</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">[P any]                int               int satisfies any</span></span>
<span class="line"><span style="color:#babed8">[S ~[]E, E any]        []int, int        []int satisfies ~[]int, int satisfies any</span></span>
<span class="line"><span style="color:#babed8">[P io.Writer]          string            illegal: string doesn&#39;t satisfy io.Writer</span></span>
<span class="line"><span style="color:#babed8">[P comparable]         any               any satisfies (but does not implement) comparable</span></span></code></pre>
<blockquote>
<p>When using a generic function, type arguments may be provided explicitly, or they may be partially or completely inferred from the context in which the function is used. Provided that they can be inferred, type argument lists may be omitted entirely if the function is:</p>
</blockquote>
<p>使用泛型函数时，可以显式提供类型实参，也可以部分或完全从使用该函数的上下文中推断出它们。如果函数是（下列形式之一），（就）可以推断出它们：</p>
<blockquote>
<ul>
<li>called with ordinary arguments,</li>
</ul>
</blockquote>
<p>用普通的实参来调用，</p>
<blockquote>
<ul>
<li>assigned to a variable with a known type</li>
</ul>
</blockquote>
<p>分配给具有已知类型的变量</p>
<blockquote>
<ul>
<li>passed as an argument to another function, or</li>
</ul>
</blockquote>
<p>作为实参传递给另一个函数，或</p>
<blockquote>
<ul>
<li>returned as a result.</li>
</ul>
</blockquote>
<p>作为结果返回。</p>
<blockquote>
<p>In all other cases, a (possibly partial) type argument list must be present. If a type argument list is absent or partial, all missing type arguments must be inferrable from the context in which the function is used.</p>
</blockquote>
<p>在所有其他情况下，（可能是部分）类型实参列表必须存在。<br/>
如果类型实参列表不存在或部分（提供），则必须（能够）从使用该函数的上下文推断出所有缺少的类型实参。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// sum returns the sum (concatenation, for strings) of its arguments.</span></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> sum</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">T ~</span><span style="color:#C792EA">int</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> ~</span><span style="color:#C792EA">float64</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">|</span><span style="color:#BABED8"> ~</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">](</span><span style="color:#BABED8">x</span><span style="color:#89DDFF">...</span><span style="color:#BABED8"> T</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> T </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">x </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> sum                       </span><span style="color:#676E95;font-style:italic">// illegal: the type of x is unknown</span></span>
<span class="line"><span style="color:#BABED8">intSum </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> sum</span><span style="color:#89DDFF">[</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">             </span><span style="color:#676E95;font-style:italic">// intSum has type func(x... int) int</span></span>
<span class="line"><span style="color:#BABED8">a </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">intSum</span><span style="color:#89DDFF">(</span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">              </span><span style="color:#676E95;font-style:italic">// a has value 5 of type int</span></span>
<span class="line"><span style="color:#BABED8">b </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> sum</span><span style="color:#89DDFF">[</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">](</span><span style="color:#F78C6C">2.0</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">      </span><span style="color:#676E95;font-style:italic">// b has value 5.0 of type float64</span></span>
<span class="line"><span style="color:#BABED8">c </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">sum</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">b</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">-</span><span style="color:#F78C6C">1</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">                </span><span style="color:#676E95;font-style:italic">// c has value 4.0 of type float64</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">sumFunc</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">x</span><span style="color:#89DDFF">...</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> f sumFunc </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> sum            </span><span style="color:#676E95;font-style:italic">// same as var f sumFunc = sum[string]</span></span>
<span class="line"><span style="color:#BABED8">f </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> sum                        </span><span style="color:#676E95;font-style:italic">// same as f = sum[string]</span></span></code></pre>
<blockquote>
<p>A partial type argument list cannot be empty; at least the first argument must be present. The list is a prefix of the full list of type arguments, leaving the remaining arguments to be inferred. Loosely speaking, type arguments may be omitted from “right to left”.</p>
</blockquote>
<p>部分提供类型的实参列表不能为空；<br/>
至少第一个参数必须存在。<br/>
该列表是类型实参的完整列表的前缀，其余实参则有待于推断。<br/>
粗略地说，类型实参可以从“右到左”省略。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> apply</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">S ~</span><span style="color:#89DDFF">[]</span><span style="color:#BABED8">E</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> E any</span><span style="color:#89DDFF">](</span><span style="color:#BABED8">s S</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> f </span><span style="color:#89DDFF">func(</span><span style="color:#BABED8">E</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> E</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> S </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8">f0 </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> apply[]                  </span><span style="color:#676E95;font-style:italic">// illegal: type argument list cannot be empty</span></span>
<span class="line"><span style="color:#BABED8">f1 </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> apply</span><span style="color:#89DDFF">[[]</span><span style="color:#C792EA">int</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">             </span><span style="color:#676E95;font-style:italic">// type argument for S explicitly provided, type argument for E inferred</span></span>
<span class="line"><span style="color:#BABED8">f2 </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> apply</span><span style="color:#89DDFF">[[]</span><span style="color:#C792EA">string</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#C792EA">string</span><span style="color:#89DDFF">]</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// both type arguments explicitly provided</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> bytes </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">byte</span></span>
<span class="line"><span style="color:#BABED8">r </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">apply</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">bytes</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func(</span><span style="color:#C792EA">byte</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#C792EA">byte</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">})</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// both type arguments inferred from the function arguments</span></span></code></pre>
<blockquote>
<p>For a generic type, all type arguments must always be provided explicitly.</p>
</blockquote>
<p>对于泛型类型，必须始终显式提供所有类型实参。</p>
<h3 id="type-inference-类型推断">Type inference 类型推断</h3>
<blockquote>
<p>A use of a generic function may omit some or all type arguments if they can be inferred from the context within which the function is used, including the constraints of the function’s type parameters. Type inference succeeds if it can infer the missing type arguments and instantiation succeeds with the inferred type arguments. Otherwise, type inference fails and the program is invalid.</p>
</blockquote>
<p>如果可以从所使用的函数的上下文（包括函数类型参数的约束）推断出类型参数，则泛型函数的使用可能会省略部分或全部（能推断出来的）类型参数。<br/>
如果类型推断可以推断缺少的类型参数，并且使用推断的类型参数来实例化也是成功的，则类型推断就成功。否则，类型推断将会失败，程序无效。</p>
<blockquote>
<p>Type inference uses the type relationships between pairs of types for inference: For instance, a function argument must be assignable to its respective function parameter; this establishes a relationship between the type of the argument and the type of the parameter. If either of these two types contains type parameters, type inference looks for the type arguments to substitute the type parameters with such that the assignability relationship is satisfied. Similarly, type inference uses the fact that a type argument must satisfy the constraint of its respective type parameter.</p>
</blockquote>
<p>类型推断是使用成对类型之间的类型关系来进行推理的：<br/>
例如，函数参数必须可以分配给其各自的函数参数；这将在形参类型和实参类型之间建立关系。<br/>
如果这两种类型中的任何一种包含了类型形参，则类型推断将会查找类型实参来替换类型形参，以便满足可分配的关系。<br/>
同样，类型推断利用了类型实参必须满足其各自类型形参的约束这一点事实。</p>
<blockquote>
<p>Each such pair of matched types corresponds to a type equation containing one or multiple type parameters, from one or possibly multiple generic functions. Inferring the missing type arguments means solving the resulting set of type equations for the respective type parameters.</p>
</blockquote>
<p>每一对这样的匹配的类型都会对应于一个类型公式，其中包含来自一个或多个泛型函数的一个或多个类型参数。<br/>
推断缺少的类型实参意味着求解相应类型形参的类型方程的结果集。</p>
<blockquote>
<p>For example, given</p>
</blockquote>
<p>例如，给定</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#676E95;font-style:italic">// dedup returns a copy of the argument slice with any duplicate entries removed.</span></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> dedup</span><span style="color:#89DDFF">[</span><span style="color:#BABED8">S ~</span><span style="color:#89DDFF">[]</span><span style="color:#BABED8">E</span><span style="color:#89DDFF">,</span><span style="color:#BABED8"> E comparable</span><span style="color:#89DDFF">](</span><span style="color:#BABED8">S</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> S </span><span style="color:#89DDFF">{</span><span style="color:#BABED8"> … </span><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF">type</span><span style="color:#BABED8"> </span><span style="color:#FFCB6B">Slice</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">[]</span><span style="color:#C792EA">int</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> s Slice</span></span>
<span class="line"><span style="color:#BABED8">s </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">dedup</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">s</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">   </span><span style="color:#676E95;font-style:italic">// same as s = dedup[Slice, int](s)</span></span></code></pre>
<blockquote>
<p>the variable s of type Slice must be assignable to the function parameter type S for the program to be valid. To reduce complexity, type inference ignores the directionality of assignments, so the type relationship between Slice and S can be expressed via the (symmetric) type equation Slice ≡A S (or S ≡A Slice for that matter), where the A in ≡A indicates that the LHS and RHS types must match per assignability rules (see the section on type unification for details). Similarly, the type parameter S must satisfy its constraint ~[]E. This can be expressed as S ≡C ~[]E where X ≡C Y stands for “X satisfies constraint Y”. These observations lead to a set of two equations</p>
</blockquote>
<p>（上面例子中）Slice 类型的变量 s 必须可分配给函数形参类型 S ，程序才有效。<br/>
为了降低复杂性，类型推断忽略了赋值的方向性，因此 Slice 和 S 之间的类型关系可以通过（对称）类型方程 <code>Slice ≡A S</code> （这里也可以换成 <code>S ≡A Slice</code> ）来表示，其中 <code>A in ≡A</code> 表示 LHS 和 RHS 类型必须根据可分配性规则来匹配（详见（下面的）类型统一小节）。<br/>
同样地，类型参数 S 必须满足其约束 <code>~[]E</code> 。<br/>
这可以表示为 <code>S ≡C ~[]E</code> ，其中 <code>X ≡C Y</code> 表示 “X 满足约束 Y”。<br/>
这些观察结果引出了一组两个方程</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">	Slice ≡A S      (1)</span></span>
<span class="line"><span style="color:#babed8">	S     ≡C ~[]E   (2)</span></span></code></pre>
<blockquote>
<p>which now can be solved for the type parameters S and E. From (1) a compiler can infer that the type argument for S is Slice. Similarly, because the underlying type of Slice is []int and []int must match []E of the constraint, a compiler can infer that E must be int. Thus, for these two equations, type inference infers</p>
</blockquote>
<p>现在可以求解类型参数 S 和 E .<br/>
由（1） ，编译器可以推断 S 的类型实参为 Slice 。<br/>
同样，由于 Slice 的基础类型是 []int ，且 []int 必须与约束 []E 相匹配，因此编译器可以推断出 E 必须为 int 。<br/>
因此，对于这两个方程，类型推断就推断出</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">	S ➞ Slice</span></span>
<span class="line"><span style="color:#babed8">	E ➞ int</span></span></code></pre>
<blockquote>
<p>Given a set of type equations, the type parameters to solve for are the type parameters of the functions that need to be instantiated and for which no explicit type arguments is provided. These type parameters are called bound type parameters. For instance, in the dedup example above, the type parameters P and E are bound to dedup. An argument to a generic function call may be a generic function itself. The type parameters of that function are included in the set of bound type parameters. The types of function arguments may contain type parameters from other functions (such as a generic function enclosing a function call). Those type parameters may also appear in type equations but they are not bound in that context. Type equations are always solved for the bound type parameters only.</p>
</blockquote>
<p>给定一组类型方程，要求解的类型参数是需要实例化的函数的类型参数，并且没有为其提供显式类型的参数。<br/>
这些类型参数就称为绑定类型参数。<br/>
例如，在上面的 dedup 示例（往前面找，“For example, given” “例如，给定”那一小节）中，类型参数 P 和 E 绑定到 dedup .<br/>
泛型函数调用的参数可以是泛型函数本身。<br/>
该函数的类型形参包含在绑定类型参数集中。<br/>
函数实参的类型可能包含来自其他函数的类型形参（例如包含函数调用的泛型函数）。<br/>
这些类型形参也可能出现在类型方程中，但它们在该上下文中不受约束。<br/>
类型方程始终仅是针对绑定类型参数求解。</p>
<blockquote>
<p>Type inference supports calls of generic functions and assignments of generic functions to (explicitly function-typed) variables. This includes passing generic functions as arguments to other (possibly also generic) functions, and returning generic functions as results. Type inference operates on a set of equations specific to each of these cases. The equations are as follows (type argument lists are omitted for clarity):</p>
</blockquote>
<p>类型推断支持对泛型函数的调用，和将泛型函数赋值到（显式函数类型）变量。<br/>
这包括将泛型函数作为实参传递给其他（可能也是泛型的）函数，以及将泛型函数作为结果返回。<br/>
类型推断对特定于每种情形的一组方程进行运算。<br/>
公式如下（为清晰起见，省略了类型实参列表）：</p>
<blockquote>
<ul>
<li>For a function call f(a_0, a_1, …) where f or a function argument ai is a generic function:</li>
</ul>
</blockquote>
<p>对于函数调用 <code>f(a_0, a_1, …)</code> ，其中 f 或函数参数 a_i 是泛型函数：</p>
<blockquote>
<p>Each pair (a_i, p_i) of corresponding function arguments and parameters where ai is not an untyped constant yields an equation typeof(p_i) ≡A typeof(a_i).</p>
</blockquote>
<p>每对 (a_i, p_i) 对应的函数实参和形参，其中不是无类型常量的 a_i，都会产生一个方程 <code>typeof(p_i) ≡A typeof(a_i)</code> 。</p>
<blockquote>
<p>If a_i is an untyped constant c_j, and typeof(pi) is a bound type parameter P_k, the pair (c_j, P_k) is collected separately from the type equations.</p>
</blockquote>
<p>如果 a_i 是一个无类型常量 c_j ，并且 typeof(pi) 是一个绑定类型形参 P_k ，则数对 (c_j, P_k) 与类型方程分开收集。</p>
<blockquote>
<ul>
<li>For an assignment v = f of a generic function f to a (non-generic) variable v of function type:</li>
</ul>
</blockquote>
<p>对于泛型函数 f 的赋值 <code>v = f</code> 到函数类型一个（非泛型的）变量 v ：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">typeof(v) ≡A typeof(f).   typeof(v) ≡A typeof(f) .</span></span></code></pre>
<blockquote>
<ul>
<li>For a return statement return …, f, … where f is a generic function returned as a result to a (non-generic) result variable r of function type:</li>
</ul>
</blockquote>
<p>对于 return 语句 <code>return …, f, …</code> ，其中 f 是作为结果返回给函数类型的（非泛型）结果变量 r 的泛型函数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">typeof(r) ≡A typeof(f).   typeof(r) ≡A typeof(f) .</span></span></code></pre>
<blockquote>
<p>Additionally, each type parameter P_k and corresponding type constraint C_k yields the type equation Pk ≡C Ck.</p>
</blockquote>
<p>此外，每个类型参数 P_k 和相应的类型约束 C_k 都会生成类型方程 <code>Pk ≡C Ck</code> 。</p>
<blockquote>
<p>Type inference gives precedence to type information obtained from typed operands before considering untyped constants. Therefore, inference proceeds in two phases:</p>
</blockquote>
<p>类型推断在考虑无类型常量之前，会优先从类型操作数获取类型信息。<br/>
因此，推理分两个阶段进行：</p>
<blockquote>
<ol>
<li>The type equations are solved for the bound type parameters using type unification. If unification fails, type inference fails.</li>
</ol>
</blockquote>
<p>使用类型统一求解绑定类型参数的类型方程。如果统一失败，则类型推断失败。</p>
<blockquote>
<ol start="2">
<li>For each bound type parameter P_k for which no type argument has been inferred yet and for which one or more pairs (c_j, P_k) with that same type parameter were collected, determine the constant kind of the constants c_j in all those pairs the same way as for constant expressions. The type argument for P_k is the default type for the determined constant kind. If a constant kind cannot be determined due to conflicting constant kinds, type inference fails.</li>
</ol>
</blockquote>
<p>对于尚未推断类型实参，且收集了具有相同类型形参的一个或多个数对 (c_j, p_k) 的每个绑定类型参数 P_k ，请以与常量表达式相同的方式，确定所有这些数对中常量 c_j 的常量类型。<br/>
P_k 的类型实参是取决于常量种类。<br/>
如果由于常量种类冲突而无法确定常量类型，则类型推断将失败。</p>
<blockquote>
<p>If not all type arguments have been found after these two phases, type inference fails.</p>
</blockquote>
<p>如果在这两个阶段之后没有找到所有类型实参，则类型推断将失败。</p>
<blockquote>
<p>If the two phases are successful, type inference determined a type argument for each bound type parameter:</p>
</blockquote>
<p>如果这两个阶段成功，则类型推断为每个绑定类型参数确定一个类型形参：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">	Pk ➞ Ak</span></span></code></pre>
<blockquote>
<p>A type argument A_k may be a composite type, containing other bound type parameters Pk as element types (or even be just another bound type parameter). In a process of repeated simplification, the bound type parameters in each type argument are substituted with the respective type arguments for those type parameters until each type argument is free of bound type parameters.</p>
</blockquote>
<p>类型实参 A_k 可以是复合类型，包含其他绑定类型形参 P_k 作为元素类型（甚至只是另一个绑定类型实参）。<br/>
在重复简化的过程中，每个类型形参中的绑定类型形参将替换为这些类型形参的相应类型参数，直到每个类型参数都不再被类型形参所绑定。</p>
<blockquote>
<p>If type arguments contain cyclic references to themselves through bound type parameters, simplification and thus type inference fails. Otherwise, type inference succeeds.</p>
</blockquote>
<p>如果类型实参通过绑定类型形参包含了对自身的循环引用，则简化和类型推断将会失败。<br/>
否则，类型推断将会成功。</p>
<h4 id="type-unification-类型统一">Type unification 类型统一</h4>
<blockquote>
<p>Type inference solves type equations through type unification. Type unification recursively compares the LHS and RHS types of an equation, where either or both types may be or contain bound type parameters, and looks for type arguments for those type parameters such that the LHS and RHS match (become identical or assignment-compatible, depending on context). To that effect, type inference maintains a map of bound type parameters to inferred type arguments; this map is consulted and updated during type unification. Initially, the bound type parameters are known but the map is empty. During type unification, if a new type argument A is inferred, the respective mapping P ➞ A from type parameter to argument is added to the map. Conversely, when comparing types, a known type argument (a type argument for which a map entry already exists) takes the place of its corresponding type parameter. As type inference progresses, the map is populated more and more until all equations have been considered, or until unification fails. Type inference succeeds if no unification step fails and the map has an entry for each type parameter.</p>
</blockquote>
<p>类型推断通过类型统一求解类型方程。<br/>
类型统一递归地比较方程的 LHS 和 RHS 类型，其中一个或两个类型可能<strong>是</strong>或<strong>包含</strong>绑定类型参数，并查找这些类型形参的类型实参，以便 LHS 和 RHS 相匹配（根据上下文变得相同或赋值兼容）。<br/>
为此，类型推断维护了绑定类型形参到推断类型实参的映射；<br/>
在类型统一期间，会查阅和更新这个映射。<br/>
起初，绑定类型参数是已知的，但映射为空。<br/>
在类型统一期间，如果推断出新的类型实参 A ，则会将类型形参到实参的相应映射 <code>P ➞ A</code> 添加到映射中。<br/>
相反，在比较类型时，已知类型实参（映射条目对应的类型实参已存在）将代替其相应的类型形参。<br/>
随着类型推断的进行，映射逐渐被填充，直到考虑了所有方程，或者直到统一失败。<br/>
如果没有统一步骤失败，并且映射具有每个类型形参的条目，则类型推断就成功。</p>
<blockquote>
<p>For example, given the type equation with the bound type parameter P</p>
</blockquote>
<p>例如，给定具有绑定类型形参 P 的类型方程</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">	[10]struct{ elem P, list []P } ≡A [10]struct{ elem string; list []string }</span></span></code></pre>
<blockquote>
<p>type inference starts with an empty map. Unification first compares the top-level structure of the LHS and RHS types. Both are arrays of the same length; they unify if the element types unify. Both element types are structs; they unify if they have the same number of fields with the same names and if the field types unify. The type argument for P is not known yet (there is no map entry), so unifying P with string adds the mapping P ➞ string to the map. Unifying the types of the list field requires unifying []P and []string and thus P and string. Since the type argument for P is known at this point (there is a map entry for P), its type argument string takes the place of P. And since string is identical to string, this unification step succeeds as well. Unification of the LHS and RHS of the equation is now finished. Type inference succeeds because there is only one type equation, no unification step failed, and the map is fully populated.</p>
</blockquote>
<p>类型推断从空映射开始。<br/>
统一首先比较 LHS 和 RHS 类型的顶层结构。<br/>
两者都是相同长度的数组；<br/>
如果元素类型统一，它们就会统一。<br/>
两种元素类型都是结构体；<br/>
如果它们具有相同数量的同名字段，并且字段类型统一，则它们将统一。<br/>
P 的类型实参仍然未知（没有映射条目），因此统一带有字符串的 P 会将映射 P ➞ string 添加到映射中。<br/>
统一 list 字段的类型需要统一 []P 和 []string 也就是 P 和 string 。<br/>
由于 P 的类型实参此时是已知的（有一个映射条目 P ），因此其类型实参 string 将取代 P 。<br/>
并且由于 string 与 string 相同，因此这个统一步骤也成功。<br/>
方程的LHS和RHS的统一现在已经完成。<br/>
类型推断成功是因为只有一个类型方程，没有统一步骤失败，并且映射已完全填充。</p>
<blockquote>
<p>Unification uses a combination of exact and loose unification depending on whether two types have to be identical, assignment-compatible, or only structurally equal. The respective type unification rules are spelled out in detail in the Appendix.</p>
</blockquote>
<p>统一使用精确统一和松散统一的组合，具体取决于两种类型是必须要相同 / 赋值兼容还是仅在结构上相等。<br/>
附录中详细说明了相应的类型统一规则。</p>
<blockquote>
<p>For an equation of the form X ≡A Y, where X and Y are types involved in an assignment (including parameter passing and return statements), the top-level type structures may unify loosely but element types must unify exactly, matching the rules for assignments.</p>
</blockquote>
<p>对于形如 <code>X ≡A Y</code> 的方程，其中 X 和 Y 是赋值中涉及的类型（包括参数传递和返回语句），顶级类型结构可以松散地统一，但元素类型必须完全统一，与赋值的规则相匹配。</p>
<blockquote>
<p>For an equation of the form P ≡C C, where P is a type parameter and C its corresponding constraint, the unification rules are bit more complicated:</p>
</blockquote>
<p>对于形如 <code>P ≡C C</code> 的方程，其中 P 是类型形参且 C 的相应约束，统一规则稍微复杂一些：</p>
<blockquote>
<ul>
<li>If C has a core type core(C) and P has a known type argument A, core(C) and A must unify loosely. If P does not have a known type argument and C contains exactly one type term T that is not an underlying (tilde) type, unification adds the mapping P ➞ T to the map.</li>
</ul>
</blockquote>
<p>如果 C 有一个核心类型并且有一个已知的类型实参 A，且 core(C) 与 A 必须松散地统一。<br/>
如果 P 没有已知的类型实参，并且 C 有且只有一个不是基础（波浪号）类型的类型项 T ，则统一会将映射 P ➞ T 添加到映射中。</p>
<blockquote>
<ul>
<li>If C does not have a core type and P has a known type argument A, A must have all methods of C, if any, and corresponding method types must unify exactly.</li>
</ul>
</blockquote>
<p>如果 C 没有核心类型，并且 P 具有已知的类型实参 A ，则 A 必须具有 C 的所有方法（如果 C 有方法的话），并且相应的方法类型必须完全统一。</p>
<blockquote>
<p>When solving type equations from type constraints, solving one equation may infer additional type arguments, which in turn may enable solving other equations that depend on those type arguments. Type inference repeats type unification as long as new type arguments are inferred.</p>
</blockquote>
<p>在从类型约束求解类型方程时，求解一个方程可能会推断出其他类型实参，这反过来又可以求解依赖于这些类型实参的其他方程。<br/>
只要推断出新的类型参数，类型推断就会重复类型统一过程。</p>
<h3 id="operators-运算符">Operators 运算符</h3>
<blockquote>
<p>Operators combine operands into expressions.</p>
</blockquote>
<p>运算符将操作数组合到表达式中。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Expression = UnaryExpr | Expression binary_op Expression .</span></span>
<span class="line"><span style="color:#babed8">UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">binary_op  = &quot;||&quot; | &quot;&amp;&amp;&quot; | rel_op | add_op | mul_op .</span></span>
<span class="line"><span style="color:#babed8">rel_op     = &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .</span></span>
<span class="line"><span style="color:#babed8">add_op     = &quot;+&quot; | &quot;-&quot; | &quot;|&quot; | &quot;^&quot; .</span></span>
<span class="line"><span style="color:#babed8">mul_op     = &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&amp;&quot; | &quot;&amp;^&quot; .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">unary_op   = &quot;+&quot; | &quot;-&quot; | &quot;!&quot; | &quot;^&quot; | &quot;*&quot; | &quot;&amp;&quot; | &quot;&lt;-&quot; .</span></span></code></pre>
<blockquote>
<p>Comparisons are discussed elsewhere. For other binary operators, the operand types must be identical unless the operation involves shifts or untyped constants. For operations involving constants only, see the section on constant expressions.</p>
</blockquote>
<p>比较（运算的内容）详见其他专题。<br/>
对于其他二元运算符，操作数类型必须相同，除非操作涉及移位或无类型常量。<br/>
有关仅涉及常量的操作，请参阅常量表达式部分。</p>
<blockquote>
<p>Except for shift operations, if one operand is an untyped constant and the other operand is not, the constant is implicitly converted to the type of the other operand.</p>
</blockquote>
<p>除移位操作之外，如果一个操作数是无类型常量，而另一个操作数不是，则该（无类型）常量将隐式转换为另一个操作数的类型。</p>
<blockquote>
<p>The right operand in a shift expression must have integer type or be an untyped constant representable by a value of type uint. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.</p>
</blockquote>
<p>移位表达式中的右操作数必须具有整数类型，或者是可由 uint 类型的值表示的无类型常量。<br/>
如果非常量的移位表达式的左操作数是无类型常量，则首先将其隐式转换为当移位表达式仅由其左操作数替换时所假定的类型。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a [1024]byte</span></span>
<span class="line"><span style="color:#babed8">var s uint = 33</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// The results of the following examples are given for 64-bit ints.</span></span>
<span class="line"><span style="color:#babed8">var i = 1&lt;&lt;s                   // 1 has type int</span></span>
<span class="line"><span style="color:#babed8">var j int32 = 1&lt;&lt;s             // 1 has type int32; j == 0</span></span>
<span class="line"><span style="color:#babed8">var k = uint64(1&lt;&lt;s)           // 1 has type uint64; k == 1&lt;&lt;33</span></span>
<span class="line"><span style="color:#babed8">var m int = 1.0&lt;&lt;s             // 1.0 has type int; m == 1&lt;&lt;33</span></span>
<span class="line"><span style="color:#babed8">var n = 1.0&lt;&lt;s == j            // 1.0 has type int32; n == true</span></span>
<span class="line"><span style="color:#babed8">var o = 1&lt;&lt;s == 2&lt;&lt;s           // 1 and 2 have type int; o == false</span></span>
<span class="line"><span style="color:#babed8">var p = 1&lt;&lt;s == 1&lt;&lt;33          // 1 has type int; p == true</span></span>
<span class="line"><span style="color:#babed8">var u = 1.0&lt;&lt;s                 // illegal: 1.0 has type float64, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var u1 = 1.0&lt;&lt;s != 0           // illegal: 1.0 has type float64, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var u2 = 1&lt;&lt;s != 1.0           // illegal: 1 has type float64, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var v1 float32 = 1&lt;&lt;s          // illegal: 1 has type float32, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var v2 = string(1&lt;&lt;s)          // illegal: 1 is converted to a string, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var w int64 = 1.0&lt;&lt;33          // 1.0&lt;&lt;33 is a constant shift expression; w == 1&lt;&lt;33</span></span>
<span class="line"><span style="color:#babed8">var x = a[1.0&lt;&lt;s]              // panics: 1.0 has type int, but 1&lt;&lt;33 overflows array bounds</span></span>
<span class="line"><span style="color:#babed8">var b = make([]byte, 1.0&lt;&lt;s)   // 1.0 has type int; len(b) == 1&lt;&lt;33</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// The results of the following examples are given for 32-bit ints,</span></span>
<span class="line"><span style="color:#babed8">// which means the shifts will overflow.</span></span>
<span class="line"><span style="color:#babed8">var mm int = 1.0&lt;&lt;s            // 1.0 has type int; mm == 0</span></span>
<span class="line"><span style="color:#babed8">var oo = 1&lt;&lt;s == 2&lt;&lt;s          // 1 and 2 have type int; oo == true</span></span>
<span class="line"><span style="color:#babed8">var pp = 1&lt;&lt;s == 1&lt;&lt;33         // illegal: 1 has type int, but 1&lt;&lt;33 overflows int</span></span>
<span class="line"><span style="color:#babed8">var xx = a[1.0&lt;&lt;s]             // 1.0 has type int; xx == a[0]</span></span>
<span class="line"><span style="color:#babed8">var bb = make([]byte, 1.0&lt;&lt;s)  // 1.0 has type int; len(bb) == 0</span></span></code></pre>
<h4 id="operator-precedence-运算符优先级">Operator precedence 运算符优先级</h4>
<blockquote>
<p>Unary operators have the highest precedence. As the ++ and — operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement *p++ is the same as (*p)++.</p>
</blockquote>
<p>一元运算符具有最高优先级。由于 ++ 和 — 运算符形成的是语句而不是表达式，因此它们不属于运算符体系。因此，语句 <code>*p++</code> 相当于 <code>(*p)++</code> 。</p>
<blockquote>
<p>There are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, &amp;&amp; (logical AND), and finally || (logical OR):</p>
</blockquote>
<p>二元运算符有五个优先级。乘法运算符优先级最高，其次是加法运算符、比较运算符、 &amp;&amp; （逻辑与），最后是 || （逻辑或）：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Precedence    Operator</span></span>
<span class="line"><span style="color:#babed8">    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^</span></span>
<span class="line"><span style="color:#babed8">    4             +  -  |  ^</span></span>
<span class="line"><span style="color:#babed8">    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=</span></span>
<span class="line"><span style="color:#babed8">    2             &amp;&amp;</span></span>
<span class="line"><span style="color:#babed8">    1             ||</span></span></code></pre>
<blockquote>
<p>Binary operators of the same precedence associate from left to right. For instance, x / y * z is the same as (x / y) * z.</p>
</blockquote>
<p>具有相同优先级的二元运算符从左到右结合。例如， <code>x / y * z</code> 相当于 <code>(x / y) * z</code> 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">+x</span></span>
<span class="line"><span style="color:#babed8">23 + 3*x[i]</span></span>
<span class="line"><span style="color:#babed8">x &lt;= f()</span></span>
<span class="line"><span style="color:#babed8">^a &gt;&gt; b</span></span>
<span class="line"><span style="color:#babed8">f() || g()</span></span>
<span class="line"><span style="color:#babed8">x == y+1 &amp;&amp; &lt;-chanInt &gt; 0</span></span></code></pre>
<h3 id="arithmetic-operators-算术运算符">Arithmetic operators 算术运算符</h3>
<blockquote>
<p>Arithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators (+, -, *, /) apply to integer, floating-point, and complex types; + also applies to strings. The bitwise logical and shift operators apply to integers only.</p>
</blockquote>
<p>算术运算符应用于数值，并生成与第一个操作数类型相同的结果。四个标准算术运算符 <code>+ - * /</code> 适用于整数、浮点和复数类型;<br/>
<code>+</code> 也适用于字符串。<br/>
按位逻辑运算符和移位运算符仅适用于整数。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">+    sum                    integers, floats, complex values, strings</span></span>
<span class="line"><span style="color:#babed8">-    difference             integers, floats, complex values</span></span>
<span class="line"><span style="color:#babed8">*    product                integers, floats, complex values</span></span>
<span class="line"><span style="color:#babed8">/    quotient               integers, floats, complex values</span></span>
<span class="line"><span style="color:#babed8">%    remainder              integers</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">&amp;    bitwise AND            integers</span></span>
<span class="line"><span style="color:#babed8">|    bitwise OR             integers</span></span>
<span class="line"><span style="color:#babed8">^    bitwise XOR            integers</span></span>
<span class="line"><span style="color:#babed8">&amp;^   bit clear (AND NOT)    integers</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">&lt;&lt;   left shift             integer &lt;&lt; integer &gt;= 0</span></span>
<span class="line"><span style="color:#babed8">&gt;&gt;   right shift            integer &gt;&gt; integer &gt;= 0</span></span></code></pre>
<blockquote>
<p>If the operand type is a type parameter, the operator must apply to each type in that type set. The operands are represented as values of the type argument that the type parameter is instantiated with, and the operation is computed with the precision of that type argument. For example, given the function:</p>
</blockquote>
<p>如果操作数类型是类型参数，那么运算符必须适用于该类型集中的每个类型。<br/>
操作数表示为实例化时所用的类型参数对应的类型实参的值，并且操作是基于类型实参的精度来计算的。<br/>
例如，给定函数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func dotProduct[F ~float32|~float64](v1, v2 []F) F {</span></span>
<span class="line"><span style="color:#babed8">	var s F</span></span>
<span class="line"><span style="color:#babed8">	for i, x := range v1 {</span></span>
<span class="line"><span style="color:#babed8">		y := v2[i]</span></span>
<span class="line"><span style="color:#babed8">		s += x * y</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">	return s</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>the product x * y and the addition s += x * y are computed with float32 or float64 precision, respectively, depending on the type argument for F.</p>
</blockquote>
<p>乘积 <code>x * y</code> 和加法 <code>s += x * y</code> 分别以按照 float32 或 float64 精度计算，具体取决于 F 的参数类型。</p>
<h4 id="integer-operators">Integer operators</h4>
<blockquote>
<p>For two integer values x and y, the integer quotient q = x / y and remainder r = x % y satisfy the following relationships:</p>
</blockquote>
<p>对于两个整数值 x 和 y ，整数商 <code>q = x / y</code> 和余数 <code>r = x % y</code> 满足以下关系：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x = q*y + r  and  |r| &lt; |y|</span></span></code></pre>
<blockquote>
<p>with x / y truncated towards zero (“truncated division”).</p>
</blockquote>
<p><code>x / y</code> 截断为零（“截断除法”）。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8"> x     y     x / y     x % y</span></span>
<span class="line"><span style="color:#babed8"> 5     3       1         2</span></span>
<span class="line"><span style="color:#babed8">-5     3      -1        -2</span></span>
<span class="line"><span style="color:#babed8"> 5    -3      -1         2</span></span>
<span class="line"><span style="color:#babed8">-5    -3       1        -2</span></span></code></pre>
<blockquote>
<p>The one exception to this rule is that if the dividend x is the most negative value for the int type of x, the quotient q = x / -1 is equal to x (and r = 0) due to two’s-complement integer overflow:</p>
</blockquote>
<p>此规则的一个例外是，如果除数 x 是 x 的 int 类型的最大负值，则由于二进制补码整数溢出，商 <code>q = x / -1</code> 等于 <code>x</code> （且 r = 0 ）：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">                         x, q</span></span>
<span class="line"><span style="color:#babed8">int8                     -128</span></span>
<span class="line"><span style="color:#babed8">int16                  -32768</span></span>
<span class="line"><span style="color:#babed8">int32             -2147483648</span></span>
<span class="line"><span style="color:#babed8">int64    -9223372036854775808</span></span></code></pre>
<blockquote>
<p>If the divisor is a constant, it must not be zero. If the divisor is zero at run time, a run-time panic occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:</p>
</blockquote>
<p>如果除数是常数，则不得为零。<br/>
如果除数在运行时为零，则会发生运行时 panic 。<br/>
如果除数是非负的，并且除数是 2 的常数幂，则除法可以用右移代替，计算余数可以用按位与运算代替：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8"> x     x / 4     x % 4     x &gt;&gt; 2     x &amp; 3</span></span>
<span class="line"><span style="color:#babed8"> 11      2         3         2          3</span></span>
<span class="line"><span style="color:#babed8">-11     -2        -3        -3          1</span></span></code></pre>
<blockquote>
<p>The shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a run-time panic occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted n times by 1 for a shift count of n. As a result, <code>x &lt;&lt; 1</code> is the same as <code>x*2</code> and <code>x &gt;&gt; 1</code> is the same as <code>x/2</code> but truncated towards negative infinity.</p>
</blockquote>
<p>移位运算符按右操作数指定的移位计数，对左操作数进行移位，计数必须为非负数。<br/>
如果在运行时，移位计数为负数，就会发生运行时 panic 。<br/>
如果左操作数是有符号整数，移位运算符实现算术移位; 如果是无符号整数，则实现逻辑移位。<br/>
移位计数没有上限。<br/>
对于计数为 n 的移位的行为，就像是左操作数以 1 的粒度移位 n 次。<br/>
结果， <code>x &lt;&lt; 1</code> 与 <code>x*2</code> 相同， <code>x &gt;&gt; 1</code> 与 <code>x/2</code> 相同但截断为负无穷大。</p>
<blockquote>
<p>For integer operands, the unary operators +, -, and ^ are defined as follows:</p>
</blockquote>
<p>对于整数操作数，一元运算符 <code>+ - ^</code> 的定义如下：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">+x                          is 0 + x</span></span>
<span class="line"><span style="color:#babed8">-x    negation              is 0 - x</span></span>
<span class="line"><span style="color:#babed8">^x    bitwise complement    is m ^ x  with m = &quot;all bits set to 1&quot; for unsigned x</span></span>
<span class="line"><span style="color:#babed8">                                      and  m = -1 for signed x</span></span></code></pre>
<h4 id="integer-overflow-整数溢出">Integer overflow 整数溢出</h4>
<blockquote>
<p>For unsigned integer values, the operations <code>+, -, *, and &lt;&lt;</code> are computed modulo <code>2^n</code>, where n is the bit width of the unsigned integer’s type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on “wrap around”.</p>
</blockquote>
<p>对于无符号整数值，运算 <code>+ - * &lt;&lt;</code> 是做模 <code>2^n</code> 运算，其中 n 是无符号整数类型的位宽。<br/>
粗略地说，这些无符号整数操作在溢出时会丢弃高位，程序可能依赖于“回环”（现象）。</p>
<p><em>这里所说的”wrap around”是一种现象，比如两个很大的正数相加，结果却是负数。</em></p>
<blockquote>
<p>For signed integers, the operations <code>+, -, *, /, and &lt;&lt;</code> may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a run-time panic. A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that <code>x &lt; x + 1</code> is always true.</p>
</blockquote>
<p>对于有符号整数，操作 <code>+ - * / &lt;&lt;</code> 可能会合法溢出，并且结果值存在，并由有符号整数的表示来确切定义。<br/>
溢出并不会导致运行时 panic 。<br/>
编译器在不会发生溢出的假定下并不会优化代码。例如，它不会假定 <code>x &lt; x + 1</code> 总是为 <code>true</code> 。</p>
<h4 id="floating-point-operators-浮点运算符">Floating-point operators 浮点运算符</h4>
<blockquote>
<p>For floating-point and complex numbers, +x is the same as x, while -x is the negation of x. The result of a floating-point or complex division by zero is not specified beyond the IEEE-754 standard; whether a run-time panic occurs is implementation-specific.</p>
</blockquote>
<p>对于浮点数和复数， <code>+x</code> 与 <code>x</code> 是相同的，而 <code>-x</code> 是 <code>x</code> 的取反。<br/>
浮点或复数除以零的结果，在 IEEE-754 标准之外并不是确定的（实现）；<br/>
是否发生运行时 panic 取决于具体实现。</p>
<blockquote>
<p>An implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit floating-point type conversion rounds to the precision of the target type, preventing fusion that would discard that rounding.</p>
</blockquote>
<p>实现可以将多个浮点运算组合成单个融合运算（可能跨语句），并产生与单独执行和舍入指令所获得的值不同的结果。显式浮点类型转换将舍入到目标类型的精度，从而防止合并会丢弃该舍入。</p>
<blockquote>
<p>For instance, some architectures provide a “fused multiply and add” (FMA) instruction that computes <code>x*y + z</code> without rounding the intermediate result <code>x*y</code> . These examples show when a Go implementation can use that instruction:</p>
</blockquote>
<p>例如，一些体系结构提供“融合乘加”（FMA）指令，该指令在不舍入中间结果 <code>x*y</code> 的情况下计算 <code>x*y + z</code> 。<br/>
这些示例展示了 Go 实现（的代码）何时可以使用该指令：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">// FMA allowed for computing r, because x*y is not explicitly rounded:</span></span>
<span class="line"><span style="color:#babed8">r  = x*y + z</span></span>
<span class="line"><span style="color:#babed8">r  = z;   r += x*y</span></span>
<span class="line"><span style="color:#babed8">t  = x*y; r = t + z</span></span>
<span class="line"><span style="color:#babed8">*p = x*y; r = *p + z</span></span>
<span class="line"><span style="color:#babed8">r  = x*y + float64(z)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// FMA disallowed for computing r, because it would omit rounding of x*y:</span></span>
<span class="line"><span style="color:#babed8">r  = float64(x*y) + z</span></span>
<span class="line"><span style="color:#babed8">r  = z; r += float64(x*y)</span></span>
<span class="line"><span style="color:#babed8">t  = float64(x*y); r = t + z</span></span></code></pre>
<h4 id="string-concatenation-字符串连接">String concatenation 字符串连接</h4>
<blockquote>
<p>Strings can be concatenated using the <code>+</code> operator or the <code>+=</code> assignment operator:</p>
</blockquote>
<p>可以使用 <code>+</code> 运算符或 <code>+=</code> 赋值运算符来连接字符串：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s := &quot;hi&quot; + string(c)</span></span>
<span class="line"><span style="color:#babed8">s += &quot; and good bye&quot;</span></span></code></pre>
<blockquote>
<p>String addition creates a new string by concatenating the operands.</p>
</blockquote>
<p>字符串的追加，会通过连接操作创建出一个新的字符串。</p>
<h3 id="comparison-operators-比较运算符">Comparison operators 比较运算符</h3>
<blockquote>
<p>Comparison operators compare two operands and yield an untyped boolean value.</p>
</blockquote>
<p>比较运算符将两个操作数比较，并生成一个无类型的布尔值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">==    equal</span></span>
<span class="line"><span style="color:#babed8">!=    not equal</span></span>
<span class="line"><span style="color:#babed8">&lt;     less</span></span>
<span class="line"><span style="color:#babed8">&lt;=    less or equal</span></span>
<span class="line"><span style="color:#babed8">&gt;     greater</span></span>
<span class="line"><span style="color:#babed8">&gt;=    greater or equal</span></span></code></pre>
<blockquote>
<p>In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.</p>
</blockquote>
<p>在任何比较中，第一个操作数都必须是可分配给第二个操作数的类型，反之亦然。</p>
<blockquote>
<p>The equality operators == and != apply to operands of comparable types. The ordering operators <code>&lt;, &lt;=, &gt;, and &gt;=</code> apply to operands of ordered types. These terms and the result of the comparisons are defined as follows:</p>
</blockquote>
<p>相等运算符 == 和 != 适用于可比较类型的操作数。<br/>
排序运算符 <code>&lt; , &lt;= , &gt; 和 &gt;=</code> 适用于有序类型的操作数。<br/>
这些项和比较的结果，定义如下：</p>
<blockquote>
<ul>
<li>Boolean types are comparable. Two boolean values are equal if they are either both true or both false.</li>
</ul>
</blockquote>
<p>布尔类型是可比较的。如果两个布尔值都为 true 或者都为 false ，那它们就是相等的。</p>
<blockquote>
<ul>
<li>Integer types are comparable and ordered. Two integer values are compared in the usual way.</li>
</ul>
</blockquote>
<p>整数类型是可比较的、可排序的。两个整数就像通常的方式那样去比较。</p>
<blockquote>
<ul>
<li>Floating-point types are comparable and ordered. Two floating-point values are compared as defined by the IEEE-754 standard.</li>
</ul>
</blockquote>
<p>浮点类型是可比较的、可排序的。两个浮点数的比较方式是根据 IEEE-754 的定义来的。</p>
<blockquote>
<ul>
<li>Complex types are comparable. Two complex values u and v are equal if both real(u) == real(v) and imag(u) == imag(v).</li>
</ul>
</blockquote>
<p>复数类型是可比较的。如果两个复数值 u 和 v 的实部相等且虚部也相等，那么 u 和 v 就是相等的。</p>
<blockquote>
<ul>
<li>String types are comparable and ordered. Two string values are compared lexically byte-wise.</li>
</ul>
</blockquote>
<p>字符串类型是可比较的、可排序的。两个字符串的值是逐个字节、按照文法来比较的。</p>
<blockquote>
<ul>
<li>Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value nil. Pointers to distinct zero-size variables may or may not be equal.</li>
</ul>
</blockquote>
<p>指针类型是可比较的。如果两个指针值指向同一变量或两个指针值都有值 nil ，那么这两个指针是相等的。指向不同的零大小的变量的指针，可能相等，也可能不相等。</p>
<blockquote>
<ul>
<li>Channel types are comparable. Two channel values are equal if they were created by the same call to make or if both have value nil.</li>
</ul>
</blockquote>
<p>通道类型是可比较的。如果两个通道值是由同一个 make 调用创建的，或者两个通道值都有值 nil ，那么这两个通道值是相等的。</p>
<blockquote>
<ul>
<li>Interface types that are not type parameters are comparable. Two interface values are equal if they have identical dynamic types and equal dynamic values or if both have value nil.</li>
</ul>
</blockquote>
<p>不是作为类型参数的接口类型，是可比较的。如果两个接口值具有相同的动态类型和相等的动态值，或者两个接口值都具有值 nil ，那么这两个接口值是相等的。</p>
<blockquote>
<ul>
<li>A value x of non-interface type X and a value t of interface type T can be compared if type X is comparable and X implements T. They are equal if t’s dynamic type is identical to X and t’s dynamic value is equal to x.</li>
</ul>
</blockquote>
<p>如果类型 X 是可比较的且 X 实现了接口 T ，那么非接口类型 X 的值 x 和接口类型的 T 的值 t 是可比较的。如果 t 的动态类型与 X 相同，且 t 的动态值等于 x ，那么 x 与 t 相等。</p>
<blockquote>
<ul>
<li>Struct types are comparable if all their field types are comparable. Two struct values are equal if their corresponding non-blank field values are equal. The fields are compared in source order, and comparison stops as soon as two field values differ (or all fields have been compared).</li>
</ul>
</blockquote>
<p>如果结构体类型的所有字段类型都是可比较的，那么结构体类型是可比较的。如果两个结构体值对应的非空字段值都是相等的，那么两个结构体就相等。字段是按源代码顺序比较的，一旦两个字段值不同（或已经比较完了所有字段），比较就会停止。</p>
<blockquote>
<ul>
<li>Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal. The elements are compared in ascending index order, and comparison stops as soon as two element values differ (or all elements have been compared).</li>
</ul>
</blockquote>
<p>如果数组元素类型是可比较的，那么数组类型是可比较的。如果两个数组元素对应的值相等，那么两个数组就相等。元素按索引升序顺序进行比较，一旦发现两个元素值不同（或已经比较完了所有元素），比较就会停止。</p>
<blockquote>
<ul>
<li>Type parameters are comparable if they are strictly comparable (see below).</li>
</ul>
</blockquote>
<p>如果类型参数是严格可比较的，那么它们就是可比较的（见下文）。</p>
<blockquote>
<p>A comparison of two interface values with identical dynamic types causes a run-time panic if that type is not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.</p>
</blockquote>
<p>如果将两个带有完全相同的动态类型、但是类型不可比较的接口值进行比较，会引起运行时 panic.<br/>
这个行为不仅适用于接口值的直接比较，也适用于与接口值的数组或带接口值字段的结构体比较时。</p>
<blockquote>
<p>Slice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier nil. Comparison of pointer, channel, and interface values to nil is also allowed and follows from the general rules above.</p>
</blockquote>
<p>切片， map 和函数类型是不可比较的。<br/>
但是，有一些特例，一个切片， map 和函数值可以和预先声明的标识符 nil 比较。<br/>
将指针、通道和接口值与 nil 比较也是允许的，它们也同样遵循上面的一般规则。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const c = 3 &lt; 4            // c is the untyped boolean constant true</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type MyBool bool</span></span>
<span class="line"><span style="color:#babed8">var x, y int</span></span>
<span class="line"><span style="color:#babed8">var (</span></span>
<span class="line"><span style="color:#babed8">	// The result of a comparison is an untyped boolean.</span></span>
<span class="line"><span style="color:#babed8">	// The usual assignment rules apply.</span></span>
<span class="line"><span style="color:#babed8">	b3        = x == y // b3 has type bool</span></span>
<span class="line"><span style="color:#babed8">	b4 bool   = x == y // b4 has type bool</span></span>
<span class="line"><span style="color:#babed8">	b5 MyBool = x == y // b5 has type MyBool</span></span>
<span class="line"><span style="color:#babed8">)</span></span></code></pre>
<blockquote>
<p>A type is strictly comparable if it is comparable and not an interface type nor composed of interface types. Specifically:</p>
</blockquote>
<p>如果一个类型是可比较的，且不是一个接口类型，也不是接口类型的组合，那么就称这个类型是严格可比较的。比如：</p>
<blockquote>
<ul>
<li>Boolean, numeric, string, pointer, and channel types are strictly comparable.</li>
</ul>
</blockquote>
<p>布尔、数值、字符串、指针和通道类型都是严格可比较类型。</p>
<blockquote>
<ul>
<li>Struct types are strictly comparable if all their field types are strictly comparable.</li>
</ul>
</blockquote>
<p>如果结构体的所有字段都是严格可比较的，那么结构体类型也是严格可比较的。</p>
<blockquote>
<ul>
<li>Array types are strictly comparable if their array element types are strictly comparable.</li>
</ul>
</blockquote>
<p>如果数组中所有元素类型都是严格可比较的，那么数组类型也是严格可比较的。</p>
<blockquote>
<ul>
<li>Type parameters are strictly comparable if all types in their type set are strictly comparable.</li>
</ul>
</blockquote>
<p>如果类型参数的类型集中的所有类型都是严格可比较的，那么类型参数也是严格可比较的。</p>
<h3 id="logical-operators-逻辑运算符">Logical operators 逻辑运算符</h3>
<blockquote>
<p>Logical operators apply to boolean values and yield a result of the same type as the operands. The right operand is evaluated conditionally.</p>
</blockquote>
<p>逻辑运算符作用于布尔值，并生成与操作数相同类型的结果。<br/>
右操作数会有条件地计算。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">&amp;&amp;    conditional AND    p &amp;&amp; q  is  &quot;if p then q else false&quot;</span></span>
<span class="line"><span style="color:#babed8">||    conditional OR     p || q  is  &quot;if p then true else q&quot;</span></span>
<span class="line"><span style="color:#babed8">!     NOT                !p      is  &quot;not p&quot;</span></span></code></pre>
<h3 id="address-operators-取地址运算符">Address operators 取地址运算符</h3>
<blockquote>
<p>For an operand x of type T, the address operation &amp;x generates a pointer of type *T to x. The operand must be addressable, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, x may also be a (possibly parenthesized) composite literal. If the evaluation of x would cause a run-time panic, then the evaluation of &amp;x does too.</p>
</blockquote>
<p>对于 T 类型的操作数 x , <code>&amp;x</code> 这样一个取地址运算符会生成一个 <code>*T</code> 类型的指针指向 x .<br/>
操作数必须是可取址的，就是说，变量、（通过）指针间接寻址，或者切片索引操作，或者可寻址的结构的字段选择操作，或者一个可寻址的数组索引。<br/>
作为可寻址要求的一个例外， x 也可以是（被括起来的）复数字面量。<br/>
如果 x 的计算会引起运行时 panic, 那么 <code>&amp;x</code> 的计算同样也会 panic.</p>
<blockquote>
<p>For an operand x of pointer type *T, the pointer indirection *x denotes the variable of type T pointed to by x. If x is nil, an attempt to evaluate *x will cause a run-time panic.</p>
</blockquote>
<p>对于 <code>*T</code> 指针类型的操作数 x , <code>*x</code> 这样的通过指针间接寻址表示的是指向 x 的 T 类型的值。<br/>
如果 x 为 nil, 那么对 <code>*x</code> 求值的尝试会引发运行时 panic.</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">&amp;x</span></span>
<span class="line"><span style="color:#babed8">&amp;a[f(2)]</span></span>
<span class="line"><span style="color:#babed8">&amp;Point{2, 3}</span></span>
<span class="line"><span style="color:#babed8">*p</span></span>
<span class="line"><span style="color:#babed8">*pf(x)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var x *int = nil</span></span>
<span class="line"><span style="color:#babed8">*x   // causes a run-time panic</span></span>
<span class="line"><span style="color:#babed8">&amp;*x  // causes a run-time panic</span></span></code></pre>
<h3 id="receive-operator-接收运算符">Receive operator 接收运算符</h3>
<blockquote>
<p>For an operand ch whose core type is a channel, the value of the receive operation <code>&lt;-ch</code> is the value received from the channel ch. The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a nil channel blocks forever. A receive operation on a closed channel can always proceed immediately, yielding the element type’s zero value after any previously sent values have been received.</p>
</blockquote>
<p>对于核心类型为通道的操作数 ch , 接收操作 <code>&lt;-ch</code> 的值是从通道 ch 中接收到的值。<br/>
这个通道的方向必须允许接收操作，并且接收操作的类型为通道元素的类型。<br/>
这个表达式在有可用的值之前，会一直阻塞。<br/>
如果是从 nil 通道接收，会永远阻塞。<br/>
在已经关闭了的通道上的接受操作会立即进行，已经收到过的任何先前发送的值都会生成元素类型的零值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">v1 := &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">v2 = &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">f(&lt;-ch)</span></span>
<span class="line"><span style="color:#babed8">&lt;-strobe  // wait until clock pulse and discard received value</span></span></code></pre>
<blockquote>
<p>A receive expression used in an assignment statement or initialization of the special form</p>
</blockquote>
<p>（下面是）一个在赋值语句或者特殊的表单式初始化中使用的接收表达式</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x, ok = &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">x, ok := &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">var x, ok = &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">var x, ok T = &lt;-ch</span></span></code></pre>
<blockquote>
<p>yields an additional untyped boolean result reporting whether the communication succeeded. The value of ok is true if the value received was delivered by a successful send operation to the channel, or false if it is a zero value generated because the channel is closed and empty.</p>
</blockquote>
<p>会生成一个额外的无类型的布尔值来报告通信是否成功。<br/>
如果收到的值是由针对该通道的成功的发送操作投递的，那么 ok 的值为 true ，否则如果它是由于通道被关闭且为空而生成的零值，那就是 false .</p>
<h3 id="conversions-转换">Conversions 转换</h3>
<blockquote>
<p>A conversion changes the type of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be implied by the context in which an expression appears.</p>
</blockquote>
<p>转换会将表达式的类型变成指定的类型。转换可能以字面形式出现在源代码中，也可能由表达式所处的上下文暗示。</p>
<blockquote>
<p>An explicit conversion is an expression of the form T(x) where T is a type and x is an expression that can be converted to type T.</p>
</blockquote>
<p>显式转换是 T(x) 形式的表达式，其中 T 是类型， x 是可以转换为类型 T 的表达式。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Conversion = Type &quot;(&quot; Expression [ &quot;,&quot; ] &quot;)&quot; .</span></span></code></pre>
<blockquote>
<p>If the type starts with the operator <code>*</code> or <code>&lt;-</code>, or if the type starts with the keyword func and has no result list, it must be parenthesized when necessary to avoid ambiguity:</p>
</blockquote>
<p>如果类型以运算符 <code>*</code> 或 <code>&lt;-</code> 开头，或者类型以关键字 func 开头且没有返回值列表，则必要时必须将其括起来以避免歧义：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">*Point(p)        // same as *(Point(p))</span></span>
<span class="line"><span style="color:#babed8">(*Point)(p)      // p is converted to *Point</span></span>
<span class="line"><span style="color:#babed8">&lt;-chan int(c)    // same as &lt;-(chan int(c))</span></span>
<span class="line"><span style="color:#babed8">(&lt;-chan int)(c)  // c is converted to &lt;-chan int</span></span>
<span class="line"><span style="color:#babed8">func()(x)        // function signature func() x</span></span>
<span class="line"><span style="color:#babed8">(func())(x)      // x is converted to func()</span></span>
<span class="line"><span style="color:#babed8">(func() int)(x)  // x is converted to func() int</span></span>
<span class="line"><span style="color:#babed8">func() int(x)    // x is converted to func() int (unambiguous)</span></span></code></pre>
<blockquote>
<p>A constant value x can be converted to type T if x is representable by a value of T. As a special case, an integer constant x can be explicitly converted to a string type using the same rule as for non-constant x.</p>
</blockquote>
<p>如果常量值 x 可由 T类型的值表示，那么就可以将 x 转换为类型 T 的值。特别地，对非常量转换的规则，对于将整数常量 x 显式转换为字符串类型也是适用的。</p>
<blockquote>
<p>Converting a constant to a type that is not a type parameter yields a typed constant.</p>
</blockquote>
<p>将常量转换为非类型参数的类型将生成有类型常量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uint(iota)               // iota value of type uint</span></span>
<span class="line"><span style="color:#babed8">float32(2.718281828)     // 2.718281828 of type float32</span></span>
<span class="line"><span style="color:#babed8">complex128(1)            // 1.0 + 0.0i of type complex128</span></span>
<span class="line"><span style="color:#babed8">float32(0.49999999)      // 0.5 of type float32</span></span>
<span class="line"><span style="color:#babed8">float64(-1e-1000)        // 0.0 of type float64</span></span>
<span class="line"><span style="color:#babed8">string(&#39;x&#39;)              // &quot;x&quot; of type string</span></span>
<span class="line"><span style="color:#babed8">string(0x266c)           // &quot;♬&quot; of type string</span></span>
<span class="line"><span style="color:#babed8">myString(&quot;foo&quot; + &quot;bar&quot;)  // &quot;foobar&quot; of type myString</span></span>
<span class="line"><span style="color:#babed8">string([]byte{&#39;a&#39;})      // not a constant: []byte{&#39;a&#39;} is not a constant</span></span>
<span class="line"><span style="color:#babed8">(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type</span></span>
<span class="line"><span style="color:#babed8">int(1.2)                 // illegal: 1.2 cannot be represented as an int</span></span>
<span class="line"><span style="color:#babed8">string(65.0)             // illegal: 65.0 is not an integer constant</span></span></code></pre>
<blockquote>
<p>Converting a constant to a type parameter yields a non-constant value of that type, with the value represented as a value of the type argument that the type parameter is instantiated with. For example, given the function:</p>
</blockquote>
<p>将常量转换为类型参数将生成该类型的非常量值，该值表示为用于实例化类型参数的类型参数的值。例如，给定函数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func f[P ~float32|~float64]() {</span></span>
<span class="line"><span style="color:#babed8">	… P(1.1) …</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>the conversion P(1.1) results in a non-constant value of type P and the value 1.1 is represented as a float32 or a float64 depending on the type argument for f. Accordingly, if f is instantiated with a float32 type, the numeric value of the expression P(1.1) + 1.2 will be computed with the same precision as the corresponding non-constant float32 addition.</p>
</blockquote>
<p>P(1.1) 这个转换，将生成 P 类型的非常量值，并且值 1.1 表示为一个 float32 或 float64 的值，具体取决于 f 的参数类型。因此，如果 f 使用 float32 类型实例化，则表达式 P(1.1) + 1.2 的数值将以与相应的非常量的 float32 加法相同的精度计算。</p>
<blockquote>
<p>A non-constant value x can be converted to type T in any of these cases:</p>
</blockquote>
<p>在以下任何一种情况下，可以将非常量值 x 转换为类型 T ：</p>
<blockquote>
<ul>
<li>x is assignable to T.</li>
</ul>
</blockquote>
<p>x 可分配给 T 。</p>
<blockquote>
<ul>
<li>ignoring struct tags (see below), x’s type and T are not type parameters but have identical underlying types.</li>
</ul>
</blockquote>
<p>忽略结构体标签（见下文）， x 的类型和 T 不是类型参数，但具有相同的基础类型。</p>
<blockquote>
<ul>
<li>ignoring struct tags (see below), x’s type and T are pointer types that are not named types, and their pointer base types are not type parameters but have identical underlying types.</li>
</ul>
</blockquote>
<p>忽略结结构体标签（见下文）， x 的类型和 T 不是具名类型的指针类型，并且它们的指针基础类型不是类型参数，但具有相同的基础类型。</p>
<blockquote>
<ul>
<li>x’s type and T are both integer or floating point types.</li>
</ul>
</blockquote>
<p>x 的类型和 T 都是整数或浮点指针类型。</p>
<blockquote>
<ul>
<li>x’s type and T are both complex types.</li>
</ul>
</blockquote>
<p>x 的类型和 T 都是复数类型。</p>
<blockquote>
<ul>
<li>x is an integer or a slice of bytes or runes and T is a string type.</li>
</ul>
</blockquote>
<p>x 是一个整数或字节切片或 Unicode 字符切片，且 T 是字符串类型。</p>
<blockquote>
<ul>
<li>x is a string and T is a slice of bytes or runes.</li>
</ul>
</blockquote>
<p>x 是一个字符串， T 是字节切片或 Unicode 字符切片。</p>
<blockquote>
<ul>
<li>x is a slice, T is an array or a pointer to an array, and the slice and array types have identical element types.</li>
</ul>
</blockquote>
<p>x 是切片， T 是一个数组或指向数组的指针，且切片和数组类型具有相同的元素类型。</p>
<blockquote>
<p>Additionally, if T or x’s type V are type parameters, x can also be converted to type T if one of the following conditions applies:</p>
</blockquote>
<p>此外，如果 T 或 x 的类型 V 是类型参数，如果满足以下任一条件， x 也可以转换为类型 T ：</p>
<blockquote>
<ul>
<li>Both V and T are type parameters and a value of each type in V’s type set can be converted to each type in T’s type set.</li>
</ul>
</blockquote>
<p>V 和 T 都是类型参数， V 的类型集中每个类型的值都可以转换为 T 的类型集中的每个类型。</p>
<blockquote>
<ul>
<li>Only V is a type parameter and a value of each type in V’s type set can be converted to T.</li>
</ul>
</blockquote>
<p>只有 V 是类型参数，并且 V 的类型集中每个类型的值都可以转换为 T 。</p>
<blockquote>
<ul>
<li>Only T is a type parameter and x can be converted to each type in T’s type set.</li>
</ul>
</blockquote>
<p>只有 T 是一个类型参数，并且 x 可以转换为 T 的类型集中的每个类型。</p>
<blockquote>
<p>Struct tags are ignored when comparing struct types for identity for the purpose of conversion:</p>
</blockquote>
<p>当出于转换目的，比较标识的结构体类型时，将忽略结构体标签：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type Person struct {</span></span>
<span class="line"><span style="color:#babed8">	Name    string</span></span>
<span class="line"><span style="color:#babed8">	Address *struct {</span></span>
<span class="line"><span style="color:#babed8">		Street string</span></span>
<span class="line"><span style="color:#babed8">		City   string</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var data *struct {</span></span>
<span class="line"><span style="color:#babed8">	Name    string `json:&quot;name&quot;`</span></span>
<span class="line"><span style="color:#babed8">	Address *struct {</span></span>
<span class="line"><span style="color:#babed8">		Street string `json:&quot;street&quot;`</span></span>
<span class="line"><span style="color:#babed8">		City   string `json:&quot;city&quot;`</span></span>
<span class="line"><span style="color:#babed8">	} `json:&quot;address&quot;`</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var person = (*Person)(data)  // ignoring tags, the underlying types are identical</span></span></code></pre>
<blockquote>
<p>Specific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of x and incur a run-time cost. All other conversions only change the type but not the representation of x.</p>
</blockquote>
<p>特定规则适用于数值类型之间的（非常量）转换或与字符串类型之间的（非常量）转换。这些转换可能会改变 x 的表示形式并产生运行时开销。所有其他转换只会改变的类型，但不会改变 x 的表示形式。</p>
<blockquote>
<p>There is no linguistic mechanism to convert between pointers and integers. The package unsafe implements this functionality under restricted circumstances.</p>
</blockquote>
<p>没有在指针和整数之间进行转换的语言机制。 unsafe 包在受限的情况下实现了这个功能。</p>
<h4 id="conversions-between-numeric-types-数值类型之间的转换">Conversions between numeric types 数值类型之间的转换</h4>
<blockquote>
<p>For the conversion of non-constant numeric values, the following rules apply:</p>
</blockquote>
<p>对于非常量数值的转换，以下规则适用：</p>
<blockquote>
<ol>
<li>When converting between integer types, if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type’s size. For example, if v := uint16(0x10F0), then uint32(int8(v)) == 0xFFFFFFF0. The conversion always yields a valid value; there is no indication of overflow.</li>
</ol>
</blockquote>
<p>在整数类型之间转换时，如果值是有符号整数，则将其符号扩展为隐式无限精度;否则为零扩展。然后截断它以适应结果类型的大小。例如，如果 v := uint16(0x10F0) 则 uint32(int8(v)) == 0xFFFFFFF0 .转换始终产生有效值；没有溢出的迹象。</p>
<blockquote>
<ol start="2">
<li>When converting a floating-point number to an integer, the fraction is discarded (truncation towards zero).</li>
</ol>
</blockquote>
<p>将浮点数转换为整数时，分数将被丢弃（截断为零）。</p>
<blockquote>
<ol start="3">
<li>When converting an integer or floating-point number to a floating-point type, or a complex number to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable x of type float32 may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding x’s value to 32-bit precision. Similarly, x + 0.1 may use more than 32 bits of precision, but float32(x + 0.1) does not.</li>
</ol>
</blockquote>
<p>将整数或浮点数转换为浮点类型或将复数转换为另一种复杂类型时，结果值将舍入为目标类型指定的精度。例如，类型的 float32 变量 x 的值可以使用超出 IEEE-754 32 位数字的额外精度进行存储，但 float32（x） 表示将 x 的值舍入为 32 位精度的结果。类似地， x + 0.1 可以使用超过 32 位的精度，但不使用 float32(x + 0.1) 。</p>
<blockquote>
<p>In all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.</p>
</blockquote>
<p>在所有涉及浮点值或复数值的非常量转换中，如果结果类型不能表示值，则转换成功，但结果值与实现相关。</p>
<h4 id="conversions-to-and-from-a-string-type-与字符串类型之间的转换">Conversions to and from a string type 与字符串类型之间的转换</h4>
<blockquote>
<ol>
<li>Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.</li>
</ol>
</blockquote>
<p>将字节片转换为字符串类型将生成一个字符串，其连续字节是切片的元素。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">string([]byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;})   // &quot;hellø&quot;</span></span>
<span class="line"><span style="color:#babed8">string([]byte{})                                     // &quot;&quot;</span></span>
<span class="line"><span style="color:#babed8">string([]byte(nil))                                  // &quot;&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type bytes []byte</span></span>
<span class="line"><span style="color:#babed8">string(bytes{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;})    // &quot;hellø&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type myByte byte</span></span>
<span class="line"><span style="color:#babed8">string([]myByte{&#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;})       // &quot;world!&quot;</span></span>
<span class="line"><span style="color:#babed8">myString([]myByte{&#39;\xf0&#39;, &#39;\x9f&#39;, &#39;\x8c&#39;, &#39;\x8d&#39;})   // &quot;🌍&quot;</span></span></code></pre>
<blockquote>
<ol start="2">
<li>Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.</li>
</ol>
</blockquote>
<p>将Unicode字符切片转换为字符串类型会产生一个字符串，该字符串是转换为字符串的各个符文值的串联。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">string([]rune{0x767d, 0x9d6c, 0x7fd4})   // &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span>
<span class="line"><span style="color:#babed8">string([]rune{})                         // &quot;&quot;</span></span>
<span class="line"><span style="color:#babed8">string([]rune(nil))                      // &quot;&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type runes []rune</span></span>
<span class="line"><span style="color:#babed8">string(runes{0x767d, 0x9d6c, 0x7fd4})    // &quot;\u767d\u9d6c\u7fd4&quot; == &quot;白鵬翔&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type myRune rune</span></span>
<span class="line"><span style="color:#babed8">string([]myRune{0x266b, 0x266c})         // &quot;\u266b\u266c&quot; == &quot;♫♬&quot;</span></span>
<span class="line"><span style="color:#babed8">myString([]myRune{0x1f30e})              // &quot;\U0001f30e&quot; == &quot;🌎&quot;</span></span></code></pre>
<blockquote>
<ol start="3">
<li>Converting a value of a string type to a slice of bytes type yields a slice whose successive elements are the bytes of the string.</li>
</ol>
</blockquote>
<p>将字符串类型的值转换为字节类型的切片将生成一个切片，其连续元素是字符串的字节。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">[]byte(&quot;hellø&quot;)             // []byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;}</span></span>
<span class="line"><span style="color:#babed8">[]byte(&quot;&quot;)                  // []byte{}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">bytes(&quot;hellø&quot;)              // []byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;\xc3&#39;, &#39;\xb8&#39;}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">[]myByte(&quot;world!&quot;)          // []myByte{&#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;}</span></span>
<span class="line"><span style="color:#babed8">[]myByte(myString(&quot;🌏&quot;))    // []myByte{&#39;\xf0&#39;, &#39;\x9f&#39;, &#39;\x8c&#39;, &#39;\x8f&#39;}</span></span></code></pre>
<blockquote>
<ol start="4">
<li>Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string.</li>
</ol>
</blockquote>
<p>将字符串类型的值转换为 Unicode 字符类型的切片将生成包含字符串的各个 Unicode 代码点的切片。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">[]rune(myString(&quot;白鵬翔&quot;))   // []rune{0x767d, 0x9d6c, 0x7fd4}</span></span>
<span class="line"><span style="color:#babed8">[]rune(&quot;&quot;)                  // []rune{}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">runes(&quot;白鵬翔&quot;)              // []rune{0x767d, 0x9d6c, 0x7fd4}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">[]myRune(&quot;♫♬&quot;)              // []myRune{0x266b, 0x266c}</span></span>
<span class="line"><span style="color:#babed8">[]myRune(myString(&quot;🌐&quot;))    // []myRune{0x1f310}</span></span></code></pre>
<blockquote>
<ol start="5">
<li>Finally, for historical reasons, an integer value may be converted to a string type. This form of conversion yields a string containing the (possibly multi-byte) UTF-8 representation of the Unicode code point with the given integer value. Values outside the range of valid Unicode code points are converted to “\uFFFD”.</li>
</ol>
</blockquote>
<p>最后，由于历史原因，整数值可能会转换为字符串类型。这种形式的转换产生一个字符串，其中包含具有给定整数值的 Unicode 码位的（可能是多字节）UTF-8 表示形式。超出有效 Unicode 码位范围的值将转换为 “\uFFFD” 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">string(&#39;a&#39;)          // &quot;a&quot;</span></span>
<span class="line"><span style="color:#babed8">string(65)           // &quot;A&quot;</span></span>
<span class="line"><span style="color:#babed8">string(&#39;\xf8&#39;)       // &quot;\u00f8&quot; == &quot;ø&quot; == &quot;\xc3\xb8&quot;</span></span>
<span class="line"><span style="color:#babed8">string(-1)           // &quot;\ufffd&quot; == &quot;\xef\xbf\xbd&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type myString string</span></span>
<span class="line"><span style="color:#babed8">myString(&#39;\u65e5&#39;)   // &quot;\u65e5&quot; == &quot;日&quot; == &quot;\xe6\x97\xa5&quot;</span></span></code></pre>
<blockquote>
<p>Note: This form of conversion may eventually be removed from the language. The go vet tool flags certain integer-to-string conversions as potential errors. Library functions such as utf8.AppendRune or utf8.EncodeRune should be used instead.</p>
</blockquote>
<p>注意：这种转换形式最终可能会从语言中删除。 go vet 工具将某些整数到字符串的转换标记为潜在错误。应改用库函数如 utf8.AppendRune 或 utf8.EncodeRune 来代替。</p>
<h4 id="conversions-from-slice-to-array-or-array-pointer-从切片到数组或到数组指针的转换">Conversions from slice to array or array pointer 从切片到数组或到数组指针的转换</h4>
<blockquote>
<p>Converting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the length of the slice is less than the length of the array, a run-time panic occurs.</p>
</blockquote>
<p>将切片转换为数组将生成一个包含切片基础数组中的元素的数组。同样，将切片转换为数组指针会生成指向切片的基础数组的指针。在这两种情况下，如果切片的长度小于数组的长度，则会发生运行时 panic 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s := make([]byte, 2, 4)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">a0 := [0]byte(s)</span></span>
<span class="line"><span style="color:#babed8">a1 := [1]byte(s[1:])     // a1[0] == s[1]</span></span>
<span class="line"><span style="color:#babed8">a2 := [2]byte(s)         // a2[0] == s[0]</span></span>
<span class="line"><span style="color:#babed8">a4 := [4]byte(s)         // panics: len([4]byte) &gt; len(s)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">s0 := (*[0]byte)(s)      // s0 != nil</span></span>
<span class="line"><span style="color:#babed8">s1 := (*[1]byte)(s[1:])  // &amp;s1[0] == &amp;s[1]</span></span>
<span class="line"><span style="color:#babed8">s2 := (*[2]byte)(s)      // &amp;s2[0] == &amp;s[0]</span></span>
<span class="line"><span style="color:#babed8">s4 := (*[4]byte)(s)      // panics: len([4]byte) &gt; len(s)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var t []string</span></span>
<span class="line"><span style="color:#babed8">t0 := [0]string(t)       // ok for nil slice t</span></span>
<span class="line"><span style="color:#babed8">t1 := (*[0]string)(t)    // t1 == nil</span></span>
<span class="line"><span style="color:#babed8">t2 := (*[1]string)(t)    // panics: len([1]string) &gt; len(t)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">u := make([]byte, 0)</span></span>
<span class="line"><span style="color:#babed8">u0 := (*[0]byte)(u)      // u0 != nil</span></span></code></pre>
<h3 id="constant-expressions-常量表达式">Constant expressions 常量表达式</h3>
<blockquote>
<p>Constant expressions may contain only constant operands and are evaluated at compile time.</p>
</blockquote>
<p>常量表达式可以只包含常量操作数，并在编译时才计算。</p>
<blockquote>
<p>Untyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.</p>
</blockquote>
<p>无类型的布尔、数字和字符串常量可以作为操作数，只要对应使用布尔、数字或字符串类型的操作数就是合法的。</p>
<blockquote>
<p>A constant comparison always yields an untyped boolean constant. If the left operand of a constant shift expression is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of integer type.</p>
</blockquote>
<p>常量比较总是会产生一个无类型的布尔常量。如果常量位移表达式的左操作数是无类型常量，则结果为整数常量；否则，结果是与左操作数类型相同的常量，左操作数必须是整数类型。</p>
<p><em>这里所说的位移表达式的意思是含有左移或右移运算符的表达式。</em></p>
<blockquote>
<p>Any other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand’s kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.</p>
</blockquote>
<p>对无类型常量执行任何其他操作，都会产生相同类型的无类型常量；即布尔常量、整数常量、浮点常量、复数常量或字符串常量。如果二进制操作（位移除外）的无类型操作数是不同类型的，则结果是在此列表后面显示的操作数类型：整数、符文、浮点、复数。例如，无类型整数常量除以无类型复数常量将会得到一个无类型复数常量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)</span></span>
<span class="line"><span style="color:#babed8">const b = 15 / 4           // b == 3     (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)</span></span>
<span class="line"><span style="color:#babed8">const Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)</span></span>
<span class="line"><span style="color:#babed8">const Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)</span></span>
<span class="line"><span style="color:#babed8">const d = 1 &lt;&lt; 3.0         // d == 8     (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">const e = 1.0 &lt;&lt; 3         // e == 8     (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">const f = int32(1) &lt;&lt; 33   // illegal    (constant 8589934592 overflows int32)</span></span>
<span class="line"><span style="color:#babed8">const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) is a typed floating-point constant)</span></span>
<span class="line"><span style="color:#babed8">const h = &quot;foo&quot; &gt; &quot;bar&quot;    // h == true  (untyped boolean constant)</span></span>
<span class="line"><span style="color:#babed8">const j = true             // j == true  (untyped boolean constant)</span></span>
<span class="line"><span style="color:#babed8">const k = &#39;w&#39; + 1          // k == &#39;x&#39;   (untyped rune constant)</span></span>
<span class="line"><span style="color:#babed8">const l = &quot;hi&quot;             // l == &quot;hi&quot;  (untyped string constant)</span></span>
<span class="line"><span style="color:#babed8">const m = string(k)        // m == &quot;x&quot;   (type string)</span></span>
<span class="line"><span style="color:#babed8">const Σ = 1 - 0.707i       //            (untyped complex constant)</span></span>
<span class="line"><span style="color:#babed8">const Δ = Σ + 2.0e-4       //            (untyped complex constant)</span></span>
<span class="line"><span style="color:#babed8">const Φ = iota*1i - 1/1i   //            (untyped complex constant)</span></span></code></pre>
<blockquote>
<p>Applying the built-in function complex to untyped integer, rune, or floating-point constants yields an untyped complex constant.</p>
</blockquote>
<p>将内置函数 complex 应用于无类型整数、符文或浮点常量，将会生成无类型复数常量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)</span></span>
<span class="line"><span style="color:#babed8">const iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)</span></span></code></pre>
<blockquote>
<p>Constant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:</p>
</blockquote>
<p>常量表达式始终会精确计算；中间值和常量本身需要的精度可能会明显大于语言中任何预先声明的类型所支持的精度。以下是合法的声明：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">const Huge = 1 &lt;&lt; 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)</span></span>
<span class="line"><span style="color:#babed8">const Four int8 = Huge &gt;&gt; 98  // Four == 4                                (type int8)</span></span></code></pre>
<blockquote>
<p>The divisor of a constant division or remainder operation must not be zero:</p>
</blockquote>
<p>常数除法或余数运算的除数不得为零：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">3.14 / 0.0   // illegal: division by zero</span></span></code></pre>
<blockquote>
<p>The values of typed constants must always be accurately representable by values of the constant type. The following constant expressions are illegal:</p>
</blockquote>
<p>有类型常量的值必须始终可由常量类型的值准确表示。以下常量表达式是非法的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uint(-1)     // -1 cannot be represented as a uint</span></span>
<span class="line"><span style="color:#babed8">int(3.14)    // 3.14 cannot be represented as an int</span></span>
<span class="line"><span style="color:#babed8">int64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64</span></span>
<span class="line"><span style="color:#babed8">Four * 300   // operand 300 cannot be represented as an int8 (type of Four)</span></span>
<span class="line"><span style="color:#babed8">Four * 100   // product 400 cannot be represented as an int8 (type of Four)</span></span></code></pre>
<blockquote>
<p>The mask used by the unary bitwise complement operator ^ matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.</p>
</blockquote>
<p>一元按位补码运算符 ^ 使用的掩码与非常量的规则匹配：对于无符号常量，掩码全部为 1 , 对于有符号和无类型常量，掩码为 -1 .</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">^1         // untyped integer constant, equal to -2</span></span>
<span class="line"><span style="color:#babed8">uint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8</span></span>
<span class="line"><span style="color:#babed8">^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)</span></span>
<span class="line"><span style="color:#babed8">int8(^1)   // same as int8(-2)</span></span>
<span class="line"><span style="color:#babed8">^int8(1)   // same as -1 ^ int8(1) = -2</span></span></code></pre>
<blockquote>
<p>Implementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on constants. This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.</p>
</blockquote>
<p>实现限制：编译器在计算无类型浮点或复数常量表达式时可以使用舍入；请参阅常量部分中的实现限制。舍入可能会导致浮点常量表达式在整数上下文中无效，即使它在使用无限精度计算时是整数的，反之亦然。</p>
<h3 id="order-of-evaluation-求值顺序">Order of evaluation 求值顺序</h3>
<blockquote>
<p>At package level, initialization dependencies determine the evaluation order of individual initialization expressions in variable declarations. Otherwise, when evaluating the operands of an expression, assignment, or return statement, all function calls, method calls, and communication operations are evaluated in lexical left-to-right order.</p>
</blockquote>
<p>在包级别，用于初始化的依赖关系确定了变量声明中各个初始化表达式的求值顺序。<br/>
否则，在计算表达式、赋值或返回语句的操作数时，将会按照从左到右的词法顺序计算所有的函数调用、方法调用和通信操作。</p>
<blockquote>
<p>For example, in the (function-local) assignment</p>
</blockquote>
<p>例如，在（函数本地）赋值中</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">y</span><span style="color:#89DDFF">[</span><span style="color:#82AAFF">f</span><span style="color:#89DDFF">()],</span><span style="color:#BABED8"> ok </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">g</span><span style="color:#89DDFF">(</span><span style="color:#82AAFF">h</span><span style="color:#89DDFF">(),</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">i</span><span style="color:#89DDFF">()+</span><span style="color:#BABED8">x</span><span style="color:#89DDFF">[</span><span style="color:#82AAFF">j</span><span style="color:#89DDFF">()],</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&lt;-</span><span style="color:#BABED8">c</span><span style="color:#89DDFF">),</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">k</span><span style="color:#89DDFF">()</span></span></code></pre>
<blockquote>
<p>the function calls and communication happen in the order <code>f(), h(), i(), j(), &lt;-c, g(), and k()</code>. However, the order of those events compared to the evaluation and indexing of x and the evaluation of y is not specified.</p>
</blockquote>
<p>函数调用和通信的发生顺序为：<code>f(), h(), i(), j(), &lt;-c, g(), k()</code>. 但是，上述事件与求值和 x 索引以及 y 的求值的顺序发生比较的顺序是不确定的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a := 1</span></span>
<span class="line"><span style="color:#babed8">f := func() int { a++; return a }</span></span>
<span class="line"><span style="color:#babed8">x := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified</span></span>
<span class="line"><span style="color:#babed8">m := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified</span></span>
<span class="line"><span style="color:#babed8">n := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified</span></span></code></pre>
<blockquote>
<p>At package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:</p>
</blockquote>
<p>在包级别，用于初始化的依赖关系会覆盖单个初始化表达式的从左到右规则，但不会覆盖每个表达式中的操作数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a, b, c = f() + v(), g(), sqr(u()) + v()</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func f() int        { return c }</span></span>
<span class="line"><span style="color:#babed8">func g() int        { return a }</span></span>
<span class="line"><span style="color:#babed8">func sqr(x int) int { return x*x }</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// functions u and v are independent of all other variables and functions</span></span></code></pre>
<blockquote>
<p>The function calls happen in the order u(), sqr(), v(), f(), v(), and g().</p>
</blockquote>
<p>函数调用的顺序为：u(), sqr(), v(), f(), v(), g().</p>
<blockquote>
<p>Floating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression x + (y + z) the addition y + z is performed before adding x.</p>
</blockquote>
<p>单个表达式中的浮点运算是根据运算符的结合性进行求值的。显式的括号会通过覆盖默认的结合性来影响求值。在表达式 <code>x + (y + z)</code> 中，在 +x 之前会先执行 y + z 。</p>
<h2 id="statements-语句">Statements 语句</h2>
<blockquote>
<p>Statements control execution.</p>
</blockquote>
<p>语句控制执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Statement =</span></span>
<span class="line"><span style="color:#babed8">	Declaration | LabeledStmt | SimpleStmt |</span></span>
<span class="line"><span style="color:#babed8">	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |</span></span>
<span class="line"><span style="color:#babed8">	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |</span></span>
<span class="line"><span style="color:#babed8">	DeferStmt .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .</span></span></code></pre>
<h3 id="terminating-statements-终止语句">Terminating statements 终止语句</h3>
<blockquote>
<p>A terminating statement interrupts the regular flow of control in a block. The following statements are terminating:</p>
</blockquote>
<p>终止语句会终止块中的常规控制流。以下语句会造成终止：</p>
<blockquote>
<ol>
<li>A “return” or “goto” statement.</li>
</ol>
</blockquote>
<p>return 或 goto 语句。</p>
<blockquote>
<ol start="2">
<li>A call to the built-in function panic.</li>
</ol>
</blockquote>
<p>调用内置函数 panic()。</p>
<blockquote>
<ol start="3">
<li>A block in which the statement list ends in a terminating statement.</li>
</ol>
</blockquote>
<p>语句列表以终止语句结尾的块。</p>
<blockquote>
<ol start="4">
<li>An “if” statement in which:</li>
</ol>
</blockquote>
<p>满足以下条件的if语句：</p>
<blockquote>
<ul>
<li>the “else” branch is present, and</li>
</ul>
</blockquote>
<ul>
<li>有else分支，且</li>
</ul>
<blockquote>
<ul>
<li>both branches are terminating statements.</li>
</ul>
</blockquote>
<ul>
<li>两个分支都是终止语句。</li>
</ul>
<blockquote>
<ol start="5">
<li>A “for” statement in which:</li>
</ol>
</blockquote>
<p>满足以下条件的for语句：</p>
<blockquote>
<ul>
<li>there are no “break” statements referring to the “for” statement, and</li>
</ul>
</blockquote>
<p>没有break语句关联for语句，并且</p>
<blockquote>
<ul>
<li>the loop condition is absent, and</li>
</ul>
</blockquote>
<p>循环条件不存在，并且</p>
<blockquote>
<ul>
<li>the “for” statement does not use a range clause.</li>
</ul>
</blockquote>
<p>for 语句没有使用 range 子句。</p>
<blockquote>
<ol start="6">
<li>A “switch” statement in which:</li>
</ol>
</blockquote>
<p>满足以下条件的 switch 语句：</p>
<blockquote>
<ul>
<li>there are no “break” statements referring to the “switch” statement,</li>
</ul>
</blockquote>
<p>没有break语句关联for语句</p>
<blockquote>
<ul>
<li>there is a default case, and</li>
</ul>
</blockquote>
<p>有一个 default case, 并且</p>
<blockquote>
<ul>
<li>the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled “fallthrough” statement.</li>
</ul>
</blockquote>
<p>该语句列出了每种 case ，包括default、终止语句的结尾或可能标记为 “fallthrough” 的语句。</p>
<blockquote>
<ol start="7">
<li>A “select” statement in which:</li>
</ol>
</blockquote>
<p>满足以下条件的 select 语句：</p>
<blockquote>
<ul>
<li>there are no “break” statements referring to the “select” statement, and</li>
</ul>
</blockquote>
<p>没有引用 select 语句的 break 语句，并且</p>
<blockquote>
<ul>
<li>the statement lists in each case, including the default if present, end in a terminating statement.</li>
</ul>
</blockquote>
<p>语句列出了每种 case ，包括 default （如果有的话），以终止语句结尾。</p>
<blockquote>
<ol start="8">
<li>A labeled statement labeling a terminating statement.</li>
</ol>
</blockquote>
<p>给终止语句做标记的 label 语句。</p>
<blockquote>
<p>All other statements are not terminating.</p>
</blockquote>
<p>其他所有语句都不会导致终止。</p>
<blockquote>
<p>A statement list ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.</p>
</blockquote>
<p>如果语句列表不为空，并且其最后一个非空语句正在终止，则该语句列表以终止语句结尾。</p>
<h3 id="empty-statements-空语句">Empty statements 空语句</h3>
<blockquote>
<p>The empty statement does nothing.</p>
</blockquote>
<p>空语句什么也不干。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">EmptyStmt = .</span></span></code></pre>
<h3 id="labeled-statements-标签语句">Labeled statements 标签语句</h3>
<blockquote>
<p>A labeled statement may be the target of a goto, break or continue statement.</p>
</blockquote>
<p>标签语句可以作为 goto 或 break / continue 语句的目标。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">LabeledStmt = Label &quot;:&quot; Statement .</span></span>
<span class="line"><span style="color:#babed8">Label       = identifier .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Error: log.Panic(&quot;error encountered&quot;)</span></span></code></pre>
<h3 id="expression-statements-表达式语句">Expression statements 表达式语句</h3>
<blockquote>
<p>With the exception of specific built-in functions, function and method calls and receive operations can appear in statement context. Such statements may be parenthesized.</p>
</blockquote>
<p>除了特定的内置函数之外，函数和方法调用以及接收操作可以出现在语句上下文中。此类声明可加括号括起来。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ExpressionStmt = Expression .</span></span></code></pre>
<blockquote>
<p>The following built-in functions are not permitted in statement context:</p>
</blockquote>
<p>语句上下文中不允许使用以下内置函数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">append cap complex imag len make new real</span></span>
<span class="line"><span style="color:#babed8">unsafe.Add unsafe.Alignof unsafe.Offsetof unsafe.Sizeof unsafe.Slice</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">h(x+y)</span></span>
<span class="line"><span style="color:#babed8">f.Close()</span></span>
<span class="line"><span style="color:#babed8">&lt;-ch</span></span>
<span class="line"><span style="color:#babed8">(&lt;-ch)</span></span>
<span class="line"><span style="color:#babed8">len(&quot;foo&quot;)  // illegal if len is the built-in function</span></span></code></pre>
<h3 id="send-statements-发送语句">Send statements 发送语句</h3>
<blockquote>
<p>A send statement sends a value on a channel. The channel expression’s core type must be a channel, the channel direction must permit send operations, and the type of the value to be sent must be assignable to the channel’s element type.</p>
</blockquote>
<p>send 语句经由 channel 来发送值。channel 表达式的核心类型必须是 channel, channel 的方向必须允许发送操作，并且要发送的值的类型必须与 channel 的元素类型一致。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">SendStmt = Channel &quot;&lt;-&quot; Expression .</span></span>
<span class="line"><span style="color:#babed8">Channel  = Expression .</span></span></code></pre>
<blockquote>
<p>Both the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a run-time panic. A send on a nil channel blocks forever.</p>
</blockquote>
<p>在通信开始之前，channel 和值表达式都会被计算。通信会一直阻塞到发送可以进行。如果有一个接收器准备就绪了，那么就可以在无缓冲通道上继续发送了。如果（有缓冲通道的）缓冲区中还有空间，那么发送就可以继续。向一个已经被关闭了的通道继续发送会导致运行时 panic 。 nil 通道上的发送会永远阻塞。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ch &lt;- 3  // send value 3 to channel ch</span></span></code></pre>
<h3 id="incdec-statements-自增减语句">IncDec statements 自增减语句</h3>
<blockquote>
<p>The ”++” and ”—” statements increment or decrement their operands by the untyped constant 1. As with an assignment, the operand must be addressable or a map index expression.</p>
</blockquote>
<p>”++“和”—“语句逐1递增或递减其操作数。带有赋值时，操作数必须是可寻址的或是 map 索引表达式。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">IncDecStmt = Expression ( &quot;++&quot; | &quot;--&quot; ) .</span></span></code></pre>
<blockquote>
<p>The following assignment statements are semantically equivalent:</p>
</blockquote>
<p>以下赋值语句在语义上是等效的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">IncDec statement    Assignment</span></span>
<span class="line"><span style="color:#babed8">x++                 x += 1</span></span>
<span class="line"><span style="color:#babed8">x--                 x -= 1</span></span></code></pre>
<h3 id="assignment-statements-赋值语句">Assignment statements 赋值语句</h3>
<blockquote>
<p>An assignment replaces the current value stored in a variable with a new value specified by an expression. An assignment statement may assign a single value to a single variable, or multiple values to a matching number of variables.</p>
</blockquote>
<p>赋值动作会将存储在变量中的当前值替换为表达式指定的新值。赋值语句可以将单个值分配给单个变量，也可以将多个值分配给个数相匹配的变量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Assignment = ExpressionList assign_op ExpressionList .</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">assign_op = [ add_op | mul_op ] &quot;=&quot; .</span></span></code></pre>
<blockquote>
<p>Each left-hand side operand must be addressable, a map index expression, or (for = assignments only) the blank identifier. Operands may be parenthesized.</p>
</blockquote>
<p>每个左侧操作数必须是可寻址的，或者是 map 索引表达式，或（仅用于 = 赋值）空白标识符。操作数可以用括号括起来。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x = 1</span></span>
<span class="line"><span style="color:#babed8">*p = f()</span></span>
<span class="line"><span style="color:#babed8">a[i] = 23</span></span>
<span class="line"><span style="color:#babed8">(k) = &lt;-ch  // same as: k = &lt;-ch</span></span></code></pre>
<blockquote>
<p>An assignment operation x op= y where op is a binary arithmetic operator is equivalent to x = x op (y) but evaluates x only once. The op= construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.</p>
</blockquote>
<p>如果赋值运算 <code>x op=y</code> , op是一个二进制算术运算符（<em>比如<code>&gt;&gt;</code>和<code>&lt;&lt;</code></em>），那么这个赋值运算等价于 <code>x = x op(y)</code>, 但 x 仅计算一次。<code>op=</code> 是一个token（<em>词法单元</em>）。在赋值操作中，左侧和右侧表达式列表必有且仅有一个单值表达式，并且左侧表达式不得为空白标识符。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a[i] &lt;&lt;= 2</span></span>
<span class="line"><span style="color:#babed8">i &amp;^= 1&lt;&lt;n</span></span></code></pre>
<blockquote>
<p>A tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a channel or map operation, or a type assertion. The number of operands on the left hand side must match the number of values. For instance, if f is a function returning two values,</p>
</blockquote>
<p>元组赋值将多值运算的各个元素分配给变量列表。有两种形式。在第一种形式中，右操作数是单个多值表达式，例如函数调用、通道，或映射操作，或类型断言。左侧的操作数的个数必须与值的个数匹配。例如，如果 f 是一个返回两个值的函数，</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">x, y = f()</span></span></code></pre>
<blockquote>
<p>assigns the first value to x and the second to y. In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the nth expression on the right is assigned to the nth operand on the left:</p>
</blockquote>
<p>将第一个值分配给 x ，将第二个值分配给 y . 在第二种形式中，左侧的操作数个数必须等于右侧的表达式个数，每个表达式必须是单值的，右侧的第 n 个表达式会赋值给左侧的第 n 个操作数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">one, two, three = &#39;一&#39;, &#39;二&#39;, &#39;三&#39;</span></span></code></pre>
<blockquote>
<p>The blank identifier provides a way to ignore right-hand side values in an assignment:</p>
</blockquote>
<p>空白标识符提供了一种忽略赋值语句中右侧值的方法：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">_ = x       // evaluate x but ignore it</span></span>
<span class="line"><span style="color:#babed8">x, _ = f()  // evaluate f() but ignore second result value</span></span></code></pre>
<blockquote>
<p>The assignment proceeds in two phases. First, the operands of index expressions and pointer indirections (including implicit pointer indirections in selectors) on the left and the expressions on the right are all evaluated in the usual order. Second, the assignments are carried out in left-to-right order.</p>
</blockquote>
<p>分配分两个阶段进行。首先，左侧的索引表达式和指针间接寻址（包括选择器中的隐式指针间接寻址）的操作数，以及右侧的表达式，都按通常的顺序计算。其次，分配按从左到右的顺序进行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">a, b = b, a  // exchange a and b</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">x := []int{1, 2, 3}</span></span>
<span class="line"><span style="color:#babed8">i := 0</span></span>
<span class="line"><span style="color:#babed8">i, x[i] = 1, 2  // set i = 1, x[0] = 2</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">i = 0</span></span>
<span class="line"><span style="color:#babed8">x[i], i = 2, 1  // set x[0] = 2, i = 1</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type Point struct { x, y int }</span></span>
<span class="line"><span style="color:#babed8">var p *Point</span></span>
<span class="line"><span style="color:#babed8">x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">i = 2</span></span>
<span class="line"><span style="color:#babed8">x = []int{3, 5, 7}</span></span>
<span class="line"><span style="color:#babed8">for i, x[i] = range x {  // set i, x[2] = 0, x[0]</span></span>
<span class="line"><span style="color:#babed8">	break</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">// after this loop, i == 0 and x == []int{3, 5, 3}</span></span></code></pre>
<blockquote>
<p>In assignments, each value must be assignable to the type of the operand to which it is assigned, with the following special cases:</p>
</blockquote>
<p>在赋值中，每个值必须与它所分配到的操作数的类型相适应，但以下特殊情况除外：</p>
<blockquote>
<ol>
<li>Any typed value may be assigned to the blank identifier.</li>
</ol>
</blockquote>
<p>任何有类型的值都可以分配给空白标识符。</p>
<blockquote>
<ol start="2">
<li>If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly converted to its default type.</li>
</ol>
</blockquote>
<p>如果将无类型常量分配给接口类型的变量或空白标识符，那么会先将这个常量隐式转换为其默认类型。</p>
<blockquote>
<ol start="3">
<li>If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type bool.</li>
</ol>
</blockquote>
<p>如果将无类型布尔值分配给接口类型或空白标识符的变量，那么会先将它隐式转换为 bool 类型。</p>
<h3 id="if-statements-if-语句">If statements If 语句</h3>
<blockquote>
<p>“If” statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the “if” branch is executed, otherwise, if present, the “else” branch is executed.</p>
</blockquote>
<p>“If”语句根据布尔表达式的值决定从两个分支中选择执行。如果表达式的计算结果为 true，则执行”if”分支，否则，就执行”else”分支（如果有”else”分支的话）。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">IfStmt = &quot;if&quot; [ SimpleStmt &quot;;&quot; ] Expression Block [ &quot;else&quot; ( IfStmt | Block ) ] .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">if x &gt; max {</span></span>
<span class="line"><span style="color:#babed8">	x = max</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>The expression may be preceded by a simple statement, which executes before the expression is evaluated.</p>
</blockquote>
<p>表达式前面可以有一个简单语句，该语句会在表达式计算之前先执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">if x := f(); x &lt; y {</span></span>
<span class="line"><span style="color:#babed8">	return x</span></span>
<span class="line"><span style="color:#babed8">} else if x &gt; z {</span></span>
<span class="line"><span style="color:#babed8">	return z</span></span>
<span class="line"><span style="color:#babed8">} else {</span></span>
<span class="line"><span style="color:#babed8">	return y</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h3 id="switch-statements-switch-语句">Switch statements Switch 语句</h3>
<blockquote>
<p>“Switch” statements provide multi-way execution. An expression or type is compared to the “cases” inside the “switch” to determine which branch to execute.</p>
</blockquote>
<p>“switch”语句提供多路执行。将表达式或类型与 switch 中的 case 进行比较，以确定要执行的分支。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .</span></span></code></pre>
<blockquote>
<p>There are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.</p>
</blockquote>
<p>有两种形式：表达式开关和类型开关。在表达式开关中， case 包含了与 switch 表达式的值相比较的表达式。在类型开关中， case 包含与特殊注明的 switch 表达式的类型相比较的类型。 switch 表达式在 switch 语句中只会计算一次。</p>
<h3 id="expression-switches-表达式开关">Expression switches 表达式开关</h3>
<blockquote>
<p>In an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a “default” case, its statements are executed. There can be at most one default case and it may appear anywhere in the “switch” statement. A missing switch expression is equivalent to the boolean value true.</p>
</blockquote>
<p>在 switch 表达式中， switch 表达式会被计算，并且 case 表达式（不必是常量）会从左到右和从上到下计算；<br/>
第一个等于 switch 表达式的 case 会触发执行对应 case 的语句；其他 case 将被跳过。如果没有匹配的 case ，但是有”default” case, 则执行 default case 的语句。<br/>
最多只能有一个 default case ，它可以出现在”switch”语句中的任意位置。<br/>
缺失的 switch 表达式等效于布尔值 true 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ExprSwitchStmt = &quot;switch&quot; [ SimpleStmt &quot;;&quot; ] [ Expression ] &quot;{&quot; { ExprCaseClause } &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">ExprCaseClause = ExprSwitchCase &quot;:&quot; StatementList .</span></span>
<span class="line"><span style="color:#babed8">ExprSwitchCase = &quot;case&quot; ExpressionList | &quot;default&quot; .</span></span></code></pre>
<blockquote>
<p>If the switch expression evaluates to an untyped constant, it is first implicitly converted to its default type. The predeclared untyped value nil cannot be used as a switch expression. The switch expression type must be comparable.</p>
</blockquote>
<p>如果 switch 表达式的计算结果为无类型常量，则首先将其隐式转换为其默认类型。预先声明的无类型值 nil 不能用作 switch 表达式。 switch 表达式的类型必须是可比较的。</p>
<blockquote>
<p>If a case expression is untyped, it is first implicitly converted to the type of the switch expression. For each (possibly converted) case expression x and the value t of the switch expression, x == t must be a valid comparison.</p>
</blockquote>
<p>如果 case 表达式是无类型的，则首先将其隐式转换为 switch 表达式的类型。对于每个（可能转换的） case 表达式 x 和 switch 表达式 t 的值， x == t 必须是有效的比较。</p>
<blockquote>
<p>In other words, the switch expression is treated as if it were used to declare and initialize a temporary variable t without explicit type; it is that value of t against which each case expression x is tested for equality.</p>
</blockquote>
<p>换言之， switch 表达式被视为用于声明和初始化一个没有显式类型的临时变量 t ; 正是这个 t 值在测试它是否与每个 case 表达式 x 是否相等。</p>
<blockquote>
<p>In a case or default clause, the last non-empty statement may be a (possibly labeled) “fallthrough” statement to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the “switch” statement. A “fallthrough” statement may appear as the last statement of all but the last clause of an expression switch.</p>
</blockquote>
<p>在 case 或 default 子句中，最后一个非空语句可能是（可能做标记）“fallthrough”语句，以指示控制权应从此子句的末尾流转到下一条子句的第一个语句。否则，控制权就会流转到”switch”语句的末尾。“fallthrough”语句可能显示为 switch 表达式的最后一个子句之外的所有语句中的最后一个语句。</p>
<blockquote>
<p>The switch expression may be preceded by a simple statement, which executes before the expression is evaluated.</p>
</blockquote>
<p>switch 表达式前面可以有一个简单的语句，该语句在表达式计算之前先执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">switch tag {</span></span>
<span class="line"><span style="color:#babed8">default: s3()</span></span>
<span class="line"><span style="color:#babed8">case 0, 1, 2, 3: s1()</span></span>
<span class="line"><span style="color:#babed8">case 4, 5, 6, 7: s2()</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">switch x := f(); {  // missing switch expression means &quot;true&quot;</span></span>
<span class="line"><span style="color:#babed8">case x &lt; 0: return -x</span></span>
<span class="line"><span style="color:#babed8">default: return x</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">switch {</span></span>
<span class="line"><span style="color:#babed8">case x &lt; y: f1()</span></span>
<span class="line"><span style="color:#babed8">case x &lt; z: f2()</span></span>
<span class="line"><span style="color:#babed8">case x == 4: f3()</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>Implementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.</p>
</blockquote>
<p>实现限制：编译器可能不允许计算为同一常量的多个大小写表达式。例如，当前编译器不允许在大小写表达式中使用重复的整数、浮点或字符串常量。</p>
<h3 id="type-switches-类型开关">Type switches 类型开关</h3>
<blockquote>
<p>A type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a type assertion using the keyword type rather than an actual type:</p>
</blockquote>
<p>类型开关比较类型而不是值。否则，它类似于表达式开关。它由一个特殊的 switch 表达式标记，该表达式具有使用关键字 type 而不是实际类型的类型断言的形式：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">switch x.(type) {</span></span>
<span class="line"><span style="color:#babed8">// cases</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>Cases then match actual types T against the dynamic type of the expression x. As with type assertions, x must be of interface type, but not a type parameter, and each non-interface type T listed in a case must implement the type of x. The types listed in the cases of a type switch must all be different.</p>
</blockquote>
<p>然后，将 case 的实际类型 T 与表达式 x 的动态类型进行匹配。与类型断言一样， x 必须是接口类型，但不是类型参数，并且 case 中列出的每个非接口类型 T 都必须实现 x 的类型。类型开关的 case 列出的类型必须各不相同。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">TypeSwitchStmt  = &quot;switch&quot; [ SimpleStmt &quot;;&quot; ] TypeSwitchGuard &quot;{&quot; { TypeCaseClause } &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">TypeSwitchGuard = [ identifier &quot;:=&quot; ] PrimaryExpr &quot;.&quot; &quot;(&quot; &quot;type&quot; &quot;)&quot; .</span></span>
<span class="line"><span style="color:#babed8">TypeCaseClause  = TypeSwitchCase &quot;:&quot; StatementList .</span></span>
<span class="line"><span style="color:#babed8">TypeSwitchCase  = &quot;case&quot; TypeList | &quot;default&quot; .</span></span></code></pre>
<blockquote>
<p>The TypeSwitchGuard may include a short variable declaration. When that form is used, the variable is declared at the end of the TypeSwitchCase in the implicit block of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.</p>
</blockquote>
<p>TypeSwitchGuard 可能包含一个短变量声明。使用该形式时，在每个子句的隐式块中的 TypeSwitchCase 末尾声明变量。在带有列出唯一类型的case的子句中，变量具有该类型；否则，变量具有 TypeSwitchGuard 中的表达式的那个类型。</p>
<blockquote>
<p>Instead of a type, a case may use the predeclared identifier nil; that case is selected when the expression in the TypeSwitchGuard is a nil interface value. There may be at most one nil case.</p>
</blockquote>
<p>case 可以使用预先声明的标识符 nil 而不用类型；当 TypeSwitchGuard 中的表达式是 nil 接口值时，将命中这个 case 。最多只能有一个 nil case.</p>
<blockquote>
<p>Given an expression x of type interface, the following type switch:</p>
</blockquote>
<p>给定一个 interface 类型的表达式 x ，请看以下类型开关：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">switch i := x.(type) {</span></span>
<span class="line"><span style="color:#babed8">case nil:</span></span>
<span class="line"><span style="color:#babed8">	printString(&quot;x is nil&quot;)                // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">case int:</span></span>
<span class="line"><span style="color:#babed8">	printInt(i)                            // type of i is int</span></span>
<span class="line"><span style="color:#babed8">case float64:</span></span>
<span class="line"><span style="color:#babed8">	printFloat64(i)                        // type of i is float64</span></span>
<span class="line"><span style="color:#babed8">case func(int) float64:</span></span>
<span class="line"><span style="color:#babed8">	printFunction(i)                       // type of i is func(int) float64</span></span>
<span class="line"><span style="color:#babed8">case bool, string:</span></span>
<span class="line"><span style="color:#babed8">	printString(&quot;type is bool or string&quot;)  // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">default:</span></span>
<span class="line"><span style="color:#babed8">	printString(&quot;don&#39;t know the type&quot;)     // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>could be rewritten:</p>
</blockquote>
<p>上述形式可以被重写为：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">v := x  // x is evaluated exactly once</span></span>
<span class="line"><span style="color:#babed8">if v == nil {</span></span>
<span class="line"><span style="color:#babed8">	i := v                                 // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">	printString(&quot;x is nil&quot;)</span></span>
<span class="line"><span style="color:#babed8">} else if i, isInt := v.(int); isInt {</span></span>
<span class="line"><span style="color:#babed8">	printInt(i)                            // type of i is int</span></span>
<span class="line"><span style="color:#babed8">} else if i, isFloat64 := v.(float64); isFloat64 {</span></span>
<span class="line"><span style="color:#babed8">	printFloat64(i)                        // type of i is float64</span></span>
<span class="line"><span style="color:#babed8">} else if i, isFunc := v.(func(int) float64); isFunc {</span></span>
<span class="line"><span style="color:#babed8">	printFunction(i)                       // type of i is func(int) float64</span></span>
<span class="line"><span style="color:#babed8">} else {</span></span>
<span class="line"><span style="color:#babed8">	_, isBool := v.(bool)</span></span>
<span class="line"><span style="color:#babed8">	_, isString := v.(string)</span></span>
<span class="line"><span style="color:#babed8">	if isBool || isString {</span></span>
<span class="line"><span style="color:#babed8">		i := v                         // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">		printString(&quot;type is bool or string&quot;)</span></span>
<span class="line"><span style="color:#babed8">	} else {</span></span>
<span class="line"><span style="color:#babed8">		i := v                         // type of i is type of x (interface{})</span></span>
<span class="line"><span style="color:#babed8">		printString(&quot;don&#39;t know the type&quot;)</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>A type parameter or a generic type may be used as a type in a case. If upon instantiation that type turns out to duplicate another entry in the switch, the first matching case is chosen.</p>
</blockquote>
<p>类型参数或泛型类型可以用作 case 中的类型。如果在实例化时该类型结果证明与 switch 中的另一个 case 重复，则选择第一个匹配的 case 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func f[P any](x any) int {</span></span>
<span class="line"><span style="color:#babed8">	switch x.(type) {</span></span>
<span class="line"><span style="color:#babed8">	case P:</span></span>
<span class="line"><span style="color:#babed8">		return 0</span></span>
<span class="line"><span style="color:#babed8">	case string:</span></span>
<span class="line"><span style="color:#babed8">		return 1</span></span>
<span class="line"><span style="color:#babed8">	case []P:</span></span>
<span class="line"><span style="color:#babed8">		return 2</span></span>
<span class="line"><span style="color:#babed8">	case []byte:</span></span>
<span class="line"><span style="color:#babed8">		return 3</span></span>
<span class="line"><span style="color:#babed8">	default:</span></span>
<span class="line"><span style="color:#babed8">		return 4</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var v1 = f[string](&quot;foo&quot;)   // v1 == 0</span></span>
<span class="line"><span style="color:#babed8">var v2 = f[byte]([]byte{})  // v2 == 2</span></span></code></pre>
<blockquote>
<p>The type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.</p>
</blockquote>
<p>类型开关防护前面可以有一个简单的语句，该语句在防护被计算之前先执行。</p>
<blockquote>
<p>The “fallthrough” statement is not permitted in a type switch.</p>
</blockquote>
<p>类型开关中不允许使用”fallthrough”语句。</p>
<h3 id="for-statements-for-语句">For statements <code>for 语句</code></h3>
<blockquote>
<p>A “for” statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a “for” clause, or a “range” clause.</p>
</blockquote>
<p>“for”语句指定重复执行块。有三种形式：迭代由 单个条件 / “for”子句 / “range” 子句控制。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ForStmt = &quot;for&quot; [ Condition | ForClause | RangeClause ] Block .</span></span>
<span class="line"><span style="color:#babed8">Condition = Expression .</span></span></code></pre>
<h4 id="for-statements-with-single-condition-单条件-for-语句">For statements with single condition 单条件 for 语句</h4>
<blockquote>
<p>In its simplest form, a “for” statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value true.</p>
</blockquote>
<p>在最简单的形式中，“for”语句指定只要布尔条件的计算结果为 true，就会重复执行块。条件在每次迭代之前都会计算。如果条件缺失，则等效于布尔值 true 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">for a &lt; b {</span></span>
<span class="line"><span style="color:#babed8">	a *= 2</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h4 id="for-statements-with-for-clause-带-for-子句的-for-语句">For statements with for clause 带 for 子句的 for 语句</h4>
<blockquote>
<p>A “for” statement with a ForClause is also controlled by its condition, but additionally it may specify an init and a post statement, such as an assignment, an increment or decrement statement. The init statement may be a short variable declaration, but the post statement must not. Variables declared by the init statement are re-used in each iteration.</p>
</blockquote>
<p>带有 for 子句 的 “for” 语句也受其条件控制，但此外，它还可以指定初始化（InitStmt）和递进（PostStmt）语句，例如赋值、递增或递减语句。初始化语句可以是简短的变量声明，但递进语句不可以。初始化语句声明的变量在每次迭代中都会<strong>重用</strong>。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ForClause = [ InitStmt ] &quot;;&quot; [ Condition ] &quot;;&quot; [ PostStmt ] .</span></span>
<span class="line"><span style="color:#babed8">InitStmt = SimpleStmt .</span></span>
<span class="line"><span style="color:#babed8">PostStmt = SimpleStmt .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">for i := 0; i &lt; 10; i++ {</span></span>
<span class="line"><span style="color:#babed8">	f(i)</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>If non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the semicolons are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value true.</p>
</blockquote>
<p>如果为非空，则在计算第一次迭代的条件之前先执行一次初始化语句；递进语句在每次执行块后执行（并且仅当块被执行时）。 for 子句的任何元素都可以为空，但分号是必需的，除非只有条件。如果条件不存在，则等效于布尔值 true 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">for cond { S() }    is the same as    for ; cond ; { S() }</span></span>
<span class="line"><span style="color:#babed8">for      { S() }    is the same as    for true     { S() }</span></span></code></pre>
<h4 id="for-statements-with-range-clause-带-range-子句的-for-语句">For statements with range clause 带 range 子句的 for 语句</h4>
<blockquote>
<p>A “for” statement with a “range” clause iterates through all entries of an array, slice, string or map, or values received on a channel. For each entry it assigns iteration values to corresponding iteration variables if present and then executes the block.</p>
</blockquote>
<p>带有”range”子句的”for”语句遍历数组、切片、字符串或映射的所有实体，或在通道上接收的值。对于每个实体，它将迭代值分配给相应的迭代变量（如果存在），然后执行该块。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">RangeClause = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] &quot;range&quot; Expression .</span></span></code></pre>
<blockquote>
<p>The expression on the right in the “range” clause is called the range expression, its core type must be an array, pointer to an array, slice, string, map, or channel permitting receive operations. As with an assignment, if present the operands on the left must be addressable or map index expressions; they denote the iteration variables. If the range expression is a channel, at most one iteration variable is permitted, otherwise there may be up to two. If the last iteration variable is the blank identifier, the range clause is equivalent to the same clause without that identifier.</p>
</blockquote>
<p>“range”子句中右侧的表达式称为范围表达式，其核心类型必须是数组、指向数组的指针、切片、字符串、映射或允许接收操作的通道。与赋值一样，如果存在，左侧的操作数必须是可寻址的或映射索引表达式；它们表示迭代变量。如果范围表达式是通道，则最多允许一个迭代变量，否则最多可以有两个迭代变量。如果最后一个迭代变量是空白标识符，则 range 子句等效于没有该标识符的同一子句。</p>
<blockquote>
<p>The range expression x is evaluated once before beginning the loop, with one exception: if at most one iteration variable is present and len(x) is constant, the range expression is not evaluated.</p>
</blockquote>
<p>范围表达式在开始循环之前计算一次，但有一个例外：如果最多存在一个迭代变量并且 len(x) 是常量，则不计算范围表达式。</p>
<blockquote>
<p>Function calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:</p>
</blockquote>
<p>左侧的函数调用每次迭代计算一次。对于每次迭代，如果存在相应的迭代变量，则按如下方式生成迭代值：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Range expression                          1st value          2nd value</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E</span></span>
<span class="line"><span style="color:#babed8">string          s  string type            index    i  int    see below  rune</span></span>
<span class="line"><span style="color:#babed8">map             m  map[K]V                key      k  K      m[k]       V</span></span>
<span class="line"><span style="color:#babed8">channel         c  chan E, &lt;-chan E       element  e  E</span></span></code></pre>
<blockquote>
<p>1.For an array, pointer to array, or slice value a, the index iteration values are produced in increasing order, starting at element index 0. If at most one iteration variable is present, the range loop produces iteration values from 0 up to len(a)-1 and does not index into the array or slice itself. For a nil slice, the number of iterations is 0.</p>
</blockquote>
<p>1.对于数组、指向数组的指针或切片值，索引迭代值 a 按递增顺序生成，从元素索引 0 开始。如果最多存在一个迭代变量，则范围循环将生成从 0 到 len(a)-1 的迭代值，并且不会索引到数组或切片本身。对于 nil 切片，迭代次数为 0。</p>
<blockquote>
<p>2.For a string value, the “range” clause iterates over the Unicode code points in the string starting at byte index 0. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type rune, will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be 0xFFFD, the Unicode replacement character, and the next iteration will advance a single byte in the string.</p>
</blockquote>
<p>2.对于字符串值，“range”子句从字节索引 0 开始遍历字符串中的 Unicode 码点。在连续迭代中，索引值将是字符串中连续 UTF-8 码点的第一个字节的索引；第二个值的类型为 rune ，将是相应码点的值。如果迭代遇到无效的 UTF-8 序列，则第二个值将是 0xFFFD （Unicode 替换字符），下一次迭代将在字符串中前进一个字节。</p>
<blockquote>
<p>3.The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is nil, the number of iterations is 0.</p>
</blockquote>
<p>3.map的迭代顺序是不确定的，并且不会保证从一个迭代到下一个迭代相同。如果在迭代过程中删除了尚未到达的 map 元素，则不会生成相应的迭代值。如果在迭代期间创建了 map 元素，则该元素可能会在迭代期间生成或跳过。（生成还是跳过的）选择可能因创建的每个元素而异，并且因迭代而异。如果映射为 nil ，则迭代次数为 0 。</p>
<blockquote>
<p>4.For channels, the iteration values produced are the successive values sent on the channel until the channel is closed. If the channel is nil, the range expression blocks forever.</p>
</blockquote>
<p>4.对于通道，生成的迭代值是通道上发送的连续值，直到通道关闭。如果通道为 nil ，则range表达式将永久阻塞。</p>
<blockquote>
<p>The iteration values are assigned to the respective iteration variables as in an assignment statement.</p>
</blockquote>
<p>迭代值被分配给相应的迭代变量，就像在赋值语句中一样。</p>
<blockquote>
<p>The iteration variables may be declared by the “range” clause using a form of short variable declaration (:=). In this case their types are set to the types of the respective iteration values and their scope is the block of the “for” statement; they are re-used in each iteration. If the iteration variables are declared outside the “for” statement, after execution their values will be those of the last iteration.</p>
</blockquote>
<p>迭代变量可以通过”range”子句使用短变量声明（ := ）的形式进行声明。在这种情况下，它们的类型设置为相应迭代值的类型，并且它们的作用域是”for”语句的块；它们在每次迭代中都会重复使用。如果迭代变量是在”for”语句之外声明的，则在执行后，它们的值将是上次迭代的值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var testdata *struct {</span></span>
<span class="line"><span style="color:#babed8">	a *[7]int</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">for i, _ := range testdata.a {</span></span>
<span class="line"><span style="color:#babed8">	// testdata.a is never evaluated; len(testdata.a) is constant</span></span>
<span class="line"><span style="color:#babed8">	// i ranges from 0 to 6</span></span>
<span class="line"><span style="color:#babed8">	f(i)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var a [10]string</span></span>
<span class="line"><span style="color:#babed8">for i, s := range a {</span></span>
<span class="line"><span style="color:#babed8">	// type of i is int</span></span>
<span class="line"><span style="color:#babed8">	// type of s is string</span></span>
<span class="line"><span style="color:#babed8">	// s == a[i]</span></span>
<span class="line"><span style="color:#babed8">	g(i, s)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var key string</span></span>
<span class="line"><span style="color:#babed8">var val interface{}  // element type of m is assignable to val</span></span>
<span class="line"><span style="color:#babed8">m := map[string]int{&quot;mon&quot;:0, &quot;tue&quot;:1, &quot;wed&quot;:2, &quot;thu&quot;:3, &quot;fri&quot;:4, &quot;sat&quot;:5, &quot;sun&quot;:6}</span></span>
<span class="line"><span style="color:#babed8">for key, val = range m {</span></span>
<span class="line"><span style="color:#babed8">	h(key, val)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">// key == last map key encountered in iteration</span></span>
<span class="line"><span style="color:#babed8">// val == map[key]</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var ch chan Work = producer()</span></span>
<span class="line"><span style="color:#babed8">for w := range ch {</span></span>
<span class="line"><span style="color:#babed8">	doWork(w)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// empty a channel</span></span>
<span class="line"><span style="color:#babed8">for range ch {}</span></span></code></pre>
<h3 id="go-statements-go-语句">Go statements Go 语句</h3>
<blockquote>
<p>A “go” statement starts the execution of a function call as an independent concurrent thread of control, or goroutine, within the same address space.</p>
</blockquote>
<p>“go”语句在同一地址空间中，启动一个作为独立并发控制线程的函数调用，或 goroutine 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">GoStmt = &quot;go&quot; Expression .</span></span></code></pre>
<blockquote>
<p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.</p>
</blockquote>
<p>表达式必须是函数或方法调用；它不可以用括号括起来。内置函数的调用也和表达式语句一样受到限制。</p>
<blockquote>
<p>The function value and parameters are evaluated as usual in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.</p>
</blockquote>
<p>函数值和参数在调用的 goroutine 中像往常一样计算，但与常规调用不同的是，程序执行不会等待调用的函数完成。相反，该函数开始在新的 goroutine 中独立执行。当函数终止时，其 goroutine 也会终止。函数的任何返回值，在函数完成时都会被丢弃。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">go Server()</span></span>
<span class="line"><span style="color:#babed8">go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true }} (c)</span></span></code></pre>
<h3 id="select-statements-select-语句">Select statements Select 语句</h3>
<blockquote>
<p>A “select” statement chooses which of a set of possible send or receive operations will proceed. It looks similar to a “switch” statement but with the cases all referring to communication operations.</p>
</blockquote>
<p>“select”语句从一组可能的发送或接收操作中选择某一个以继续。它看起来类似于”switch”语句，但case都涉及通信操作。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">SelectStmt = &quot;select&quot; &quot;{&quot; { CommClause } &quot;}&quot; .</span></span>
<span class="line"><span style="color:#babed8">CommClause = CommCase &quot;:&quot; StatementList .</span></span>
<span class="line"><span style="color:#babed8">CommCase   = &quot;case&quot; ( SendStmt | RecvStmt ) | &quot;default&quot; .</span></span>
<span class="line"><span style="color:#babed8">RecvStmt   = [ ExpressionList &quot;=&quot; | IdentifierList &quot;:=&quot; ] RecvExpr .</span></span>
<span class="line"><span style="color:#babed8">RecvExpr   = Expression .</span></span></code></pre>
<blockquote>
<p>A case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a short variable declaration. The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.</p>
</blockquote>
<p>带接收操作的的 case 可以将接收表达式的结果分配给一个或两个变量，这些变量可以使用短变量声明方式来声明。接收表达式必须是（可能被括号包裹的）接收操作。最多只能有一个默认 case ，它可以出现在 case 列表中的任何位置。</p>
<blockquote>
<p>Execution of a “select” statement proceeds in several steps:</p>
</blockquote>
<p>“select”语句的执行分几个步骤进行：</p>
<blockquote>
<p>1.For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the “select” statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.</p>
</blockquote>
<p>1.对于语句中的所有case，在进入”select”语句时，接收操作的通道操作数、通道、以及发送语句的右侧表达式，将按原始顺序精确计算一次。结果是一组要接收或发送的通道，以及要发送的相应值。无论选择到哪种（如果有的话）通信操作，它的赋值中的任何副作用都会发生。接收语句左侧带有短变量声明或赋值的表达式则暂时还不会被计算。</p>
<blockquote>
<p>2.If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the “select” statement blocks until at least one of the communications can proceed.</p>
</blockquote>
<p>2.如果一个或多个通信可以继续，则通过一致的伪随机选择来选择某一个以继续通信。否则，如果存在默认 case ，则选择该 case 。如果没有默认 case ，则”select”语句将阻塞，直到至少有一个通信可以继续。</p>
<blockquote>
<p>3.Unless the selected case is the default case, the respective communication operation is executed.</p>
</blockquote>
<p>3.除非所选 case 是默认 case ，否则将执行相应的通信操作。</p>
<blockquote>
<p>4.If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned.</p>
</blockquote>
<p>4.如果所选case是具有短变量声明或赋值的接收表达式，则会计算左侧表达式并分配接收的值（或多个值）。</p>
<blockquote>
<p>5.The statement list of the selected case is executed.</p>
</blockquote>
<p>5.执行所选case的语句列表。</p>
<blockquote>
<p>Since communication on nil channels can never proceed, a select with only nil channels and no default case blocks forever.</p>
</blockquote>
<p>由于通道上的 nil 通信永远不可能继续，因此只有 nil 通道且没有默认 case 的 select 将永远阻塞。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a []int</span></span>
<span class="line"><span style="color:#babed8">var c, c1, c2, c3, c4 chan int</span></span>
<span class="line"><span style="color:#babed8">var i1, i2 int</span></span>
<span class="line"><span style="color:#babed8">select {</span></span>
<span class="line"><span style="color:#babed8">case i1 = &lt;-c1:</span></span>
<span class="line"><span style="color:#babed8">	print(&quot;received &quot;, i1, &quot; from c1\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">case c2 &lt;- i2:</span></span>
<span class="line"><span style="color:#babed8">	print(&quot;sent &quot;, i2, &quot; to c2\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3</span></span>
<span class="line"><span style="color:#babed8">	if ok {</span></span>
<span class="line"><span style="color:#babed8">		print(&quot;received &quot;, i3, &quot; from c3\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">	} else {</span></span>
<span class="line"><span style="color:#babed8">		print(&quot;c3 is closed\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">case a[f()] = &lt;-c4:</span></span>
<span class="line"><span style="color:#babed8">	// same as:</span></span>
<span class="line"><span style="color:#babed8">	// case t := &lt;-c4</span></span>
<span class="line"><span style="color:#babed8">	//	a[f()] = t</span></span>
<span class="line"><span style="color:#babed8">default:</span></span>
<span class="line"><span style="color:#babed8">	print(&quot;no communication\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">for {  // send random sequence of bits to c</span></span>
<span class="line"><span style="color:#babed8">	select {</span></span>
<span class="line"><span style="color:#babed8">	case c &lt;- 0:  // note: no statement, no fallthrough, no folding of cases</span></span>
<span class="line"><span style="color:#babed8">	case c &lt;- 1:</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">select {}  // block forever</span></span></code></pre>
<h3 id="return-statements-return-语句">Return statements Return 语句</h3>
<blockquote>
<p>A “return” statement in a function F terminates the execution of F, and optionally provides one or more result values. Any functions deferred by F are executed before F returns to its caller.</p>
</blockquote>
<p>函数 F 中的”return”语句会终止 F 的执行，并选择性地提供一个或多个返回值。 F 中延迟的任何函数在 F 返回给其调用方之前一定会先执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ReturnStmt = &quot;return&quot; [ ExpressionList ] .</span></span></code></pre>
<blockquote>
<p>In a function without a result type, a “return” statement must not specify any result values.</p>
</blockquote>
<p>如果函数不带返回值类型，那么”return”语句不能带任何返回值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func noResult() {</span></span>
<span class="line"><span style="color:#babed8">	return</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>There are three ways to return values from a function with a result type:</p>
</blockquote>
<p>从带返回值类型的函数中返回值，有三种方法：</p>
<blockquote>
<p>1.The return value or values may be explicitly listed in the “return” statement. Each expression must be single-valued and assignable to the corresponding element of the function’s result type.</p>
</blockquote>
<p>1.返回值可以显式地列在”return”语句中。每个表达式只能产生一个值，并且可以分配与函数返回值类型一致的元素。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func simpleF() int {</span></span>
<span class="line"><span style="color:#babed8">	return 2</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func complexF1() (re float64, im float64) {</span></span>
<span class="line"><span style="color:#babed8">	return -7.0, -4.0</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>2.The expression list in the “return” statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a “return” statement listing these variables, at which point the rules of the previous case apply.</p>
</blockquote>
<p>2.”return”语句中的表达式列表可以是对多返回值函数的一次调用。效果就如同从该函数返回的每个值，都分配给了具有相应值类型的临时变量，后跟列出这些变量的”return”语句，这时就适用前一种情况的规则。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func complexF2() (re float64, im float64) {</span></span>
<span class="line"><span style="color:#babed8">	return complexF1()</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>3.The expression list may be empty if the function’s result type specifies names for its result parameters. The result parameters act as ordinary local variables and the function may assign values to them as necessary. The “return” statement returns the values of these variables.</p>
</blockquote>
<p>3.如果函数的返回值类型具体指定了名称，则表达式列表可能为空。返回值充当普通的局部变量，函数可以根据需要为它们赋值。“return”语句就返回这些变量的值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func complexF3() (re float64, im float64) {</span></span>
<span class="line"><span style="color:#babed8">	re = 7.0</span></span>
<span class="line"><span style="color:#babed8">	im = 4.0</span></span>
<span class="line"><span style="color:#babed8">	return</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func (devnull) Write(p []byte) (n int, _ error) {</span></span>
<span class="line"><span style="color:#babed8">	n = len(p)</span></span>
<span class="line"><span style="color:#babed8">	return</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>Regardless of how they are declared, all the result values are initialized to the zero values for their type upon entry to the function. A “return” statement that specifies results sets the result parameters before any deferred functions are executed.</p>
</blockquote>
<p>无论如何声明，所有结果值在进入函数时都会初始化为其类型的零值。指定结果的”return”语句在执行任何延迟函数之前设置结果参数。</p>
<blockquote>
<p>Implementation restriction: A compiler may disallow an empty expression list in a “return” statement if a different entity (constant, type, or variable) with the same name as a result parameter is in scope at the place of the return.</p>
</blockquote>
<p>实现限制：如果”return”语句位置的范围内存在与返回值参数同名的其他实体（常量、类型或变量），那么编译器可能会禁止在”return”语句中使用空表达式列表。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func f(n int) (res int, err error) {</span></span>
<span class="line"><span style="color:#babed8">	if _, err := f(n-1); err != nil {</span></span>
<span class="line"><span style="color:#babed8">		return  // invalid return statement: err is shadowed</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">	return</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h3 id="break-statements-break-语句">Break statements Break 语句</h3>
<blockquote>
<p>A “break” statement terminates execution of the innermost “for”, “switch”, or “select” statement within the same function.</p>
</blockquote>
<p>“break”语句终止同一函数中最内层的”for”、“switch”或”select”语句的执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">BreakStmt = &quot;break&quot; [ Label ] .</span></span></code></pre>
<blockquote>
<p>If there is a label, it must be that of an enclosing “for”, “switch”, or “select” statement, and that is the one whose execution terminates.</p>
</blockquote>
<p>如果使用标签，后面必须跟闭合的”for”、“switch”或”select”语句，并且是执行终止的语句。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">OuterLoop:</span></span>
<span class="line"><span style="color:#babed8">	for i = 0; i &lt; n; i++ {</span></span>
<span class="line"><span style="color:#babed8">		for j = 0; j &lt; m; j++ {</span></span>
<span class="line"><span style="color:#babed8">			switch a[i][j] {</span></span>
<span class="line"><span style="color:#babed8">			case nil:</span></span>
<span class="line"><span style="color:#babed8">				state = Error</span></span>
<span class="line"><span style="color:#babed8">				break OuterLoop</span></span>
<span class="line"><span style="color:#babed8">			case item:</span></span>
<span class="line"><span style="color:#babed8">				state = Found</span></span>
<span class="line"><span style="color:#babed8">				break OuterLoop</span></span>
<span class="line"><span style="color:#babed8">			}</span></span>
<span class="line"><span style="color:#babed8">		}</span></span>
<span class="line"><span style="color:#babed8">	}</span></span></code></pre>
<h3 id="continue-statements-continue-语句">Continue statements Continue 语句</h3>
<blockquote>
<p>A “continue” statement begins the next iteration of the innermost enclosing “for” loop by advancing control to the end of the loop block. The “for” loop must be within the same function.</p>
</blockquote>
<p>“continue”语句通过将控制推进到循环块的末尾来开始最内层闭合”for”循环的下一轮迭代。“for”循环必须位于同一函数中。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ContinueStmt = &quot;continue&quot; [ Label ] .</span></span></code></pre>
<blockquote>
<p>If there is a label, it must be that of an enclosing “for” statement, and that is the one whose execution advances.</p>
</blockquote>
<p>如果使用标签，标签后面必须跟闭合的”for”语句，并且要推进执行。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">RowLoop:</span></span>
<span class="line"><span style="color:#babed8">	for y, row := range rows {</span></span>
<span class="line"><span style="color:#babed8">		for x, data := range row {</span></span>
<span class="line"><span style="color:#babed8">			if data == endOfRow {</span></span>
<span class="line"><span style="color:#babed8">				continue RowLoop</span></span>
<span class="line"><span style="color:#babed8">			}</span></span>
<span class="line"><span style="color:#babed8">			row[x] = data + bias(x, y)</span></span>
<span class="line"><span style="color:#babed8">		}</span></span>
<span class="line"><span style="color:#babed8">	}</span></span></code></pre>
<h3 id="goto-statements-goto-语句">Goto statements Goto 语句</h3>
<blockquote>
<p>A “goto” statement transfers control to the statement with the corresponding label within the same function.</p>
</blockquote>
<p>“goto”语句将控制权转移到同一函数中对应标签的语句。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">GotoStmt = &quot;goto&quot; Label .</span></span></code></pre>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">goto Error</span></span></code></pre>
<blockquote>
<p>Executing the “goto” statement must not cause any variables to come into scope that were not already in scope at the point of the goto. For instance, this example:</p>
</blockquote>
<p>“goto”语句的执行并不会让任何在 goto 语句处尚未进入作用域的变量，进入作用域。例如，此示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">	goto L  // BAD</span></span>
<span class="line"><span style="color:#babed8">	v := 3</span></span>
<span class="line"><span style="color:#babed8">L:</span></span></code></pre>
<blockquote>
<p>is erroneous because the jump to label L skips the creation of v.</p>
</blockquote>
<p>是错误的，因为跳转到标签 L 会跳过 v 的创建。</p>
<blockquote>
<p>A “goto” statement outside a block cannot jump to a label inside that block. For instance, this example:</p>
</blockquote>
<p>块外的”goto”语句不能跳转到块内的标签。例如，此示例：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">if n%2 == 1 {</span></span>
<span class="line"><span style="color:#babed8">	goto L1</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8">for n &gt; 0 {</span></span>
<span class="line"><span style="color:#babed8">	f()</span></span>
<span class="line"><span style="color:#babed8">	n--</span></span>
<span class="line"><span style="color:#babed8">L1:</span></span>
<span class="line"><span style="color:#babed8">	f()</span></span>
<span class="line"><span style="color:#babed8">	n--</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>is erroneous because the label L1 is inside the “for” statement’s block but the goto is not.</p>
</blockquote>
<p>是错误的，因为标签 L1 在”for”语句的块内，而 goto 不在。</p>
<h3 id="fallthrough-statements-fallthrough-语句">Fallthrough statements fallthrough 语句</h3>
<blockquote>
<p>A “fallthrough” statement transfers control to the first statement of the next case clause in an expression “switch” statement. It may be used only as the final non-empty statement in such a clause.</p>
</blockquote>
<p>“fallthrough”语句将控制权转移到表达式”switch”语句中下一个 case 子句的第一个语句。它只能用作此类子句中的最终非空语句。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">FallthroughStmt = &quot;fallthrough&quot; .</span></span></code></pre>
<h3 id="defer-statements-defer语句">Defer statements defer语句</h3>
<p><em>defer, 延迟。</em></p>
<blockquote>
<p>A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.</p>
</blockquote>
<p>defer语句调用一个函数，这个函数的执行被推迟到上下文函数返回的那一刻；或者是因为上下文函数执行了返回语句，到达了其函数体的末尾，或者是因为相应的goroutine发生了panic。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#BABED8">DeferStmt </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">&quot;</span><span style="color:#C3E88D">defer</span><span style="color:#89DDFF">&quot;</span><span style="color:#BABED8"> Expression </span><span style="color:#89DDFF">.</span></span></code></pre>
<blockquote>
<p>The expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements.</p>
</blockquote>
<p>表达式必须是函数或方法调用；它不能用括号括起来。内建函数的调用与表达式语句一样，也是受到限制的。</p>
<blockquote>
<p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement, deferred functions are executed after any result parameters are set by that return statement but before the function returns to its caller. If a deferred function value evaluates to nil, execution panics when the function is invoked, not when the “defer” statement is executed.</p>
</blockquote>
<p>每次执行defer语句时，调用的函数值和参数都会正常计算并重新保存，但不调用实际函数。相反，defer的函数在上下文函数返回之前立即调用，执行顺序正和defer的顺序相反。也就是说，如果上下文函数显式地通过return语句返回，则defer的函数<strong>在</strong>该return语句设置任何结果参数<strong>之后</strong>，<strong>在</strong>函数返回给其调用方<strong>之前</strong>执行。如果defer函数值的计算结果为nil，则在调用该函数时执行会发生panic，注意不是在执行defer语句时panic。</p>
<blockquote>
<p>For instance, if the deferred function is a function literal and the surrounding function has named result parameters that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on handling panics.)</p>
</blockquote>
<p>例如，如果defer函数是函数字面量（其实就是匿名函数），并且上下文函数使用具名返回值，其作用域位于函数字面量之内（其实含有匿名函数的函数就是闭包），则defer函数可以在return返回值之前访问和修改返回值。如果defer函数有任何返回值，它们会在函数完成时被丢弃。（另请参阅有关处理panic的部分。）</p>
<p><em>简而言之，当一个具名返回值的闭包中defer一个匿名函数时，先从return语句获得具名返回值的值，再由defer计算这个具名返回值。</em><br/>
<em>闭包 + 具名返回值 =&gt; 先return取值，再defer修改值</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#82AAFF">lock</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">l</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic">defer</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">unlock</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">l</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// unlocking happens before surrounding function returns</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// prints 3 2 1 0 before surrounding function returns</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic">for</span><span style="color:#BABED8"> i </span><span style="color:#89DDFF">:=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">0</span><span style="color:#89DDFF">;</span><span style="color:#BABED8"> i </span><span style="color:#89DDFF">&lt;=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">3</span><span style="color:#89DDFF">;</span><span style="color:#BABED8"> i</span><span style="color:#89DDFF">++</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF;font-style:italic">defer</span><span style="color:#BABED8"> fmt</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">Print</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">i</span><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic">// f returns 42</span></span>
<span class="line"><span style="color:#89DDFF">func</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">f</span><span style="color:#89DDFF">()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span><span style="color:#BABED8">result </span><span style="color:#C792EA">int</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF;font-style:italic">defer</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">func()</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">{</span></span>
<span class="line"><span style="color:#BABED8">		</span><span style="color:#676E95;font-style:italic">// result is accessed after it was set to 6 by the return statement</span></span>
<span class="line"><span style="color:#BABED8">		result </span><span style="color:#89DDFF">*=</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">7</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF">}()</span></span>
<span class="line"><span style="color:#BABED8">	</span><span style="color:#89DDFF;font-style:italic">return</span><span style="color:#BABED8"> </span><span style="color:#F78C6C">6</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<h2 id="built-in-functions-内置函数">Built-in functions 内置函数</h2>
<blockquote>
<p>Built-in functions are predeclared. They are called like any other function but some of them accept a type instead of an expression as the first argument.</p>
</blockquote>
<p>内置函数是预先声明好的。它们的调用方式和其他函数是一样的，但其中一些函数的第一个参数接受的是类型，而不是表达式。</p>
<p><em>“预先声明好”意味着用户不需要去定义它，直接调用就可以。至于实现，比如 len() ，编译器会将其转换为 OLEN ，然后根据不同的类型调用相应求长度的方法，比如对数组求长度会调用 cmd/compile/internal/types/type.go 中的 NumELem() 。</em><br/>
<em>“有些函数的第一个参数接受的是类型”，比如 make([]int, 2) ,第一个参数就是类型。</em><br/>
<em>有的资料中也把built-in翻译成内建。</em></p>
<blockquote>
<p>The built-in functions do not have standard Go types, so they can only appear in call expressions; they cannot be used as function values.</p>
</blockquote>
<p>内置函数并不具有标准的 Go 类型，所以它们只能出现在调用表达式中；而不能用作函数值。<br/>
<em>比如说，当我们想实现一个函数，把求数组长度的工作委托出去给其他函数做，可以这样写：<code>DelegateGetLen(arr, GetLen)</code> （其中GetLen自行实现），但不能写 <code>DelegateGetLen(arr, len)</code>, 后者会提示 “len (built-in) must be called”, 就是这个原理。</em></p>
<h3 id="close-关闭通道">Close 关闭（通道）</h3>
<blockquote>
<p>For an argument ch with a core type that is a channel, the built-in function close records that no more values will be sent on the channel. It is an error if ch is a receive-only channel. Sending to or closing a closed channel causes a run-time panic. Closing the nil channel also causes a run-time panic. After calling close, and after any previously sent values have been received, receive operations will return the zero value for the channel’s type without blocking. The multi-valued receive operation returns a received value along with an indication of whether the channel is closed.</p>
</blockquote>
<p>对于核心类型为通道的参数 ch ，内置函数 close 会记录下不会再在通道上发送任何值；<br/>
如果 ch 是只收通道 <code>&lt;-chan</code> ，会报错；<br/>
发送消息，或者重复关闭一个已经关闭了的通道，会引起运行时崩溃 <em>panic</em> ；<br/>
关闭一个空 <em>nil</em> 通道也会引起运行时崩溃 <em>panic</em> ；<br/>
调用 close() 之后，如果收到了先前发送过的值，那么接收操作返回的都是通道类型的零值，而不会阻塞；<br/>
对于多值接收操作，会将返回值与通道是否关闭的标识一并返回；</p>
<h3 id="length-and-capacity-长度和容量">Length and capacity 长度和容量</h3>
<blockquote>
<p>The built-in functions len and cap take arguments of various types and return a result of type int. The implementation guarantees that the result always fits into an int.</p>
</blockquote>
<p>内置函数 len() 和 cap() 可接收多种类型作为参数，并返回int类型的结果。<br/>
其实现保证了结果总是适配于 int.</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Call      Argument type    Result</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">len(s)    string type      string length in bytes</span></span>
<span class="line"><span style="color:#babed8">          [n]T, *[n]T      array length (== n)</span></span>
<span class="line"><span style="color:#babed8">          []T              slice length</span></span>
<span class="line"><span style="color:#babed8">          map[K]T          map length (number of defined keys)</span></span>
<span class="line"><span style="color:#babed8">          chan T           number of elements queued in channel buffer</span></span>
<span class="line"><span style="color:#babed8">          type parameter   see below</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">cap(s)    [n]T, *[n]T      array length (== n)</span></span>
<span class="line"><span style="color:#babed8">          []T              slice capacity</span></span>
<span class="line"><span style="color:#babed8">          chan T           channel buffer capacity</span></span>
<span class="line"><span style="color:#babed8">          type parameter   see below</span></span></code></pre>
<blockquote>
<p>If the argument type is a type parameter P, the call len(e) (or cap(e) respectively) must be valid for each type in P’s type set. The result is the length (or capacity, respectively) of the argument whose type corresponds to the type argument with which P was instantiated.</p>
</blockquote>
<p>如果参数类型是类型参数 P ，则 len(e) （或 cap(e) ）这样一个调用，必须对 P 的类型集中的每个类型都有效。结果是参数的长度（或容量），其类型对应于实例化时使用 P 的类型参数。</p>
<blockquote>
<p>The capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:</p>
</blockquote>
<p>切片的容量是在其内部数组中被分配了空间的元素个数。在任何时候，以下关系都成立：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">0 &lt;= len(s) &lt;= cap(s)</span></span></code></pre>
<blockquote>
<p>The length of a nil slice, map or channel is 0. The capacity of a nil slice or channel is 0.</p>
</blockquote>
<p>空切片，空map，空通道的长度为0. 空切片或空通道的容量为0.</p>
<blockquote>
<p>The expression len(s) is constant if s is a string constant. The expressions len(s) and cap(s) are constants if the type of s is an array or pointer to an array and the expression s does not contain channel receives or (non-constant) function calls; in this case s is not evaluated. Otherwise, invocations of len and cap are not constant and s is evaluated.</p>
</blockquote>
<p>如果 s 是字符串常量，则表达式 len(s) 也是常量。<br/>
如果 s 的类型是数组或指向数组的指针，并且表达式 s 不包含通道接收或（非常量）函数调用，则表达式 s len(s) 和 cap(s) 是常量；在这种情况下 s 不会被求值。否则，对 len 和 cap 的调用就不是常量，会对 s 求值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#89DDFF">const</span><span style="color:#BABED8"> </span><span style="color:#89DDFF">(</span></span>
<span class="line"><span style="color:#BABED8">	c1 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">imag</span><span style="color:#89DDFF">(</span><span style="color:#F78C6C">2i</span><span style="color:#89DDFF">)</span><span style="color:#BABED8">                    </span><span style="color:#676E95;font-style:italic">// imag(2i) = 2.0 is a constant</span></span>
<span class="line"><span style="color:#BABED8">	c2 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">([</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">{</span><span style="color:#F78C6C">2</span><span style="color:#89DDFF">})</span><span style="color:#BABED8">         </span><span style="color:#676E95;font-style:italic">// [10]float64{2} contains no function calls</span></span>
<span class="line"><span style="color:#BABED8">	c3 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">([</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">{</span><span style="color:#BABED8">c1</span><span style="color:#89DDFF">})</span><span style="color:#BABED8">        </span><span style="color:#676E95;font-style:italic">// [10]float64{c1} contains no function calls</span></span>
<span class="line"><span style="color:#BABED8">	c4 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">([</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">{</span><span style="color:#82AAFF">imag</span><span style="color:#89DDFF">(</span><span style="color:#F78C6C">2i</span><span style="color:#89DDFF">)})</span><span style="color:#BABED8">  </span><span style="color:#676E95;font-style:italic">// imag(2i) is a constant and no function call is issued</span></span>
<span class="line"><span style="color:#BABED8">	c5 </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> </span><span style="color:#82AAFF">len</span><span style="color:#89DDFF">([</span><span style="color:#F78C6C">10</span><span style="color:#89DDFF">]</span><span style="color:#C792EA">float64</span><span style="color:#89DDFF">{</span><span style="color:#82AAFF">imag</span><span style="color:#89DDFF">(</span><span style="color:#BABED8">z</span><span style="color:#89DDFF">)})</span><span style="color:#BABED8">   </span><span style="color:#676E95;font-style:italic">// invalid: imag(z) is a (non-constant) function call</span></span>
<span class="line"><span style="color:#89DDFF">)</span></span>
<span class="line"><span style="color:#89DDFF">var</span><span style="color:#BABED8"> z </span><span style="color:#C792EA">complex128</span></span></code></pre>
<h3 id="allocation-分配">Allocation 分配</h3>
<blockquote>
<p>The built-in function new takes a type T, allocates storage for a variable of that type at run time, and returns a value of type *T pointing to it. The variable is initialized as described in the section on initial values.</p>
</blockquote>
<p>内置函数 new 接收一个类型 T ，在运行时为该类型的变量分配空间，并返回 *T类型（指向它） 的值。变量是按照初始值一节中的说明来初始化的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">new(T)</span></span></code></pre>
<h4 id="for-instance-例如">For instance 例如</h4>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type S struct { a int; b float64 }</span></span>
<span class="line"><span style="color:#babed8">new(S)</span></span></code></pre>
<blockquote>
<p>allocates storage for a variable of type S, initializes it (a=0, b=0.0), and returns a value of type *S containing the address of the location.</p>
</blockquote>
<p>为类型 S 的变量分配空间，会把它初始化为 (a=0, b=0.0)，并返回 *S 类型的值，这个值包含了地址。</p>
<h3 id="making-slices-maps-and-channels-创建切片map和通道">Making slices, maps and channels 创建切片、map和通道</h3>
<blockquote>
<p>The built-in function make takes a type T, optionally followed by a type-specific list of expressions. The core type of T must be a slice, map or channel. It returns a value of type T (not *T). The memory is initialized as described in the section on initial values.</p>
</blockquote>
<p>内置函数 make 接收一个类型T，跟在后面的一组特定类型的表达式是可选的。<br/>
T的核心类型只能是切片、map或通道。<br/>
它的返回值的类型是T，而不是T*。<br/>
内存是按照初始值一节中的说明来初始化的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Call             Core type    Result</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">make(T, n)       slice        slice of type T with length n and capacity n</span></span>
<span class="line"><span style="color:#babed8">make(T, n, m)    slice        slice of type T with length n and capacity m</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">make(T)          map          map of type T</span></span>
<span class="line"><span style="color:#babed8">make(T, n)       map          map of type T with initial space for approximately n elements</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">make(T)          channel      unbuffered channel of type T</span></span>
<span class="line"><span style="color:#babed8">make(T, n)       channel      buffered channel of type T, buffer size n</span></span></code></pre>
<blockquote>
<p>Each of the size arguments n and m must be of integer type, have a type set containing only integer types, or be an untyped constant. A constant size argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. If both n and m are provided and are constant, then n must be no larger than m. For slices and channels, if n is negative or larger than m at run time, a run-time panic occurs.</p>
</blockquote>
<p>每个 size 参数 n m 都必须是整数类型，具有仅包含整数类型的类型集，或者是非类型化常量。常量大小参数必须是非负数，并且可由 type int 的值表示;如果它是一个非类型常量，则给定类型 int 。如果同时 n 提供 和 m 并且是常量， n 则不得大于 m 。对于切片和通道，如果为负数或大于 m 运行时，则 n 会发生运行时崩溃。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100</span></span>
<span class="line"><span style="color:#babed8">s := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000</span></span>
<span class="line"><span style="color:#babed8">s := make([]int, 1&lt;&lt;63)         // illegal: len(s) is not representable by a value of type int</span></span>
<span class="line"><span style="color:#babed8">s := make([]int, 10, 0)         // illegal: len(s) &gt; cap(s)</span></span>
<span class="line"><span style="color:#babed8">c := make(chan int, 10)         // channel with a buffer size of 10</span></span>
<span class="line"><span style="color:#babed8">m := make(map[string]int, 100)  // map with initial space for approximately 100 elements</span></span></code></pre>
<blockquote>
<p>Calling make with a map type and size hint n will create a map with initial space to hold n map elements. The precise behavior is implementation-dependent.</p>
</blockquote>
<p>调用 make 时，带上map类型和大小的提示值n，将会创建一个具有n个元素那么多的初始空间的map。不过，其实际的行为，是取决于实现的。</p>
<h3 id="appending-to-and-copying-slices-追加元素到和拷贝切片">Appending to and copying slices 追加（元素到）和拷贝切片</h3>
<blockquote>
<p>The built-in functions append and copy assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.</p>
</blockquote>
<p>append 和 copy 这两个内置函数用于在常见的切片操作中提供支持。<br/>
对于这两个函数，结果与参数引用的内存是否重叠无关。</p>
<blockquote>
<p>The variadic function append appends zero or more values x to a slice s and returns the resulting slice of the same type as s. The core type of s must be a slice of type []E. The values x are passed to a parameter of type …E and the respective parameter passing rules apply. As a special case, if the core type of s is []byte, append also accepts a second argument with core type bytestring followed by … This form appends the bytes of the byte slice or string.</p>
</blockquote>
<p>可变参数函数 append 会将零个或多个值 x 追加到切片 s 上，返回一个类型与 s 相同的切片。<br/>
s 的核心类型必须是 []E 。<br/>
（追加的多个）值x，是以 …E 形式的参数传递（给函数 append ）的，并且各自的参数传递规则也都是适用的。<br/>
但是有特例，如果 s 的核心类型是 []byte，那么函数 append 还需要接收第二个跟着…的、核心类型为bytestring的参数。这个形式是用来追加字符切片或者字符串中的字节的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">append(s S, x ...E) S  // core type of S is []E</span></span></code></pre>
<blockquote>
<p>If the capacity of s is not large enough to fit the additional values, append allocates a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, append re-uses the underlying array.</p>
</blockquote>
<p>如果切片 s 的容量装不下这些追加的值，那么函数 append 会分配一个新的、足够大的底层数组，（这个新数组）能同时装下已有的切片元素和追加值。否则，函数 append 会复用底层数组。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">s0 := []int{0, 0}</span></span>
<span class="line"><span style="color:#babed8">s1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}</span></span>
<span class="line"><span style="color:#babed8">s2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}</span></span>
<span class="line"><span style="color:#babed8">s3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}</span></span>
<span class="line"><span style="color:#babed8">s4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var t []interface{}</span></span>
<span class="line"><span style="color:#babed8">t = append(t, 42, 3.1415, &quot;foo&quot;)   //                             t == []interface{}{42, 3.1415, &quot;foo&quot;}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var b []byte</span></span>
<span class="line"><span style="color:#babed8">b = append(b, &quot;bar&quot;...)            // append string contents      b == []byte{&#39;b&#39;, &#39;a&#39;, &#39;r&#39; }</span></span></code></pre>
<blockquote>
<p>The function copy copies slice elements from a source src to a destination dst and returns the number of elements copied. The core types of both arguments must be slices with identical element type. The number of elements copied is the minimum of len(src) and len(dst). As a special case, if the destination’s core type is []byte, copy also accepts a source argument with core type bytestring. This form copies the bytes from the byte slice or string into the byte slice.</p>
</blockquote>
<p>函数 copy 会从源 src 中复制切片元素到目的 dst 中，并返回复制的元素个数。这两个参数（ src 和 dst ）的核心类型都必须是带有相同元素类型的切片。复制的元素个数是 len(src) 和 len(dst) 当中较小的那一个。但是有特例，如果 dst 的核心类型是 []byte ，那么函数 copy 还会接收一个带有核心类型bytestring的源（切片）参数。这个形式是用来复制字符切片或者字符串中的字节到（新的）字节切片中的。</p>
<p><em>按照这个描述，如果 dsc 容量太小装不下，元素是有可能复制少了的。</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">copy(dst, src []T) int</span></span>
<span class="line"><span style="color:#babed8">copy(dst []byte, src string) int</span></span></code></pre>
<h4 id="examples-例子">Examples: 例子：</h4>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}</span></span>
<span class="line"><span style="color:#babed8">var s = make([]int, 6)</span></span>
<span class="line"><span style="color:#babed8">var b = make([]byte, 5)</span></span>
<span class="line"><span style="color:#babed8">n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}</span></span>
<span class="line"><span style="color:#babed8">n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}</span></span>
<span class="line"><span style="color:#babed8">n3 := copy(b, &quot;Hello, World!&quot;)  // n3 == 5, b == []byte(&quot;Hello&quot;)</span></span></code></pre>
<h3 id="deletion-of-map-elements-删除map元素">Deletion of map elements 删除map元素</h3>
<blockquote>
<p>The built-in function delete removes the element with key k from a map m. The value k must be assignable to the key type of m.</p>
</blockquote>
<p>内置函数 delete 会从 map m 中移除键 k 对应的元素。<br/>
k值类型必须与 m 的键类型一致。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">delete(m, k)  // remove element m[k] from map m</span></span></code></pre>
<blockquote>
<p>If the type of m is a type parameter, all types in that type set must be maps, and they must all have identical key types.</p>
</blockquote>
<p>如果 m 的类型是类型参数，则该类型集中的所有类型都必须是 map ，并且它们的键类型都必须一致。</p>
<blockquote>
<p>If the map m is nil or the element m[k] does not exist, delete is a no-op.</p>
</blockquote>
<p>如果map m 是 nil 或者元素 m[k] 不存在，删除操作什么事情都不会做（do nothing）。</p>
<h3 id="manipulating-complex-numbers-操纵复数">Manipulating complex numbers 操纵复数</h3>
<blockquote>
<p>Three functions assemble and disassemble complex numbers. The built-in function complex constructs a complex value from a floating-point real and imaginary part, while real and imag extract the real and imaginary parts of a complex value.</p>
</blockquote>
<p>（提供了）三个（内置）函数用于组装和拆解复数。<br/>
内置函数 complex 用来基于浮点的实部和虚部构造复数；
相应的，real 和 imag 函数用来提取复数的实部和虚部。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">complex(realPart, imaginaryPart floatT) complexT</span></span>
<span class="line"><span style="color:#babed8">real(complexT) floatT</span></span>
<span class="line"><span style="color:#babed8">imag(complexT) floatT</span></span></code></pre>
<blockquote>
<p>The type of the arguments and return value correspond. For complex, the two arguments must be of the same floating-point type and the return type is the complex type with the corresponding floating-point constituents: complex64 for float32 arguments, and complex128 for float64 arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly converted to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.</p>
</blockquote>
<p>参数和返回值的类型是相对应的。<br/>
对于函数 complex，两个参数必须是同一种浮点类型，返回值也是相应的浮点成分组成的复数类型。返回值complex64对应float32；返回值complex128对应float64。<br/>
如果参数之一计算出是无类型常量，则首先将它隐式转化为另一个参数的类型；<br/>
如果两个参数计算出都是无类型常量，它们都不可以是复数，或者它们的虚部都必须为0，返回值也是一个无类型的复数常量。</p>
<blockquote>
<p>For real and imag, the argument must be of complex type, and the return type is the corresponding floating-point type: float32 for a complex64 argument, and float64 for a complex128 argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.</p>
</blockquote>
<p>对于函数 real 和 imag，参数必须是复数类型，返回值类型只能是相对应的浮点类型：float32对应于complex64类型，float64对应于complex128类型。如果参数计算出是无类型常量，那么它必须是数字；返回值是无类型浮点常量。</p>
<blockquote>
<p>The real and imag functions together form the inverse of complex, so for a value z of a complex type Z, z == Z(complex(real(z), imag(z))).</p>
</blockquote>
<p>函数 real 和 imag 共同组成了 函数 complex 的逆运算，因此对于复数类型Z的值z，有（以下关系成立）：<code>z == Z(complex(real(z), imag(z)))</code> 。</p>
<blockquote>
<p>If the operands of these functions are all constants, the return value is a constant.</p>
</blockquote>
<p>如果这些函数的操作数全都是常量，那么返回值也是一个常量。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var a = complex(2, -2)             // complex128</span></span>
<span class="line"><span style="color:#babed8">const b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i</span></span>
<span class="line"><span style="color:#babed8">x := float32(math.Cos(math.Pi/2))  // float32</span></span>
<span class="line"><span style="color:#babed8">var c64 = complex(5, -x)           // complex64</span></span>
<span class="line"><span style="color:#babed8">var s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int</span></span>
<span class="line"><span style="color:#babed8">_ = complex(1, 2&lt;&lt;s)               // illegal: 2 assumes floating-point type, cannot shift</span></span>
<span class="line"><span style="color:#babed8">var rl = real(c64)                 // float32</span></span>
<span class="line"><span style="color:#babed8">var im = imag(a)                   // float64</span></span>
<span class="line"><span style="color:#babed8">const c = imag(b)                  // untyped constant -1.4</span></span>
<span class="line"><span style="color:#babed8">_ = imag(3 &lt;&lt; s)                   // illegal: 3 assumes complex type, cannot shift</span></span></code></pre>
<blockquote>
<p>Arguments of type parameter type are not permitted.</p>
</blockquote>
<p>参数不可以是类型参数类型。</p>
<h3 id="handling-panics-处理panic">Handling panics 处理panic</h3>
<blockquote>
<p>Two built-in functions, panic and recover, assist in reporting and handling run-time panics and program-defined error conditions.</p>
</blockquote>
<p>两个内置函数， panic 和 recover ，用于报告和处理运行时崩溃以及程序定义的错误场景。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func panic(interface{})</span></span>
<span class="line"><span style="color:#babed8">func recover() interface{}</span></span></code></pre>
<blockquote>
<p>While executing a function F, an explicit call to panic or a run-time panic terminates the execution of F. Any functions deferred by F are then executed as usual. Next, any deferred functions run by F’s caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to panic. This termination sequence is called panicking.</p>
</blockquote>
<p>当执行函数 F 时，一个对 panic() 的显式调用，或者运行时崩溃都会中断函数 F 的执行。<br/>
F 中 defer 调用的任何函数仍然正常执行。<br/>
因此， F 中任何 defer 调用的函数都会执行，以此类推，一直执行到当前执行中的协程中的最顶层函数中的defer调用的函数。<br/>
到那时候，程序会中断，错误场景及传递给 panic() 的参数会被报告。<br/>
我们称这个中断序列为 panicking (崩溃中)。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">panic(42)</span></span>
<span class="line"><span style="color:#babed8">panic(&quot;unreachable&quot;)</span></span>
<span class="line"><span style="color:#babed8">panic(Error(&quot;cannot parse&quot;))</span></span></code></pre>
<blockquote>
<p>The recover function allows a program to manage behavior of a panicking goroutine. Suppose a function G defers a function D that calls recover and a panic occurs in a function on the same goroutine in which G is executing. When the running of deferred functions reaches D, the return value of D’s call to recover will be the value passed to the call of panic. If D returns normally, without starting a new panic, the panicking sequence stops. In that case, the state of functions called between G and the call to panic is discarded, and normal execution resumes. Any functions deferred by G before D are then run and G’s execution terminates by returning to its caller.</p>
</blockquote>
<p>recover 函数允许一个程序管理 panicking (恐慌中) 的协程的行为。<br/>
假设一个函数 G defer 调用函数 D ，D 带有一个 recover 调用。同时负责执行函数 G 的那个协程中的一个函数发生了 panic :<br/>
那么当 defer 调用的函数运行到了 D, D 中的 recover 调用的返回值，就会被传递给 panic 调用。<br/>
如果 D 正常返回，没有发生新的 panic ，这个（协程的）panicking 状态也就结束了。<br/>
在这种情况下，G 和 panic 调用之间的那部分所调用的函数状态就都丢失了，恢复正常执行。<br/>
在 D 之前的 G 中的任何 defer 函数调用之后都会被运行，而 G 的执行会由于它的调用得到返回而终止。</p>
<blockquote>
<p>The return value of recover is nil if any of the following conditions holds:</p>
</blockquote>
<p>以下任一条件满足，recover 就会返回 nil :</p>
<blockquote>
<p>panic’s argument was nil;</p>
</blockquote>
<p>panic 的参数是nil;</p>
<blockquote>
<p>the goroutine is not panicking;</p>
</blockquote>
<p>协程不在 panicking 状态；</p>
<blockquote>
<p>recover was not called directly by a deferred function.</p>
</blockquote>
<p>recover 没有被一个 defer 调用的函数直接调用。</p>
<blockquote>
<p>The protect function in the example below invokes the function argument g and protects callers from run-time panics raised by g.</p>
</blockquote>
<p>下面例子中的 protect 函数调用了函数参数 g 并保护调用者免受 g 引起的运行时panic 影响。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func protect(g func()) {</span></span>
<span class="line"><span style="color:#babed8">	defer func() {</span></span>
<span class="line"><span style="color:#babed8">		log.Println(&quot;done&quot;)  // Println executes normally even if there is a panic</span></span>
<span class="line"><span style="color:#babed8">		if x := recover(); x != nil {</span></span>
<span class="line"><span style="color:#babed8">			log.Printf(&quot;run time panic: %v&quot;, x)</span></span>
<span class="line"><span style="color:#babed8">		}</span></span>
<span class="line"><span style="color:#babed8">	}()</span></span>
<span class="line"><span style="color:#babed8">	log.Println(&quot;start&quot;)</span></span>
<span class="line"><span style="color:#babed8">	g()</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h3 id="bootstrapping-引导">Bootstrapping 引导</h3>
<blockquote>
<p>Current implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.</p>
</blockquote>
<p>当前的实现提供了几个引导期间有用的内置函数。这些函数虽然提供了详尽的文档，但不保证一直保留在这门语言中。它们没有返回值。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Function   Behavior</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">print      prints all arguments; formatting of arguments is implementation-specific</span></span>
<span class="line"><span style="color:#babed8">println    like print but prints spaces between arguments and a newline at the end</span></span></code></pre>
<p><em>也就是说，你的代码里最好不要大量地显式写出 print 或 println ,因为它们将来可能被废弃。你可以把它们封装一层，以方便未来的修改。</em></p>
<blockquote>
<p>Implementation restriction: print and println need not accept arbitrary argument types, but printing of boolean, numeric, and string types must be supported.</p>
</blockquote>
<p>实现方面的限制要求： print 和 println 不需要接收任意参数类型，但必须支持布尔、数值和字符串类型的打印。</p>
<h2 id="packages-包">Packages 包</h2>
<blockquote>
<p>Go programs are constructed by linking together packages. A package in turn is constructed from one or more source files that together declare constants, types, variables and functions belonging to the package and which are accessible in all files of the same package. Those elements may be exported and used in another package.</p>
</blockquote>
<p>Go程序是通过将多个包连接在一起构建出来的。每个包又各自是由一至多个声明了属于该包的常量、类型、变量和函数的源码文件构成，同一个包中的所有文件都是可见的。这些元素也可以被导出来并用在其他包里。</p>
<h3 id="source-file-organization-源文件组织">Source file organization 源文件组织</h3>
<blockquote>
<p>Each source file consists of a package clause defining the package to which it belongs, followed by a possibly empty set of import declarations that declare packages whose contents it wishes to use, followed by a possibly empty set of declarations of functions, types, variables, and constants.</p>
</blockquote>
<p>每个源文件是由一个定义了它应该归属于哪个包的 package 语句及一组（也可能没有）声明了要使用哪些包上下文的 import 语句，以及一组（也可能没有）函数、类型、变量和常量声明等所组成。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">SourceFile       = PackageClause &quot;;&quot; { ImportDecl &quot;;&quot; } { TopLevelDecl &quot;;&quot; } .</span></span></code></pre>
<h3 id="package-clause-package-语句">Package clause package 语句</h3>
<blockquote>
<p>A package clause begins each source file and defines the package to which the file belongs.</p>
</blockquote>
<p>一个 package 语句位于源文件开头，定义了这个文件属于哪个包。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">PackageClause  = &quot;package&quot; PackageName .</span></span>
<span class="line"><span style="color:#babed8">PackageName    = identifier .</span></span></code></pre>
<blockquote>
<p>The PackageName must not be the blank identifier.</p>
</blockquote>
<p>包名不可以是空白标识符。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">package math</span></span></code></pre>
<blockquote>
<p>A set of files sharing the same PackageName form the implementation of a package. An implementation may require that all source files for a package inhabit the same directory.</p>
</blockquote>
<p>一组包名相同的文件，就是实现一个包的形式。实现可能要求一个包下所有源文件都应该位于同一目录。</p>
<h3 id="import-declarations-import-声明">Import declarations import 声明</h3>
<blockquote>
<p>An import declaration states that the source file containing the declaration depends on functionality of the imported package (§Program initialization and execution) and enables access to exported identifiers of that package. The import names an identifier (PackageName) to be used for access and an ImportPath that specifies the package to be imported.</p>
</blockquote>
<p>一个 import 声明说明了源文件包含的声明依赖于那些被导入的包的功能（参见 Program initialization and execution 小节），并可以访问到那个包导出的标识符。import 命名了一个标识符（包名）用于访问，和一个导入路径用于具体指出包从哪里导入进来。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">ImportDecl       = &quot;import&quot; ( ImportSpec | &quot;(&quot; { ImportSpec &quot;;&quot; } &quot;)&quot; ) .</span></span>
<span class="line"><span style="color:#babed8">ImportSpec       = [ &quot;.&quot; | PackageName ] ImportPath .</span></span>
<span class="line"><span style="color:#babed8">ImportPath       = string_lit .</span></span></code></pre>
<blockquote>
<p>The PackageName is used in qualified identifiers to access exported identifiers of the package within the importing source file. It is declared in the file block. If the PackageName is omitted, it defaults to the identifier specified in the package clause of the imported package. If an explicit period (.) appears instead of a name, all the package’s exported identifiers declared in that package’s package block will be declared in the importing source file’s file block and must be accessed without a qualifier.</p>
</blockquote>
<p>包名被用在限定标识符中以便访问导入源文件中那些包的导出标识符。它的声明是文件层级的。如果包名被省略，则默认使用导入包语句中指定的标识符。如果一个显式的句点（.）替代了包名，那么包导出的所有包级标识符都会在导入源文件的文件级别中声明，使用时前面也不能加限定。</p>
<blockquote>
<p>The interpretation of the ImportPath is implementation-dependent but it is typically a substring of the full file name of the compiled package and may be relative to a repository of installed packages.</p>
</blockquote>
<p>导入路径如何解释是取决于实现的，但它通常是已编译的包的完整文件名的子字符串，可能是基于导入包的仓库的相对路径。</p>
<blockquote>
<p>Implementation restriction: A compiler may restrict ImportPaths to non-empty strings using only characters belonging to Unicode’s L, M, N, P, and S general categories (the Graphic characters without spaces) and may also exclude the characters <code>!&quot;#$%&amp;&#39;()*,:;&lt;=&gt;?[\]^`````{|}</code> and the Unicode replacement character U+FFFD.</p>
</blockquote>
<p>实现约束：编译器会将导入路径限制为非空字符串，仅使用属于 Unicode 的 L、M、N、P 和 S 常规类别的字符（不带空格的图形字符），还可以排除字符和 Unicode 替换字符 <code>!&quot;#$%&amp;&#39;()*,:;&lt;=&gt;?[\]^`````{|}</code> U+FFFD。</p>
<blockquote>
<p>Consider a compiled a package containing the package clause package math, which exports function Sin, and installed the compiled package in the file identified by “lib/math”. This table illustrates how Sin is accessed in files that import the package after the various types of import declaration.</p>
</blockquote>
<p>考虑一个编译的包，包含包语句 <code>package math</code> ，它导出函数 <code>Sin</code> ，并将编译后的包安装在由 “lib/math” 标识的文件中。下表说明了如何在各种类型的导入声明后导入包的文件中访问 <code>Sin</code> 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">Import declaration          Local name of Sin</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">import   &quot;lib/math&quot;         math.Sin</span></span>
<span class="line"><span style="color:#babed8">import m &quot;lib/math&quot;         m.Sin</span></span>
<span class="line"><span style="color:#babed8">import . &quot;lib/math&quot;         Sin</span></span></code></pre>
<blockquote>
<p>An import declaration declares a dependency relation between the importing and imported package. It is illegal for a package to import itself, directly or indirectly, or to directly import a package without referring to any of its exported identifiers. To import a package solely for its side-effects (initialization), use the blank identifier as explicit package name:</p>
</blockquote>
<p>导入声明语句声明了导入包和被导入的包之间的依赖关系。包直接或间接导入自身，或直接导入包而不引用其任何导出的标识符都是非法的。如果仅仅是为了副作用（初始化）而导入包，应使用空白标识符作为显式的包名：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">import _ &quot;lib/math&quot;</span></span></code></pre>
<h3 id="an-example-package-一个示例包">An example package 一个示例包</h3>
<blockquote>
<p>Here is a complete Go package that implements a concurrent prime sieve.</p>
</blockquote>
<p>这是一个完整的 Go 包，它实现了并发素数筛。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">package main</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">import &quot;fmt&quot;</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// Send the sequence 2, 3, 4, … to channel &#39;ch&#39;.</span></span>
<span class="line"><span style="color:#babed8">func generate(ch chan&lt;- int) {</span></span>
<span class="line"><span style="color:#babed8">	for i := 2; ; i++ {</span></span>
<span class="line"><span style="color:#babed8">		ch &lt;- i  // Send &#39;i&#39; to channel &#39;ch&#39;.</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// Copy the values from channel &#39;src&#39; to channel &#39;dst&#39;,</span></span>
<span class="line"><span style="color:#babed8">// removing those divisible by &#39;prime&#39;.</span></span>
<span class="line"><span style="color:#babed8">func filter(src &lt;-chan int, dst chan&lt;- int, prime int) {</span></span>
<span class="line"><span style="color:#babed8">	for i := range src {  // Loop over values received from &#39;src&#39;.</span></span>
<span class="line"><span style="color:#babed8">		if i%prime != 0 {</span></span>
<span class="line"><span style="color:#babed8">			dst &lt;- i  // Send &#39;i&#39; to channel &#39;dst&#39;.</span></span>
<span class="line"><span style="color:#babed8">		}</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">// The prime sieve: Daisy-chain filter processes together.</span></span>
<span class="line"><span style="color:#babed8">func sieve() {</span></span>
<span class="line"><span style="color:#babed8">	ch := make(chan int)  // Create a new channel.</span></span>
<span class="line"><span style="color:#babed8">	go generate(ch)       // Start generate() as a subprocess.</span></span>
<span class="line"><span style="color:#babed8">	for {</span></span>
<span class="line"><span style="color:#babed8">		prime := &lt;-ch</span></span>
<span class="line"><span style="color:#babed8">		fmt.Print(prime, &quot;\n&quot;)</span></span>
<span class="line"><span style="color:#babed8">		ch1 := make(chan int)</span></span>
<span class="line"><span style="color:#babed8">		go filter(ch, ch1, prime)</span></span>
<span class="line"><span style="color:#babed8">		ch = ch1</span></span>
<span class="line"><span style="color:#babed8">	}</span></span>
<span class="line"><span style="color:#babed8">}</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func main() {</span></span>
<span class="line"><span style="color:#babed8">	sieve()</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h2 id="program-initialization-and-execution-程序初始化和执行">Program initialization and execution 程序初始化和执行</h2>
<h3 id="the-zero-value-零值">The zero value 零值</h3>
<blockquote>
<p>When storage is allocated for a variable, either through a declaration or a call of new, or when a new value is created, either through a composite literal or a call of make, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the zero value for its type: false for booleans, 0 for numeric types, &quot;&quot; for strings, and nil for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.</p>
</blockquote>
<p>当通过声明或调用 new 函数的形式将存储分配给一个变量，或者通过组合字面量或调用 make 函数创建一个新值，并且没有提供显式初始化，那么变量或值设定的就是默认值；<br/>
此类变量或值的每个元素都设置为其类型的零值：布尔类型设为 false , 数值类型设为 0 , 字符串设为 &quot;&quot; , 指针、函数、接口、切片、通道和 map 都设为 nil ；<br/>
这个初始化是递归完成的，因此比如说，如果没有指定初始化的具体值，那么结构体数组的每个字段都会被设置零值；</p>
<blockquote>
<p>These two simple declarations are equivalent:</p>
</blockquote>
<p>以下两个简单的声明是等效的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var i int</span></span>
<span class="line"><span style="color:#babed8">var i int = 0</span></span></code></pre>
<blockquote>
<p>After</p>
</blockquote>
<p>之后</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type T struct { i int; f float64; next *T }</span></span>
<span class="line"><span style="color:#babed8">t := new(T)</span></span></code></pre>
<blockquote>
<p>the following holds:</p>
</blockquote>
<p>以下成立：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">t.i == 0</span></span>
<span class="line"><span style="color:#babed8">t.f == 0.0</span></span>
<span class="line"><span style="color:#babed8">t.next == nil</span></span></code></pre>
<blockquote>
<p>The same would also be true after</p>
</blockquote>
<p>之后也是如此</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var t T</span></span></code></pre>
<h3 id="package-initialization-包的初始化">Package initialization 包的初始化</h3>
<blockquote>
<p>Within a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in declaration order which has no dependencies on uninitialized variables.</p>
</blockquote>
<p>在包中，包级变量初始化依次进行，每个步骤都会选择那些不依赖于未初始化变量的变量的声明顺序，先后进行。</p>
<blockquote>
<p>More precisely, a package-level variable is considered ready for initialization if it is not yet initialized and either has no initialization expression or its initialization expression has no dependencies on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.</p>
</blockquote>
<p>更精确地说，如果一个包级变量尚未初始化，并且也没有初始化表达式，或者其初始化表达式并不依赖于未初始化的变量，则认为该变量已准备好可以进行初始化了。初始化过程通过不停地初始化下一个最早声明并准备初始化的包级变量来进行，一直到实在没有已准备好初始化的变量了才停下。</p>
<blockquote>
<p>If any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.</p>
</blockquote>
<p>如果这个过程一直到结束时都没有能初始化任何一个变量，那么这些变量实际上属于一个或多个初始化周期的一部分，那这部分程序也就成了无效的。</p>
<blockquote>
<p>Multiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.</p>
</blockquote>
<p>左侧的多个变量声明，是由右侧的单个（多<em>返回</em>值）表达式初始化的变量声明一起初始化的：如果左侧的任何变量被初始化完成，那么这些变量也一定是在同一步骤中初始化完成的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x = a</span></span>
<span class="line"><span style="color:#babed8">var a, b = f() // a and b are initialized together, before x is initialized</span></span></code></pre>
<blockquote>
<p>For the purpose of package initialization, blank variables are treated like any other variables in declarations.</p>
</blockquote>
<p>出于包初始化的目的，空白变量被视为声明中的任何其他变量。</p>
<blockquote>
<p>The declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on.</p>
</blockquote>
<p>在多个文件中的变量声明顺序是由文件传递给编译器的顺序决定的：在第一个文件中声明的变量会在第二个文件中声明的任何变量之前声明，依此类推。</p>
<blockquote>
<p>Dependency analysis does not rely on the actual values of the variables, only on lexical references to them in the source, analyzed transitively. For instance, if a variable x’s initialization expression refers to a function whose body refers to variable y then x depends on y. Specifically:</p>
</blockquote>
<p>依赖关系分析并不依赖于变量的实际值，仅仅依赖于源代码中对它们的词法引用，这种分析会传递进行。例如，如果一个变量 x 的初始化表达式中引用了一个函数体中引用了变量 y 的函数，那么 x 会依赖于 y 。具体有：</p>
<blockquote>
<p>A reference to a variable or function is an identifier denoting that variable or function.</p>
</blockquote>
<p>（上文中所称的）“对变量或函数的引用”指的是一个代表该变量或函数的标识符。</p>
<blockquote>
<p>A reference to a method m is a method value or method expression of the form t.m, where the (static) type of t is not an interface type, and the method m is in the method set of t. It is immaterial whether the resulting function value t.m is invoked.</p>
</blockquote>
<p>一个对方法 m 的引用是一个方法值，或者 t.m 这种形式的方法表达式，其中 t 的（静态）类型不是接口类型，并且该方法 m 在 t 的方法集中。至于 t.m 的函数返回值是不是会被调用，这无关紧要。</p>
<blockquote>
<p>A variable, function, or method x depends on a variable y if x’s initialization expression or body (for functions and methods) contains a reference to y or to a function or method that depends on y.</p>
</blockquote>
<p>如果 x 的初始化表达式或（函数）体（和方法体）包含了对 y 的引用，就称这个变量 x 或函数 / 方法 x 是依赖于变量 y 的。</p>
<blockquote>
<p>For example, given the declarations</p>
</blockquote>
<p>例如，给定声明</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var (</span></span>
<span class="line"><span style="color:#babed8">	a = c + b  // == 9</span></span>
<span class="line"><span style="color:#babed8">	b = f()    // == 4</span></span>
<span class="line"><span style="color:#babed8">	c = f()    // == 5</span></span>
<span class="line"><span style="color:#babed8">	d = 3      // == 5 after initialization has finished</span></span>
<span class="line"><span style="color:#babed8">)</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func f() int {</span></span>
<span class="line"><span style="color:#babed8">	d++</span></span>
<span class="line"><span style="color:#babed8">	return d</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>the initialization order is d, b, c, a. Note that the order of subexpressions in initialization expressions is irrelevant: a = c + b and a = b + c result in the same initialization order in this example.</p>
</blockquote>
<p>（上面这个例子的）初始化顺序应该是 d, b, c, a. 注意：初始化表达式中的子表达式顺序无关紧要： a = c + b 和 a = b + c 的结果在这个例子里位于同一个初始化序列中。</p>
<blockquote>
<p>Dependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.</p>
</blockquote>
<p>每个包是单独执行依赖关系分析的；只会考虑当前包中声明的变量、函数和（非接口）方法的引用。如果变量之间还存在其他的、隐式的数据依赖，那这些变量的初始化顺序是不能够确定的。</p>
<blockquote>
<p>For instance, given the declarations</p>
</blockquote>
<p>例如，给定声明</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x = I(T{}).ab()   // x has an undetected, hidden dependency on a and b</span></span>
<span class="line"><span style="color:#babed8">var _ = sideEffect()  // unrelated to x, a, or b</span></span>
<span class="line"><span style="color:#babed8">var a = b</span></span>
<span class="line"><span style="color:#babed8">var b = 42</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type I interface      { ab() []int }</span></span>
<span class="line"><span style="color:#babed8">type T struct{}</span></span>
<span class="line"><span style="color:#babed8">func (T) ab() []int   { return []int{a, b} }</span></span></code></pre>
<blockquote>
<p>the variable a will be initialized after b but whether x is initialized before b, between b and a, or after a, and thus also the moment at which sideEffect() is called (before or after x is initialized) is not specified.</p>
</blockquote>
<p>变量 a 在 b 之后初始化，但 x 是否一定在 b 之前，还是在 b 和 a 之间，或者 a 之后初始化，甚至副作用 sideEffect() 被调用（是在x被初始化之前还是之后）的时机，都是不确定的。</p>
<blockquote>
<p>Variables may also be initialized using functions named init declared in the package block, with no arguments and no result parameters.</p>
</blockquote>
<p>变量也可以通过包块中声明的 init 函数来初始化，这个 init 函数是没有参数和返回值的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func init() { … }</span></span></code></pre>
<blockquote>
<p>Multiple such functions may be defined per package, even within a single source file. In the package block, the init identifier can be used only to declare init functions, yet the identifier itself is not declared. Thus init functions cannot be referred to from anywhere in a program.</p>
</blockquote>
<p>每个包中可以定义多个这样的（init）函数，即使在单个源文件中也可以。在包块中， init 标识符只能用于声明函数，但标识符本身不会被声明。因此在程序中的任何地方都不能引用到 init 函数。</p>
<blockquote>
<p>A package with no imports is initialized by assigning initial values to all its package-level variables followed by calling all init functions in the order they appear in the source, possibly in multiple files, as presented to the compiler. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies.</p>
</blockquote>
<p>一个没有导入语句的包，它的初始化，是通过按照源码文件中各个 init 函数出现的先后顺序来为其所有包级变量分配初始值。（它们也可能在多个文件中，以传递给编译器的为准）<br/>
如果这个包有导入语句，则在初始化包本身之前，先初始化导入的包。<br/>
如果多个包导入同一个包，则导入的包只会初始化一次。<br/>
包的导入机制通过构建确保了不会有循环初始化依赖。</p>
<blockquote>
<p>Package initialization—variable initialization and the invocation of init functions—happens in a single goroutine, sequentially, one package at a time. An init function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the init functions: it will not invoke the next one until the previous one has returned.</p>
</blockquote>
<p>包初始化——变量初始化和 init 函数调用——是在同一个协程中发生的，按顺序来，一次一个包。一个 init 函数里也可能启动其他协程，这些协程可以和初始化代码同时运行。但是，初始化总是会确保 init 函数有序：只要前一个 init 还没返回，就不会去调用下一个 init 。</p>
<blockquote>
<p>To ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.</p>
</blockquote>
<p>为了确保初始化行为是可复现的，鼓励构建系统按照词法文件名的顺序，把同一个包里的多个文件，传递给编译器。</p>
<h3 id="program-execution-程序执行">Program execution 程序执行</h3>
<blockquote>
<p>A complete program is created by linking a single, unimported package called the main package with all the packages it imports, transitively. The main package must have package name main and declare a function main that takes no arguments and returns no value.</p>
</blockquote>
<p>通过将单个未导入的包（称为 main 包）及其导入的所有包（可传递的）链接起来，创建完整的程序。 main 包的包名必须是 main ，并声明一个不带参数且不返回任何值的函数 main 。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func main() { … }</span></span></code></pre>
<blockquote>
<p>Program execution begins by initializing the main package and then invoking the function main. When that function invocation returns, the program exits. It does not wait for other (non-main) goroutines to complete.</p>
</blockquote>
<p>程序的执行，从 main 包的初始化开始，然后调用函数 main 。当 main 函数调用返回时，程序就会退出。它不会等待其他（非 main ）的协程完成。</p>
<h2 id="errors-错误">Errors 错误</h2>
<blockquote>
<p>The predeclared type error is defined as</p>
</blockquote>
<p>预声明的类型 error 定义为</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type error interface {</span></span>
<span class="line"><span style="color:#babed8">	Error() string</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<blockquote>
<p>It is the conventional interface for representing an error condition, with the nil value representing no error. For instance, a function to read data from a file might be defined:</p>
</blockquote>
<p>它是表示错误条件的普通接口， nil 值表示没有错误。例如，可以定义一个从文件中读取数据的函数：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">func Read(f *File, b []byte) (n int, err error)</span></span></code></pre>
<h2 id="run-time-panics-运行时panic">Run-time panics 运行时panic</h2>
<blockquote>
<p>Execution errors such as attempting to index an array out of bounds trigger a run-time panic equivalent to a call of the built-in function panic with a value of the implementation-defined interface type runtime.Error. That type satisfies the predeclared interface type error. The exact error values that represent distinct run-time error conditions are unspecified.</p>
</blockquote>
<p>执行错误（例如尝试越界索引数组）会触发运行时崩溃，等效于（主动）调用带有实现定义的接口类型 runtime.Error 的值的内置函数 panic 。该类型满足预声明的接口类型 error 。表示不同运行时错误条件的确切错误值，是不确定的。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">package runtime</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type Error interface {</span></span>
<span class="line"><span style="color:#babed8">	error</span></span>
<span class="line"><span style="color:#babed8">	// and perhaps other methods</span></span>
<span class="line"><span style="color:#babed8">}</span></span></code></pre>
<h2 id="system-considerations-系统注意事项">System considerations 系统注意事项</h2>
<h3 id="package-unsafe-unsafe包">Package unsafe unsafe包</h3>
<blockquote>
<p>The built-in package unsafe, known to the compiler and accessible through the import path “unsafe”, provides facilities for low-level programming including operations that violate the type system. A package using unsafe must be vetted manually for type safety and may not be portable. The package provides the following interface:</p>
</blockquote>
<p>内置包 unsafe 对编译器是已知的，可以通过 “unsafe” 这个导入路径来访问，提供了包括违反类型系统的操作在内的低级编程基础设施。一个使用了 unsafe 的包必须手动审查类型安全，且可能是不可移植的。这个包提供如下接口：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">package unsafe</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type</span></span>
<span class="line"><span style="color:#babed8">type Pointer *ArbitraryType</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">func Alignof(variable ArbitraryType) uintptr</span></span>
<span class="line"><span style="color:#babed8">func Offsetof(selector ArbitraryType) uintptr</span></span>
<span class="line"><span style="color:#babed8">func Sizeof(variable ArbitraryType) uintptr</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type IntegerType int  // shorthand for an integer type; it is not a real type</span></span>
<span class="line"><span style="color:#babed8">func Add(ptr Pointer, len IntegerType) Pointer</span></span>
<span class="line"><span style="color:#babed8">func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType</span></span>
<span class="line"><span style="color:#babed8">func SliceData(slice []ArbitraryType) *ArbitraryType</span></span>
<span class="line"><span style="color:#babed8">func String(ptr *byte, len IntegerType) string</span></span>
<span class="line"><span style="color:#babed8">func StringData(str string) *byte</span></span></code></pre>
<blockquote>
<p>A Pointer is a pointer type but a Pointer value may not be dereferenced. Any pointer or value of underlying type uintptr can be converted to a type of underlying type Pointer and vice versa. The effect of converting between Pointer and uintptr is implementation-defined.</p>
</blockquote>
<p>一个 Pointer 是一个指针类型，但是一个 Pointer 的值可能是无法解引用的。任何 pointer 或者基础类型 uintptr 的值都可以被转换成 Pointer 基础类型，反过来也可以。 Pointer 和 uintptr 之间转换的实际效果取决于实现。</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var f float64</span></span>
<span class="line"><span style="color:#babed8">bits = *(*uint64)(unsafe.Pointer(&amp;f))</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">type ptr unsafe.Pointer</span></span>
<span class="line"><span style="color:#babed8">bits = *(*uint64)(ptr(&amp;f))</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">var p ptr = nil</span></span></code></pre>
<blockquote>
<p>The functions Alignof and Sizeof take an expression x of any type and return the alignment or size, respectively, of a hypothetical variable v as if v was declared via var v = x.</p>
</blockquote>
<p>Alignof 和 Sizeof 函数接收一个任意类型的表达式 x ，并分别返回假想变量 v 的对齐（倍数）或大小，就好像 v 是通过 <code>var v = x</code> 声明的一样。</p>
<p><em>示例：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">var x = 2</span></span>
<span class="line"><span style="color:#babed8">fmt.Println(unsafe.Sizeof(x))</span></span>
<span class="line"><span style="color:#babed8">fmt.Println(unsafe.Alignof(x))</span></span></code></pre>
<p><em>返回结果：</em></p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">8</span></span>
<span class="line"><span style="color:#babed8">8</span></span></code></pre>
<blockquote>
<p>The function Offsetof takes a (possibly parenthesized) selector s.f, denoting a field f of the struct denoted by s or *s, and returns the field offset in bytes relative to the struct’s address. If f is an embedded field, it must be reachable without pointer indirections through fields of the struct. For a struct s with field f:</p>
</blockquote>
<p>该函数 Offsetof 采用一个选择器（可能带括号） s.f , 表示 s 或 *s 结构中 的字段 f ，并返回相对于结构体地址的字段 偏移量（以字节为单位）。如果是嵌套字段，则它必须是无需指针间接通过结构的字段即可访问的。对于带有字段 f 的结构体 s :</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))</span></span></code></pre>
<blockquote>
<p>Computer architectures may require memory addresses to be aligned; that is, for addresses of a variable to be a multiple of a factor, the variable’s type’s alignment. The function Alignof takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable x:</p>
</blockquote>
<p>计算机体系结构可能需要对齐内存地址；就是说变量的类型对齐方式，对于一个变量的地址，需要是因子的倍数。该函数 Alignof 接收一个任意类型的变量的表达式，并返回这个变量（的类型）的对齐方式（以字节为单位）。对于变量 x :</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0</span></span></code></pre>
<blockquote>
<p>A (variable of) type T has variable size if T is a type parameter, or if it is an array or struct type containing elements or fields of variable size. Otherwise the size is constant. Calls to Alignof, Offsetof, and Sizeof are compile-time constant expressions of type uintptr if their arguments (or the struct s in the selector expression s.f for Offsetof) are types of constant size.</p>
</blockquote>
<p>如果 T 是类型参数，或者它是一个数组或包含了元素的结构体类型，或者带变量大小的字段，那么该类型（的变量） T 具有可变的大小。反之，大小就是恒定的。对于 Alignof, Offsetof, Sizeof 函数的调用，如果它们的参数（或结构体 s 位于 Offsetof 的选择器表达式 s.f 里）是固定大小的类型时，它们在编译时就都是 uintptr 类型的常量表达式。</p>
<blockquote>
<p>The function Add adds len to ptr and returns the updated pointer unsafe.Pointer(uintptr(ptr) + uintptr(len)). The len argument must be of integer type or an untyped constant. A constant len argument must be representable by a value of type int; if it is an untyped constant it is given type int. The rules for valid uses of Pointer still apply.</p>
</blockquote>
<p>函数 Add 把 len 添加到 ptr 上，并返回更新的指针 unsafe.Pointer(uintptr(ptr) + uintptr(len)) . 参数  len 必须是整数类型，或者一个无类型常量。len 常量参数必须可以由 int 类型的值表示出来；如果它是无类型常量，则它是给定的 int 类型。这些规则对于指针的使用同样适用。</p>
<blockquote>
<p>The function Slice returns a slice whose underlying array starts at ptr and whose length and capacity are len. Slice(ptr, len) is equivalent to</p>
</blockquote>
<p>Slice 函数返回一个切片，它的底层数组从 ptr 开始，其长度和容量都是 len 。 Slice(ptr, len) 就相当于</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]</span></span></code></pre>
<blockquote>
<p>except that, as a special case, if ptr is nil and len is zero, Slice returns nil.</p>
</blockquote>
<p>除了一种特殊情况：如果 ptr 为 nil 且 len 为零，那么 Slice 返回 nil .</p>
<blockquote>
<p>The len argument must be of integer type or an untyped constant. A constant len argument must be non-negative and representable by a value of type int; if it is an untyped constant it is given type int. At run time, if len is negative, or if ptr is nil and len is not zero, a run-time panic occurs.</p>
</blockquote>
<p>参数 len 必须是整数类型或无类型常量。常量 len 参数必须是非负的，并且可用 int 类型的值表示出来；如果它是一个无类型常量，则给定类型 int 。在运行时，如果 len 为负数，或者如果 ptr 为 nil 且 len 不为零，就会发生运行时 panic .</p>
<blockquote>
<p>The function SliceData returns a pointer to the underlying array of the slice argument. If the slice’s capacity cap(slice) is not zero, that pointer is &amp;slice[:1][0]. If slice is nil, the result is nil. Otherwise it is a non-nil pointer to an unspecified memory address.</p>
</blockquote>
<p>SliceData 函数返回一个指针，指针指向 slice 参数的底层数组。如果切片的容量 cap(slice) 不为零，则该指针为 &amp;slice[:1][0] 。如果切片为 nil ，则结果为 nil 。否则，它是指向不特定的内存地址的非空指针。</p>
<blockquote>
<p>The function String returns a string value whose underlying bytes start at ptr and whose length is len. The same requirements apply to the ptr and len argument as in the function Slice. If len is zero, the result is the empty string &quot;&quot;. Since Go strings are immutable, the bytes passed to String must not be modified afterwards.</p>
</blockquote>
<p>String 函数返回一个字符串值，其底层字节从 ptr 开始，长度为 len 。 同样的要求也适用于 Slice 函数中的 ptr 和 len 参数。如果 len 为零，则结果为空字符串 &quot;&quot; 。由于 Go 字符串是不可变的，因此之后不应该再去修改传递给 String 函数的bytes .</p>
<blockquote>
<p>The function StringData returns a pointer to the underlying bytes of the str argument. For an empty string the return value is unspecified, and may be nil. Since Go strings are immutable, the bytes returned by StringData must not be modified.</p>
</blockquote>
<p>StringData 函数返回指向 str 参数的底层字节的指针。对于空字符串，返回值是不确定的，也许是 nil 。由于 Go 字符串是不可变的，因此之后不应该再去修改传递给 StringData 函数的bytes .</p>
<h3 id="size-and-alignment-guarantees-大小与对齐保证">Size and alignment guarantees 大小与对齐保证</h3>
<blockquote>
<p>For the numeric types, the following sizes are guaranteed:</p>
</blockquote>
<p>对于数值类型，以下大小是确定的：</p>
<pre class="relative shadow-2xl bg-black code"><button aria-label="copy-button" class="copy-button absolute  z-20 top-2 right-2  rounded-md transition-all ease-in max-w-full max-h-fit hover:text-indigo-400"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z"></path><path d="M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2"></path></svg></button><span class="check-span absolute z-10 top-2 right-2  rounded-md transition-all ease-in opacity-0 text-green-300 max-w-full max-h-fit "><svg class="icon icon-tabler icon-tabler-check" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5 12l5 5l10 -10"></path></svg></span><code><span class="line"><span style="color:#babed8">type                                 size in bytes</span></span>
<span class="line"><span style="color:#babed8"></span></span>
<span class="line"><span style="color:#babed8">byte, uint8, int8                     1</span></span>
<span class="line"><span style="color:#babed8">uint16, int16                         2</span></span>
<span class="line"><span style="color:#babed8">uint32, int32, float32                4</span></span>
<span class="line"><span style="color:#babed8">uint64, int64, float64, complex64     8</span></span>
<span class="line"><span style="color:#babed8">complex128                           16</span></span></code></pre>
<blockquote>
<p>The following minimal alignment properties are guaranteed:</p>
</blockquote>
<p>以下最小对齐属性也可以保证：</p>
<blockquote>
<ol>
<li>For a variable x of any type: unsafe.Alignof(x) is at least 1.</li>
</ol>
</blockquote>
<p>对于任意类型的变量 x , unsafe.Alignof(x) 至少为1</p>
<blockquote>
<ol start="2">
<li>For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.</li>
</ol>
</blockquote>
<p>对于结构体变量 x , unsafe.Alignof(x) 取 x 中每个字段 f 对应 unsafe.Alignof(x.f) 中最大的一个，且一定大于等于1</p>
<blockquote>
<ol start="3">
<li>For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array’s element type.</li>
</ol>
</blockquote>
<p>对于数组类型变量 x , unsafe.Alignof(x) 与数组的每一个元素变量的类型的对齐值一致。</p>
<blockquote>
<p>A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.</p>
</blockquote>
<p>如果结构体或数组类型不包含大小大于零的字段（或元素），则该结构体或数组类型的大小为零。两个不同的零大小变量，其内存地址可能相同。</p>
<h2 id="appendix-附录">Appendix 附录</h2>
<h3 id="type-unification-rules-类型统一规则">Type unification rules 类型统一规则</h3>
<blockquote>
<p>The type unification rules describe if and how two types unify. The precise details are relevant for Go implementations, affect the specifics of error messages (such as whether a compiler reports a type inference or other error), and may explain why type inference fails in unusual code situations. But by and large these rules can be ignored when writing Go code: type inference is designed to mostly “work as expected”, and the unification rules are fine-tuned accordingly.</p>
</blockquote>
<p>类型统一规则描述了两种类型是否可以统一以及如何统一。精确的细节与 Go 的实现相关，而影响错误消息的细节（比如编译器是否会报告类型推断或者其他错误），并且可以解释为什么类型推断在异常代码情况下会失败。但总而言之，这些规则在编写 Go 代码时可以忽略：类型推断会尽量设计成“按预期工作的”，并且统一规则也会相应地进行微调。</p>
<blockquote>
<p>Type unification is controlled by a matching mode, which may be exact or loose. As unification recursively descends a composite type structure, the matching mode used for elements of the type, the element matching mode, remains the same as the matching mode except when two types are unified for assignability (≡A): in this case, the matching mode is loose at the top level but then changes to exact for element types, reflecting the fact that types don’t have to be identical to be assignable.</p>
</blockquote>
<p>类型统一由匹配模式来控制，可以是精确的，也可以是宽松的。当统一过程递归下降一个组合类型结构时，用于该类型元素的匹配模式（元素匹配模式）会保持与匹配模式相同，除非两个类型被统一用于可赋值性（ ≡A ）：这种情况下，匹配模式在顶层是宽松的，但随后会变为元素类型的精确匹配，反映了类型不必相同即可赋值这一事实。</p>
<blockquote>
<p>Two types that are not bound type parameters unify exactly if any of following conditions is true:</p>
</blockquote>
<p>满足以下任一条件，未绑定类型参数的两种类型就精确统一：</p>
<blockquote>
<ul>
<li>Both types are identical.</li>
</ul>
</blockquote>
<p>两种类型相同。</p>
<blockquote>
<ul>
<li>Both types have identical structure and their element types unify exactly.</li>
</ul>
</blockquote>
<p>两种类型结构相同，并且它们的元素类型也精确统一。</p>
<blockquote>
<ul>
<li>Exactly one type is an unbound type parameter with a core type, and that core type unifies with the other type per the unification rules for ≡A (loose unification at the top level and exact unification for element types).</li>
</ul>
</blockquote>
<p>有且仅有一种类型是具有核心类型的未绑定类型参数，并且该核心类型是根据 ≡A 的统一规则来统一其他类型（顶层的宽松统一和元素类型的精确统一）。</p>
<blockquote>
<p>If both types are bound type parameters, they unify per the given matching modes if:</p>
</blockquote>
<p>如果两种类型都是绑定类型参数，则它们根据给定的匹配模式来统一，如果（满足以下）：</p>
<blockquote>
<ul>
<li>Both type parameters are identical.</li>
</ul>
</blockquote>
<p>两个类型参数相同。</p>
<blockquote>
<ul>
<li>At most one of the type parameters has a known type argument. In this case, the type parameters are joined: they both stand for the same type argument. If neither type parameter has a known type argument yet, a future type argument inferred for one the type parameters is simultaneously inferred for both of them.</li>
</ul>
</blockquote>
<p>最多一个类型形参具有已知的类型实参。在这种情况下，类型参数会被连接起来：它们都代表相同的类型参数。如果两个类型形参都没有已知的类型实参，那么对其中一个类型参数进行推断得到的未来类型实参将对这两个类型参数同时适用。</p>
<blockquote>
<ul>
<li>Both type parameters have a known type argument and the type arguments unify per the given matching modes.</li>
</ul>
</blockquote>
<p>两个类型参数都有一个已知的类型参数，并且类型参数根据给定的匹配模式来统一。</p>
<blockquote>
<p>A single bound type parameter P and another type T unify per the given matching modes if:</p>
</blockquote>
<p>单个绑定类型参数 P 和另一个类型 T 根据给定的匹配模式来统一，如果（满足以下）：</p>
<blockquote>
<ul>
<li>P doesn’t have a known type argument. In this case, T is inferred as the type argument for P.</li>
</ul>
</blockquote>
<p>P 没有已知的类型参数。在这个例子中， T 被推断为 P 的类型实参。</p>
<blockquote>
<ul>
<li>P does have a known type argument A, A and T unify per the given matching modes, and one of the following conditions is true:</li>
</ul>
</blockquote>
<p>P 确实有一个已知类型参数 A ， A 和 T 根据给定的匹配模式来统一，并且满足以下条件之一：</p>
<blockquote>
<ul>
<li>Both A and T are interface types: In this case, if both A and T are also defined types, they must be identical. Otherwise, if neither of them is a defined type, they must have the same number of methods (unification of A and T already established that the methods match).</li>
</ul>
</blockquote>
<p>A 和 T 都是接口类型：这种情况下，如果 A 和 T 也是已定义类型，则它们必须相同。否则，如果它们都不是已定义的类型，则它们必须具有相同数量的方法（ A 和 T 的统一已经建立起了方法匹配）。</p>
<blockquote>
<ul>
<li>Neither A nor T are interface types: In this case, if T is a defined type, T replaces A as the inferred type argument for P.</li>
</ul>
</blockquote>
<p>A 和 T 都不是接口类型：这种情况下，如果 T 是已定义的类型，则 T 会替换掉 A 的推断类型参数。</p>
<blockquote>
<p>Finally, two types that are not bound type parameters unify loosely (and per the element matching mode) if:</p>
</blockquote>
<p>最后，两种未绑定类型参数的类型会宽松统一（且会按照元素匹配模式），如果（满足以下）：</p>
<blockquote>
<ul>
<li>Both types unify exactly.</li>
</ul>
</blockquote>
<p>两种类型精确统一。</p>
<blockquote>
<ul>
<li>One type is a defined type, the other type is a type literal, but not an interface, and their underlying types unify per the element matching mode.</li>
</ul>
</blockquote>
<p>一种类型是已定义类型，另一种类型是类型字面量，但不是一个接口，并且它们的底层类型也按照元素匹配模式来统一。</p>
<blockquote>
<ul>
<li>Both types are interfaces (but not type parameters) with identical type terms, both or neither embed the predeclared type comparable, corresponding method types unify per the element matching mode, and the method set of one of the interfaces is a subset of the method set of the other interface.</li>
</ul>
</blockquote>
<p>两种类型都具有相同类型项的接口（但不是类型参数），都嵌入或者都不嵌入预声明的可比较类型，相应的方法类型按照元素匹配模式来统一，并且其中一个接口的方法集是该方法集的子集的另一个接口。</p>
<blockquote>
<ul>
<li>Only one type is an interface (but not a type parameter), corresponding methods of the two types unify per the element matching mode, and the method set of the interface is a subset of the method set of the other type.</li>
</ul>
</blockquote>
<p>只有一种类型是接口（但不是类型参数），两种类型对应的方法按照元素匹配方式来统一，并且接口的方法集是另一种类型的方法集的子集。</p>
<blockquote>
<ul>
<li>Both types have the same structure and their element types unify per the element matching mode.</li>
</ul>
</blockquote>
<p>两种类型结构相同，并且它们的元素类型按照元素匹配模式来统一。</p></div></article></div></div></article><footer class="flex justify-center items-center w-full px-16 h-28 border-t-2">
&copy; 2023 github.com/swordtraveller. All rights reserved.
</footer></main></body></html><script>
	const img = document.querySelector('img')
	const placeholder = document.querySelector('.placeholder')

	img?.addEventListener('load', () => {
		img.classList.add('opacity-100')
		placeholder.classList.add('opacity-0')
	})
</script>